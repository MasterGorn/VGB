<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Chesstendo - Draft + Plateau</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
<script>

const config = {
  type: Phaser.AUTO,
  width: 600,
  height: 600,
  backgroundColor: '#ececec',
  scene: { preload, create, update }
};

const TILE_SIZE = 40;
const GRID_SIZE = 15;

let grid = [];
let pieces = [];
let currentPlayer = 0; // index joueur qui doit jouer
let gameStarted = false;
let selectedPiece = null;
let highlightedTiles = [];
let turnText;

// --- BUDGET / DRAFT ---
let players = [];

// catalogue de persos
const catalog = {
  link: { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3, color: 0xff0000 },
  mario: { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2, color: 0x0000ff },
  zelda: { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8, color: 0x00ff00 },
  // Pi√®ce sp√©ciale automatique par joueur (non draft√©e)
  nintendo: { cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1, color: 0x222222, draft: false }
};

// Draft UI
let infoText;
let choiceButtons = [];
let choiceThumbs = [];
let armyThumbs = [];
let armyLabels = [];
let endDraftBtn;
let armyPanels = [];
let armyHints = [];
let clearAllBtn;
let playerCountBtns = [];

function preload() {
  // Chemin relatif (fonctionne quel que soit le port/domaine du serveur local)
  this.load.setPath('public/images/characters/');
  this.load.image('mario', 'sprite-mario.png');
  this.load.image('link', 'sprite-link.png');
  // zelda utilise temporairement le sprite de samus
  this.load.image('zelda', 'sprite-samus.png');
  // nintendo utilise le sprite de pit
  this.load.image('nintendo', 'sprite-pit.png');
}

function create() {
  infoText = this.add.text(10, 10, "", { font: "16px Arial", fill: "#000" });
  infoText.setDepth(1000);
  setupPlayerCountUI(this);
}

function setupPlayerCountUI(scene) {
  infoText.setText("Choisissez le nombre de joueurs (2 √† 4)");
  const options = [2,3,4];
  let x = 10;
  let y = 40;
  options.forEach(n => {
    const btn = scene.add.text(x, y, `${n} joueurs`, { font: "16px Arial", fill: "#000", backgroundColor: "#ddd" })
      .setInteractive()
      .on("pointerdown", () => selectPlayerCount(scene, n));
    playerCountBtns.push(btn);
    y += 30;
  });
}

function selectPlayerCount(scene, n) {
  players = Array.from({ length: n }, (_, i) => ({ id: i, points: 20, army: [] }));
  currentPlayer = 0;
  // nettoyer UI de s√©lection
  playerCountBtns.forEach(b => b.destroy());
  playerCountBtns = [];
  // lancer l'UI de draft
  setupDraftUI(scene);
  updateDraftUI();
}

function setupDraftUI(scene) {
  let y = 50;
  for (let key in catalog) {
    if (catalog[key].draft === false) continue; // ne pas afficher 'nintendo' dans le draft
    const img = scene.add.image(35, y, key)
      .setDisplaySize(52,52)
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const nameText = scene.add.text(70, y - 12, `${key}`, { font: "16px Arial", fill: "#000" })
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const costText = scene.add.text(70, y + 10, `cost: ${catalog[key].cost}` , { font: "12px Arial", fill: "#333" });
    choiceThumbs.push({ key, image: img, nameText, costText });
    y += 70;
  }

  // bouton "Terminer"
  endDraftBtn = scene.add.text(10, y+10, "‚úÖ Terminer draft", 
    { font: "16px Arial", fill: "#000", backgroundColor: "#afa" })
    .setInteractive()
    .on("pointerdown", () => endDraft(scene));

  // bouton "Tout supprimer"
  clearAllBtn = scene.add.text(180, y+10, "üóëÔ∏è Tout supprimer", 
    { font: "16px Arial", fill: "#000", backgroundColor: "#faa" })
    .setInteractive()
    .on("pointerdown", () => clearCurrentBasket(scene));

  // labels/panneaux/hints dynamiques selon nombre de joueurs
  armyLabels = [];
  armyPanels = [];
  armyHints = [];
  armyThumbs = Array.from({ length: players.length }, () => []);
  for (let i = 0; i < players.length; i++) {
    const baseLabelY = 30 + i*70;
    armyLabels[i] = scene.add.text(300, baseLabelY, `√âquipe J${i+1}`, { font: "16px Arial", fill: "#000" });
    armyPanels[i] = scene.add.rectangle(450, baseLabelY + 35, 280, 50, 0xffffff, 0).setStrokeStyle(0);
    armyHints[i] = scene.add.text(300, baseLabelY + 15, "Cliquez pour retirer", { font: "12px Arial", fill: "#555" });
  }
  renderArmyThumbnails(scene);
}

function updateDraftUI() {
  let p = players[currentPlayer];
  infoText.setText(`Joueur ${p.id+1} - Points restants: ${p.points}\nChoisissez vos persos`);
  updateChoiceAvailability();
  const scene = infoText.scene;
  renderArmyThumbnails(scene);
  if (clearAllBtn) {
    clearAllBtn.setText(`üóëÔ∏è Tout supprimer (J${currentPlayer+1})`);
  }
}

function updateChoiceAvailability() {
  const p = players[currentPlayer];
  for (let entry of choiceThumbs) {
    const affordable = p.points >= catalog[entry.key].cost;
    entry.image.setAlpha(affordable ? 1 : 0.4);
    entry.nameText.setAlpha(affordable ? 1 : 0.5);
    entry.costText.setAlpha(affordable ? 1 : 0.5);
    if (affordable) {
      entry.image.setInteractive();
      entry.nameText.setInteractive();
    } else {
      entry.image.disableInteractive();
      entry.nameText.disableInteractive();
    }
  }
}

function renderArmyThumbnails(scene) {
  // nettoyer existants
  for (let i = 0; i < armyThumbs.length; i++) {
    for (let img of armyThumbs[i]) { img.destroy(); }
    armyThumbs[i] = [];
  }
  // re-cr√©er
  players.forEach((pl,i) => {
    const baseY = 60 + i*70;
    pl.army.forEach((charKey, idx) => {
      const img = scene.add.image(300 + idx*45, baseY, charKey).setDisplaySize(32,32);
      if (i === currentPlayer && !gameStarted) {
        img.setInteractive().on("pointerdown", () => removeArmyItem(scene, i, idx));
      } else {
        img.disableInteractive();
        img.setAlpha(0.9);
      }
      armyThumbs[i].push(img);
    });
  });
}

function removeArmyItem(scene, playerIndex, itemIndex) {
  if (gameStarted) return;
  if (playerIndex !== currentPlayer) return;
  const key = players[playerIndex].army[itemIndex];
  if (!key) return;
  players[playerIndex].army.splice(itemIndex, 1);
  players[playerIndex].points += catalog[key].cost;
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function clearCurrentBasket(scene) {
  if (gameStarted) return;
  const p = players[currentPlayer];
  // Confirmation
  if (!window.confirm(`Voulez-vous supprimer tous les choix du Joueur ${currentPlayer+1} ?`)) {
    return;
  }
  // rembourser tous les choix
  let refund = 0;
  for (let key of p.army) {
    refund += catalog[key].cost;
  }
  p.points += refund;
  p.army = [];
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function pickCharacter(scene, key) {
  let p = players[currentPlayer];
  let char = catalog[key];
  if (p.points >= char.cost) {
    p.points -= char.cost;
    p.army.push(key);
    updateDraftUI();
  }
}

function endDraft(scene) {
  if (currentPlayer === players.length-1) {
    // Tous les joueurs ont fini => lancer la partie
    startGame(scene);
  } else {
    currentPlayer++;
    updateDraftUI();
  }
}

function startGame(scene) {
  gameStarted = true;
  currentPlayer = 0;
  infoText.setText("D√©but de la partie !");
  // cacher l'UI de draft
  choiceButtons.forEach(btn => btn.setVisible(false));
  if (endDraftBtn) endDraftBtn.setVisible(false);
  if (choiceThumbs && choiceThumbs.length) {
    choiceThumbs.forEach(entry => {
      entry.image.setVisible(false);
      entry.nameText.setVisible(false);
      entry.costText.setVisible(false);
    });
  }
  if (clearAllBtn) clearAllBtn.setVisible(false);
  if (armyLabels && armyLabels.length) {
    armyLabels.forEach(lbl => lbl && lbl.setVisible(false));
  }
  if (armyThumbs && armyThumbs.length) {
    armyThumbs.forEach(list => list.forEach(img => img && img.setVisible(false)));
  }
  if (armyPanels && armyPanels.length) {
    armyPanels.forEach(r => r && r.setVisible(false));
  }
  if (armyHints && armyHints.length) {
    armyHints.forEach(t => t && t.setVisible(false));
  }

  // cr√©er la grille
  for (let y=0; y<GRID_SIZE; y++) {
    grid[y] = [];
    for (let x=0; x<GRID_SIZE; x++) {
      const baseColor = (x+y)%2===0 ? 0xffffff : 0xcccccc;
      const rect = scene.add.rectangle(
        x*TILE_SIZE + TILE_SIZE/2,
        y*TILE_SIZE + TILE_SIZE/2,
        TILE_SIZE-2, TILE_SIZE-2,
        baseColor
      ).setStrokeStyle(1,0x000000).setInteractive();
      rect.baseColor = baseColor;
      rect.pos = {x,y};
      rect.on('pointerdown', () => handleClick(scene, rect.pos));
      grid[y][x] = rect;
    }
  }

  // Helpers placement
  const getPlayerSide = (index) => {
    if (index === 0) return 'top';
    if (index === 1) return 'bottom';
    if (index === 2) return 'left';
    return 'right';
  };
  const mid = Math.floor(GRID_SIZE / 2);

  const getBlockSlotsForSide = (side) => {
    // G√©n√©rer une spirale en coordonn√©es locales (autour de 0,0) puis mapper vers la grille
    let minDX, maxDX, minDY, maxDY;
    if (side === 'top' || side === 'bottom') {
      minDX = -2; maxDX = 2; minDY = 0; maxDY = 3; // 5x4
    } else { // left / right
      minDX = 0; maxDX = 3; minDY = -2; maxDY = 2; // 4x5
    }
    const area = (maxDX - minDX + 1) * (maxDY - minDY + 1);
    const needed = area - 1; // case du roi exclue

    const dirs = [ [1,0], [0,1], [-1,0], [0,-1] ]; // droite, bas, gauche, haut
    let stepLen = 1;
    let dirIndex = 0;
    let lx = 0, ly = 0; // coords locales
    const offsets = [];
    while (offsets.length < needed && stepLen < 100) {
      for (let repeat = 0; repeat < 2; repeat++) {
        const [dxStep, dyStep] = dirs[dirIndex];
        for (let s = 0; s < stepLen; s++) {
          lx += dxStep; ly += dyStep;
          if (lx >= minDX && lx <= maxDX && ly >= minDY && ly <= maxDY && !(lx === 0 && ly === 0)) {
            offsets.push({ dx: lx, dy: ly });
            if (offsets.length >= needed) break;
          }
        }
        dirIndex = (dirIndex + 1) % 4;
        if (offsets.length >= needed) break;
      }
      stepLen++;
    }

    // Map vers les coordonn√©es grille selon le c√¥t√©
    const slots = [];
    if (side === 'top') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: 0 + o.dy });
    } else if (side === 'bottom') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: GRID_SIZE - 1 - o.dy });
    } else if (side === 'left') {
      for (const o of offsets) slots.push({ x: 0 + o.dx, y: mid + o.dy });
    } else if (side === 'right') {
      for (const o of offsets) slots.push({ x: GRID_SIZE - 1 - o.dx, y: mid + o.dy });
    }
    return slots;
  };

  // 1) Placer les rois (nintendo) au centre exact du bord
  players.forEach((p,i) => {
    const side = getPlayerSide(i);
    let pos = { x: mid, y: 0 };
    if (side === 'top') pos = { x: mid, y: 0 };
    if (side === 'bottom') pos = { x: mid, y: GRID_SIZE - 1 };
    if (side === 'left') pos = { x: 0, y: mid };
    if (side === 'right') pos = { x: GRID_SIZE - 1, y: mid };
    pieces.push({ sprite: scene.add.image(0,0,'nintendo'), type: 'nintendo', x: pos.x, y: pos.y, player: p.id });
  });

  // 2) Placer les autres pi√®ces en partant du bord propre √† chaque joueur
  players.forEach((p,i) => {
    const side = getPlayerSide(i);
    const slots = getBlockSlotsForSide(side);
    let si = 0;
    p.army.forEach((charKey) => {
      // avancer jusqu'√† trouver un slot libre
      while (si < slots.length && getPieceAt(slots[si])) si++;
      if (si >= slots.length) return; // plus de place dans le bloc
      const pos = slots[si];
      pieces.push({ sprite: scene.add.image(0,0,charKey), type: charKey, x: pos.x, y: pos.y, player: p.id });
      si++;
    });
  });

  updatePieces();
  // Cr√©er un texte d√©di√© pour le tour, centr√© en haut et au-dessus de tout
  turnText = scene.add.text(config.width/2, 10, "", { font: "18px Arial", fill: "#000", backgroundColor: "#fff" })
    .setOrigin(0.5, 0)
    .setDepth(2000);
  updateTurnUI();
}

function updatePieces() {
  for (let p of pieces) {
    p.sprite.x = p.x*TILE_SIZE + TILE_SIZE/2;
    p.sprite.y = p.y*TILE_SIZE + TILE_SIZE/2;
    // ajuster la taille pour remplir la case moins une marge de bordure
    const margin = 4; // 2px de chaque c√¥t√©
    const targetSize = TILE_SIZE - margin;
    p.sprite.setDisplaySize(targetSize, targetSize);
  }
}

function handleClick(scene, pos) {
  if (!gameStarted) return;
  const clickedPiece = getPieceAt(pos);

  // S√©lection d'une pi√®ce du joueur courant
  if (clickedPiece && clickedPiece.player === currentPlayer) {
    selectedPiece = clickedPiece;
    const reachable = getReachablePositions(selectedPiece);
    highlightPositions(reachable);
    return;
  }

  // D√©placement si une pi√®ce est s√©lectionn√©e et la case est atteignable
  if (selectedPiece) {
    const reachable = getReachablePositions(selectedPiece);
    const isReachable = reachable.some(p => p.x === pos.x && p.y === pos.y);
    if (isReachable) {
      // Capture √©ventuelle sur la case cible
      const target = getPieceAt(pos);
      if (target && target.player !== selectedPiece.player) {
        const capturedNintendo = target.type === 'nintendo';
        target.sprite.destroy();
        pieces = pieces.filter(p => p !== target);
        // D√©placer la pi√®ce du joueur sur la case captur√©e
        selectedPiece.x = pos.x;
        selectedPiece.y = pos.y;
        updatePieces();
        clearHighlights();
        selectedPiece = null;
        if (capturedNintendo) {
          endGame(currentPlayer);
          return;
        }
        currentPlayer = (currentPlayer+1) % players.length; // changer de joueur
        updateTurnUI();
        return;
      }
      // Case vide
      selectedPiece.x = pos.x;
      selectedPiece.y = pos.y;
      updatePieces();
      clearHighlights();
      selectedPiece = null;
      currentPlayer = (currentPlayer+1) % players.length; // changer de joueur
      updateTurnUI();
    } else {
      // Clic non valide: nettoyer la s√©lection pour √©viter la confusion
      clearHighlights();
      selectedPiece = null;
    }
  }
}

function isValidMove(piece, pos) {
  const reachable = getReachablePositions(piece);
  return reachable.some(p => p.x === pos.x && p.y === pos.y);
}

function getPieceAt(pos) {
  return pieces.find(p => p.x === pos.x && p.y === pos.y);
}

function getReachablePositions(piece) {
  const positions = [];
  const rule = catalog[piece.type];
  for (let dir of rule.moves) {
    for (let step = 1; step <= rule.range; step++) {
      const nx = piece.x + dir[0] * step;
      const ny = piece.y + dir[1] * step;
      if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break;
      const occ = getPieceAt({ x: nx, y: ny });
      if (!occ) {
        positions.push({ x: nx, y: ny });
        continue;
      }
      // Case occup√©e: on peut capturer un ennemi mais on s'arr√™te ensuite
      if (occ.player !== piece.player) {
        positions.push({ x: nx, y: ny });
      }
      break;
    }
  }
  return positions;
}

function endGame(winnerPlayerIndex) {
  gameStarted = false;
  clearHighlights();
  if (turnText) {
    turnText.setText(`Le Joueur ${winnerPlayerIndex+1} gagne !`);
  } else if (infoText) {
    infoText.setText(`Le Joueur ${winnerPlayerIndex+1} gagne !`);
  }
}

function clearHighlights() {
  for (let tile of highlightedTiles) {
    tile.setFillStyle(tile.baseColor);
  }
  highlightedTiles = [];
}

function highlightPositions(positions) {
  clearHighlights();
  for (let pos of positions) {
    const tile = grid[pos.y][pos.x];
    tile.setFillStyle(0xfff59d); // jaune clair
    highlightedTiles.push(tile);
  }
}

function updateTurnUI() {
  if (turnText) {
    turnText.setText(`Tour du Joueur ${currentPlayer+1}`);
  } else if (infoText) {
    infoText.setText(`Tour du Joueur ${currentPlayer+1}`);
  }
}

function update() {}

new Phaser.Game(config);

/* https://www.reddit.com/r/retrogaming/comments/1hkzmcw/i_redrew_some_nes_sprites_of_various_nintendo/?tl=fr */
</script>
</body>