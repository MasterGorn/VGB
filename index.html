<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Chesstendo - Draft + Plateau</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
<div id="app" style="display:flex; gap:16px; align-items:flex-start;">
  <div id="game-root"></div>
  <div id="ads-panel" style="width:280px;">
    <div id="ads-title" style="font:16px Arial; margin-bottom:8px;">Publicités</div>
    <div id="ad-slot-1" style="height:130px; background:#f0f0f0; margin-bottom:10px; display:flex; align-items:center; justify-content:center;">Annonce 1</div>
    <div id="ad-slot-2" style="height:130px; background:#f0f0f0; margin-bottom:10px; display:flex; align-items:center; justify-content:center;">Annonce 2</div>
    <div id="ad-info" style="font:12px Arial; color:#555;">Mise à jour toutes les 5 actions</div>
  </div>
</div>
<script>

const config = {
  type: Phaser.AUTO,
  width: 900,
  height: 900,
  backgroundColor: '#ececec',
  parent: 'game-root',
  scene: { preload, create, update }
};

const GRID_OFFSET_X = 60; // marge gauche
const GRID_OFFSET_Y = 60; // marge haut
let TILE_SIZE = 52;       // recalculé selon GRID_SIZE
let GRID_SIZE = 15;       // configurable (9, 12, 15)

let grid = [];
let pieces = [];
let currentPlayer = 0; // index joueur qui doit jouer
let gameStarted = false;
let selectedPiece = null;
let highlightedTiles = [];
let turnText;
let moveCount = 0;
let adRotationIndex = 0;
let playerNameTexts = [];
let turnIcon;
let currentChoicesFaction = null;
let choiceListBottomY = 0;
let pendingPlayerIndex = 0;
let playerSetupDiv = null;
let adIntervalId = null;
let eliminationOrder = [];
let gridSizeUIElems = [];

// Factions et teintes
const brandTints = {
  nintendo: 0xe60012,
  sega: 0x0089cf,
  playstation: 0x003087,
  xbox: 0x107c10
};

function parseFactionInput(input) {
  const v = (input || '').toLowerCase();
  if (v.includes('seg')) return 'sega';
  if (v.includes('play') || v.includes('sony') || v.includes('ps')) return 'playstation';
  if (v.includes('xbox') || v.includes('xb')) return 'xbox';
  return 'nintendo';
}

function getFactionDisplayName(faction) {
  if (faction === 'sega') return 'SEGA';
  if (faction === 'playstation') return 'PlayStation';
  if (faction === 'xbox') return 'Xbox';
  return 'Nintendo';
}

function applyFactionTintByPlayerId(playerId, sprite) {
  const player = players.find(p => p.id === playerId);
  const tint = brandTints[player && player.faction ? player.faction : 'nintendo'];
  if (sprite && typeof sprite.setTint === 'function') sprite.setTint(tint);
}

// --- BUDGET / DRAFT ---
let players = [];

// roi par faction (non drafté)
const kings = {
  nintendo: { key: 'king-nintendo', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  sega: { key: 'king-sega', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  playstation: { key: 'king-playstation', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  xbox: { key: 'king-xbox', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 }
};

// catalogues par faction (draftables)
const factionCatalogs = {
  nintendo: {
    link: { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 },
    mario: { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 },
    zelda: { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }
  },
  xbox: {
    'masterchief': { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 },
    'marcus-fenix': { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 },
    'joanna-dark': { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }
  },
  sega: {
    'sonic': { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 },
    'ryo': { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 },
    'joe-musashi': { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }
  },
  playstation: {
    'nathan-drake': { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 },
    'kratos': { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 },
    'astro-bot': { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }
  }
};

function getCatalogForFaction(faction) {
  return factionCatalogs[faction] || factionCatalogs.nintendo;
}

// Draft UI
let infoText;
let choiceButtons = [];
let choiceThumbs = [];
let armyThumbs = [];
let armyLabels = [];
let endDraftBtn;
let armyPanels = [];
let armyHints = [];
let clearAllBtn;
let playerCountBtns = [];

function preload() {
  // Nintendo existants (actuels)
  this.load.setPath('public/images/nintendo/characters/');
  this.load.image('mario', 'mario.png');
  this.load.image('link', 'link.png');
  // zelda utilise temporairement le sprite de samus
  this.load.image('zelda', 'samus.png');
  // nintendo utilise le sprite de pit (fallback)
  this.load.image('nintendo', 'pit.png');

  // Rois par faction (images à fournir) - chemins par dossier faction
  this.load.setPath('public/images/nintendo/characters/');
  this.load.image('king-nintendo', 'king.png');
  this.load.setPath('public/images/sega/characters/');
  this.load.image('king-sega', 'king.png');
  this.load.setPath('public/images/playstation/characters/');
  this.load.image('king-playstation', 'king.png');
  this.load.setPath('public/images/xbox/characters/');
  this.load.image('king-xbox', 'king.png');

  // Sprites factionnels (images à ajouter par faction, sans préfixe dans les noms de fichiers)
  // Xbox
  this.load.setPath('public/images/xbox/characters/');
  this.load.image('masterchief', 'masterchief.png');
  this.load.image('marcus-fenix', 'marcus-fenix.png');
  this.load.image('joanna-dark', 'joanna-dark.png');
  // SEGA
  this.load.setPath('public/images/sega/characters/');
  this.load.image('sonic', 'sonic.png');
  this.load.image('ryo', 'ryo.png');
  this.load.image('joe-musashi', 'joe-musashi.png');
  // PlayStation
  this.load.setPath('public/images/playstation/characters/');
  this.load.image('nathan-drake', 'nathan-drake.png');
  this.load.image('kratos', 'kratos.png');
  this.load.image('astro-bot', 'astro-bot.png');
}

function create() {
  infoText = this.add.text(10, 10, "", { font: "16px Arial", fill: "#000" });
  infoText.setDepth(1000);
  // Démarrage avec preset mémorisé ?
  const wantsPreset = localStorage.getItem('vgb_start_with_preset') === '1';
  if (wantsPreset && loadPresetAndStart(this)) {
    localStorage.removeItem('vgb_start_with_preset');
    return;
  }
  setupGridSizeUI(this);
}

function setupGridSizeUI(scene) {
  const last = parseInt(localStorage.getItem('vgb_grid_size') || '0', 10);
  infoText.setText("Choisissez la taille du plateau (9x9 / 12x12 / 15x15)");
  const options = [9,11,15];
  let x = 10;
  let y = 40;
  options.forEach(size => {
    const isDefault = (last === size);
    const label = isDefault ? `${size} x ${size} (défaut)` : `${size} x ${size}`;
    const btn = scene.add.text(x, y, label, { font: "16px Arial", fill: "#000", backgroundColor: isDefault ? "#bdf" : "#ddd" })
      .setInteractive()
      .on("pointerdown", () => selectGridSize(scene, size));
    gridSizeUIElems.push(btn);
    y += 30;
  });
  // Bouton pour utiliser directement la taille par défaut mémorisée
  if (options.includes(last)) {
    const defBtn = scene.add.text(x, y + 10, `➡️ Utiliser la taille par défaut (${last}x${last})`, { font: "16px Arial", fill: "#000", backgroundColor: "#cfc" })
      .setInteractive()
      .on("pointerdown", () => selectGridSize(scene, last));
    gridSizeUIElems.push(defBtn);
  }
}

function selectGridSize(scene, size) {
  GRID_SIZE = size;
  // ajuster automatiquement la taille de tuile pour tenir dans 900x900 avec les offsets
  const available = 900 - 2*GRID_OFFSET_Y; // carré
  TILE_SIZE = Math.floor(available / GRID_SIZE);
  // mémoriser le choix
  try { localStorage.setItem('vgb_grid_size', String(size)); } catch(e) {}
  // passer au choix du nombre de joueurs
  gridSizeUIElems.forEach(e => e && e.setVisible(false));
  setupPlayerCountUI(scene);
}

function getKingCenterIndex(gridSize) {
  // 15x15 -> 8e case (index 7), 11x11 -> 6e (index 5), 9x9 -> 5e (index 4)
  if (gridSize === 15) return 7;
  if (gridSize === 11) return 5;
  if (gridSize === 9) return 4;
  return Math.floor(gridSize / 2);
}

function setupPlayerCountUI(scene) {
  infoText.setText("Choisissez le nombre de joueurs (2 à 4)");
  const options = [2,3,4];
  let x = 10;
  let y = 40;
  options.forEach(n => {
    const btn = scene.add.text(x, y, `${n} joueurs`, { font: "16px Arial", fill: "#000", backgroundColor: "#ddd" })
      .setInteractive()
      .on("pointerdown", () => selectPlayerCount(scene, n));
    playerCountBtns.push(btn);
    y += 30;
  });
}

function selectPlayerCount(scene, n) {
  players = Array.from({ length: n }, (_, i) => ({ id: i, points: 20, army: [], name: '', faction: 'nintendo' }));
  currentPlayer = 0;
  // nettoyer UI de sélection
  playerCountBtns.forEach(b => b.destroy());
  playerCountBtns = [];
  // lancer le formulaire séquentiel Nom + Faction
  pendingPlayerIndex = 0;
  showPlayerSetupForm(scene);
}

function showPlayerSetupForm(scene) {
  if (!playerSetupDiv) {
    playerSetupDiv = document.createElement('div');
    playerSetupDiv.id = 'player-setup';
    playerSetupDiv.style.position = 'fixed';
    playerSetupDiv.style.left = '20px';
    playerSetupDiv.style.top = '20px';
    playerSetupDiv.style.zIndex = '9999';
    playerSetupDiv.style.background = 'rgba(255,255,255,0.95)';
    playerSetupDiv.style.border = '1px solid #ccc';
    playerSetupDiv.style.padding = '12px';
    playerSetupDiv.style.borderRadius = '6px';
    playerSetupDiv.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
    document.body.appendChild(playerSetupDiv);
  }
  const idx = pendingPlayerIndex;
  const formHtml = `
    <div style="font:16px Arial; margin-bottom:8px;">Configuration du Joueur ${idx+1}</div>
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
      <label style="font:14px Arial;">Nom</label>
      <input id="pset-name" type="text" value="${players[idx].name || `Joueur ${idx+1}`}" style="font:14px Arial; padding:4px;" />
    </div>
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:12px;">
      <label style="font:14px Arial;">Faction</label>
      <select id="pset-faction" style="font:14px Arial; padding:4px;">
        <option ${players[idx].faction==='nintendo'?'selected':''} value="nintendo">Nintendo</option>
        <option ${players[idx].faction==='sega'?'selected':''} value="sega">SEGA</option>
        <option ${players[idx].faction==='playstation'?'selected':''} value="playstation">PlayStation</option>
        <option ${players[idx].faction==='xbox'?'selected':''} value="xbox">Xbox</option>
      </select>
    </div>
    <div style="display:flex; gap:8px;">
      <button id="pset-validate" style="font:14px Arial; padding:6px 10px;">Valider</button>
    </div>
  `;
  playerSetupDiv.innerHTML = formHtml;
  const btn = document.getElementById('pset-validate');
  btn.onclick = () => {
    const name = (document.getElementById('pset-name').value || '').trim() || `Joueur ${idx+1}`;
    const faction = (document.getElementById('pset-faction').value || 'nintendo');
    players[idx].name = name;
    players[idx].faction = faction;
    pendingPlayerIndex++;
    if (pendingPlayerIndex >= players.length) {
      // terminé
      playerSetupDiv.remove();
      playerSetupDiv = null;
      infoText.setText("");
      setupDraftUI(scene);
      updateDraftUI();
    } else {
      showPlayerSetupForm(scene);
    }
  };
}

function setupDraftUI(scene) {
  rebuildChoiceList(scene);

  // bouton "Terminer"
  endDraftBtn = scene.add.text(10, choiceListBottomY+10, "✅ Terminer draft", 
    { font: "16px Arial", fill: "#000", backgroundColor: "#afa" })
    .setInteractive()
    .on("pointerdown", () => endDraft(scene));

  // bouton "Tout supprimer"
  clearAllBtn = scene.add.text(180, choiceListBottomY+10, "🗑️ Tout supprimer", 
    { font: "16px Arial", fill: "#000", backgroundColor: "#faa" })
    .setInteractive()
    .on("pointerdown", () => clearCurrentBasket(scene));

  // labels/panneaux/hints dynamiques selon nombre de joueurs
  armyLabels = [];
  armyPanels = [];
  armyHints = [];
  armyThumbs = Array.from({ length: players.length }, () => []);
  for (let i = 0; i < players.length; i++) {
    const baseLabelY = 30 + i*70;
    armyLabels[i] = scene.add.text(300, baseLabelY, `Équipe J${i+1}`, { font: "16px Arial", fill: "#000" });
    armyPanels[i] = scene.add.rectangle(450, baseLabelY + 35, 280, 50, 0xffffff, 0).setStrokeStyle(0);
    armyHints[i] = scene.add.text(300, baseLabelY + 15, "Cliquez pour retirer", { font: "12px Arial", fill: "#555" });
  }
  renderArmyThumbnails(scene);
}

function hasTexture(scene, key) {
  return scene.textures && typeof scene.textures.exists === 'function' && scene.textures.exists(key);
}

function rebuildChoiceList(scene) {
  const faction = players[currentPlayer] && players[currentPlayer].faction ? players[currentPlayer].faction : 'nintendo';
  const draftCatalog = getCatalogForFaction(faction);
  // détruire anciens choix
  if (choiceThumbs.length) {
    for (let entry of choiceThumbs) {
      entry.image.destroy();
      entry.nameText.destroy();
      entry.costText.destroy();
    }
    choiceThumbs = [];
  }
  currentChoicesFaction = faction;
  let y = 50;
  for (let key in draftCatalog) {
    const displayName = getDisplayNameForKey(key);
    const texKey = hasTexture(scene, key) ? key : 'nintendo';
    const img = scene.add.image(35, y, texKey)
      .setDisplaySize(52,52)
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const nameText = scene.add.text(70, y - 12, displayName, { font: "16px Arial", fill: "#000" })
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const costText = scene.add.text(70, y + 10, `cost: ${draftCatalog[key].cost}` , { font: "12px Arial", fill: "#333" });
    choiceThumbs.push({ key, image: img, nameText, costText });
    y += 70;
  }
  choiceListBottomY = y;
  if (endDraftBtn) endDraftBtn.setY(choiceListBottomY + 10);
  if (clearAllBtn) clearAllBtn.setY(choiceListBottomY + 10);
}

function mapCharacterToFactionSprite(faction, baseKey) {
  // baseKey est déjà la clé du sprite à charger dans le dossier de la faction
  return baseKey;
}

function getDisplayNameForKey(key) {
  // Capitalise chaque mot
  return key.replaceAll('-', ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function updateDraftUI() {
  let p = players[currentPlayer];
  infoText.setText(`Joueur ${p.id+1} - Points restants: ${p.points}\nChoisissez vos persos`);
  rebuildChoiceList(infoText.scene); // reconstruire au changement de joueur/faction
  updateChoiceAvailability();
  const scene = infoText.scene;
  renderArmyThumbnails(scene);
  if (clearAllBtn) {
    clearAllBtn.setText(`🗑️ Tout supprimer (J${currentPlayer+1})`);
  }
}

function updateChoiceAvailability() {
  const p = players[currentPlayer];
  const catalog = getCatalogForFaction(p.faction);
  for (let entry of choiceThumbs) {
    const affordable = p.points >= catalog[entry.key].cost;
    entry.image.setAlpha(affordable ? 1 : 0.4);
    entry.nameText.setAlpha(affordable ? 1 : 0.5);
    entry.costText.setAlpha(affordable ? 1 : 0.5);
    if (affordable) {
      entry.image.setInteractive();
      entry.nameText.setInteractive();
    } else {
      entry.image.disableInteractive();
      entry.nameText.disableInteractive();
    }
  }
}

function renderArmyThumbnails(scene) {
  // nettoyer existants
  for (let i = 0; i < armyThumbs.length; i++) {
    for (let img of armyThumbs[i]) { img.destroy(); }
    armyThumbs[i] = [];
  }
  // re-créer
  players.forEach((pl,i) => {
    const baseY = 60 + i*70;
    pl.army.forEach((charKey, idx) => {
      const img = scene.add.image(300 + idx*45, baseY, charKey).setDisplaySize(32,32);
      if (i === currentPlayer && !gameStarted) {
        img.setInteractive().on("pointerdown", () => removeArmyItem(scene, i, idx));
      } else {
        img.disableInteractive();
        img.setAlpha(0.9);
      }
      armyThumbs[i].push(img);
    });
  });
}

function removeArmyItem(scene, playerIndex, itemIndex) {
  if (gameStarted) return;
  if (playerIndex !== currentPlayer) return;
  const key = players[playerIndex].army[itemIndex];
  if (!key) return;
  players[playerIndex].army.splice(itemIndex, 1);
  players[playerIndex].points += getCatalogForFaction(players[playerIndex].faction)[key].cost;
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function clearCurrentBasket(scene) {
  if (gameStarted) return;
  const p = players[currentPlayer];
  // Confirmation
  if (!window.confirm(`Voulez-vous supprimer tous les choix du Joueur ${currentPlayer+1} ?`)) {
    return;
  }
  // rembourser tous les choix
  let refund = 0;
  for (let key of p.army) {
    refund += getCatalogForFaction(p.faction)[key].cost;
  }
  p.points += refund;
  p.army = [];
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function pickCharacter(scene, key) {
  let p = players[currentPlayer];
  let char = getCatalogForFaction(p.faction)[key];
  if (p.points >= char.cost) {
    p.points -= char.cost;
    p.army.push(key);
    updateDraftUI();
  }
}

function endDraft(scene) {
  if (currentPlayer === players.length-1) {
    // Tous les joueurs ont fini => lancer la partie
    startGame(scene);
  } else {
    currentPlayer++;
    updateDraftUI();
  }
}

function startGame(scene) {
  gameStarted = true;
  currentPlayer = 0;
  infoText.setText("");
  // cacher l'UI de draft
  choiceButtons.forEach(btn => btn.setVisible(false));
  if (endDraftBtn) endDraftBtn.setVisible(false);
  if (choiceThumbs && choiceThumbs.length) {
    choiceThumbs.forEach(entry => {
      entry.image.setVisible(false);
      entry.nameText.setVisible(false);
      entry.costText.setVisible(false);
    });
  }
  if (clearAllBtn) clearAllBtn.setVisible(false);
  // cacher l'aperçu des équipes pendant la partie
  if (armyLabels && armyLabels.length) {
    armyLabels.forEach(lbl => lbl && lbl.setVisible(false));
  }
  if (armyThumbs && armyThumbs.length) {
    armyThumbs.forEach(list => list.forEach(img => img && img.setVisible(false)));
  }
  if (armyPanels && armyPanels.length) {
    armyPanels.forEach(r => r && r.setVisible(false));
  }
  if (armyHints && armyHints.length) {
    armyHints.forEach(t => t && t.setVisible(false));
  }

  // créer la grille
  for (let y=0; y<GRID_SIZE; y++) {
    grid[y] = [];
    for (let x=0; x<GRID_SIZE; x++) {
      const baseColor = (x+y)%2===0 ? 0xffffff : 0xcccccc;
      const rect = scene.add.rectangle(
        GRID_OFFSET_X + x*TILE_SIZE + TILE_SIZE/2,
        GRID_OFFSET_Y + y*TILE_SIZE + TILE_SIZE/2,
        TILE_SIZE-2, TILE_SIZE-2,
        baseColor
      ).setStrokeStyle(1,0x000000).setInteractive();
      rect.baseColor = baseColor;
      rect.pos = {x,y};
      rect.on('pointerdown', () => handleClick(scene, rect.pos));
      grid[y][x] = rect;
    }
  }

  // Helpers placement
  const getPlayerSide = (index) => {
    if (index === 0) return 'top';
    if (index === 1) return 'bottom';
    if (index === 2) return 'left';
    return 'right';
  };
  const mid = getKingCenterIndex(GRID_SIZE);

  const getBlockSlotsForSide = (side) => {
    // Générer une spirale en coordonnées locales (autour de 0,0) puis mapper vers la grille
    let minDX, maxDX, minDY, maxDY;
    if (side === 'top' || side === 'bottom') {
      minDX = -2; maxDX = 2; minDY = 0; maxDY = 3; // 5x4
    } else { // left / right
      minDX = 0; maxDX = 3; minDY = -2; maxDY = 2; // 4x5
    }
    const area = (maxDX - minDX + 1) * (maxDY - minDY + 1);
    const needed = area - 1; // case du roi exclue

    const dirs = [ [1,0], [0,1], [-1,0], [0,-1] ]; // droite, bas, gauche, haut
    let stepLen = 1;
    let dirIndex = 0;
    let lx = 0, ly = 0; // coords locales
    const offsets = [];
    while (offsets.length < needed && stepLen < 100) {
      for (let repeat = 0; repeat < 2; repeat++) {
        const [dxStep, dyStep] = dirs[dirIndex];
        for (let s = 0; s < stepLen; s++) {
          lx += dxStep; ly += dyStep;
          if (lx >= minDX && lx <= maxDX && ly >= minDY && ly <= maxDY && !(lx === 0 && ly === 0)) {
            offsets.push({ dx: lx, dy: ly });
            if (offsets.length >= needed) break;
          }
        }
        dirIndex = (dirIndex + 1) % 4;
        if (offsets.length >= needed) break;
      }
      stepLen++;
    }

    // Map vers les coordonnées grille selon le côté
    const slots = [];
    if (side === 'top') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: 0 + o.dy });
    } else if (side === 'bottom') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: GRID_SIZE - 1 - o.dy });
    } else if (side === 'left') {
      for (const o of offsets) slots.push({ x: 0 + o.dx, y: mid + o.dy });
    } else if (side === 'right') {
      for (const o of offsets) slots.push({ x: GRID_SIZE - 1 - o.dx, y: mid + o.dy });
    }
    return slots;
  };

  // 1) Placer les rois par faction au centre exact du bord
  players.forEach((p,i) => {
    const side = getPlayerSide(i);
    let pos = { x: mid, y: 0 };
    if (side === 'top') pos = { x: mid, y: 0 };
    if (side === 'bottom') pos = { x: mid, y: GRID_SIZE - 1 };
    if (side === 'left') pos = { x: 0, y: mid };
    if (side === 'right') pos = { x: GRID_SIZE - 1, y: mid };
    const kingKey = (kings[p.faction] && kings[p.faction].key) ? kings[p.faction].key : 'nintendo';
    const spr = scene.add.image(0,0,kingKey);
    pieces.push({ sprite: spr, type: 'king', x: pos.x, y: pos.y, player: p.id });
  });

  // 2) Placer les autres pièces en partant du bord propre à chaque joueur
  players.forEach((p,i) => {
    const side = getPlayerSide(i);
    const slots = getBlockSlotsForSide(side);
    let si = 0;
    p.army.forEach((charKey) => {
      // avancer jusqu'à trouver un slot libre
      while (si < slots.length && getPieceAt(slots[si])) si++;
      if (si >= slots.length) return; // plus de place dans le bloc
      const pos = slots[si];
      const spr = scene.add.image(0,0,charKey);
      pieces.push({ sprite: spr, type: charKey, x: pos.x, y: pos.y, player: p.id });
      si++;
    });
  });

  updatePieces();
  // Bandeau "Début de la partie" en haut de la grille
  const startText = scene.add.text(GRID_OFFSET_X + (GRID_SIZE*TILE_SIZE)/2, GRID_OFFSET_Y - 26, "Début de la partie !", { font: "20px Arial", fill: "#000", backgroundColor: "#fff" })
    .setOrigin(0.5, 0)
    .setDepth(2000);
  scene.time.delayedCall(1500, () => { startText.destroy(); });

  // Textes des noms des joueurs hors de la grille
  playerNameTexts.forEach(t => t && t.destroy());
  playerNameTexts = [];
  const midNames = getKingCenterIndex(GRID_SIZE);
  const margin = 12;
  players.forEach((p,i) => {
    const side = (i===0)?'top':(i===1)?'bottom':(i===2)?'left':'right';
    let nx = 0, ny = 0;
    if (side === 'top') { nx = GRID_OFFSET_X + midNames*TILE_SIZE + TILE_SIZE/2; ny = GRID_OFFSET_Y - 18; }
    if (side === 'bottom') { nx = GRID_OFFSET_X + midNames*TILE_SIZE + TILE_SIZE/2; ny = GRID_OFFSET_Y + GRID_SIZE*TILE_SIZE + 6; }
    if (side === 'left') { nx = GRID_OFFSET_X - 12; ny = GRID_OFFSET_Y + midNames*TILE_SIZE + TILE_SIZE/2; }
    if (side === 'right') { nx = GRID_OFFSET_X + GRID_SIZE*TILE_SIZE + 12; ny = GRID_OFFSET_Y + midNames*TILE_SIZE + TILE_SIZE/2; }
    const tintColor = brandTints[p.faction || 'nintendo'] || 0x000000;
    const factionLabel = getFactionDisplayName(p.faction || 'nintendo');
    const label = `${p.name} (${factionLabel})`;
    const txt = scene.add.text(nx, ny, label, { font: "18px Arial", fill: `#${tintColor.toString(16).padStart(6,'0')}` }).setOrigin(0.5);
    if (side === 'left') txt.setAngle(-90);
    if (side === 'right') txt.setAngle(90);
    txt.setDepth(1500);
    playerNameTexts.push(txt);
  });

  // Indicateur de tour (icône)
  if (turnIcon) { turnIcon.destroy(); }
  turnIcon = scene.add.text(0,0,"🎮", { font: "22px Arial" }).setDepth(2000);
  updateTurnUI();
}

function savePreset() {
  try {
    const preset = {
      gridSize: GRID_SIZE,
      players: players.map(p => ({ name: p.name, faction: p.faction }))
    };
    localStorage.setItem('vgb_preset', JSON.stringify(preset));
  } catch(e) {}
}

function loadPresetAndStart(scene) {
  try {
    const raw = localStorage.getItem('vgb_preset');
    if (!raw) return false;
    const preset = JSON.parse(raw);
    if (!preset || !preset.gridSize || !Array.isArray(preset.players) || preset.players.length < 2) return false;
    GRID_SIZE = preset.gridSize;
    const available = 900 - 2*GRID_OFFSET_Y;
    TILE_SIZE = Math.floor(available / GRID_SIZE);
    players = preset.players.map((pp, i) => ({ id: i, points: 20, army: [], name: pp.name || `Joueur ${i+1}`, faction: pp.faction || 'nintendo' }));
    currentPlayer = 0;
    setupDraftUI(scene);
    updateDraftUI();
    return true;
  } catch(e) { return false; }
}

function updatePieces() {
  for (let p of pieces) {
    p.sprite.x = GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2;
    p.sprite.y = GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2;
    // ajuster la taille pour remplir la case moins une marge de bordure
    const margin = 4; // 2px de chaque côté
    const targetSize = TILE_SIZE - margin;
    p.sprite.setDisplaySize(targetSize, targetSize);
  }
}

function handleClick(scene, pos) {
  if (!gameStarted) return;
  const clickedPiece = getPieceAt(pos);

  // Sélection d'une pièce du joueur courant
  if (clickedPiece && clickedPiece.player === currentPlayer) {
    selectedPiece = clickedPiece;
    const reachable = getReachablePositions(selectedPiece);
    highlightPositions(reachable);
    return;
  }

  // Déplacement si une pièce est sélectionnée et la case est atteignable
  if (selectedPiece) {
    const reachable = getReachablePositions(selectedPiece);
    const isReachable = reachable.some(p => p.x === pos.x && p.y === pos.y);
    if (isReachable) {
      // Capture éventuelle sur la case cible
      const target = getPieceAt(pos);
      if (target && target.player !== selectedPiece.player) {
        const capturedKing = target.type === 'king';
        target.sprite.destroy();
        pieces = pieces.filter(p => p !== target);
        // Déplacer la pièce du joueur sur la case capturée
        selectedPiece.x = pos.x;
        selectedPiece.y = pos.y;
        updatePieces();
        clearHighlights();
        selectedPiece = null;
        // Gestion élimination et condition de fin
        if (capturedKing) {
          if (!eliminationOrder.includes(target.player)) {
            eliminationOrder.push(target.player);
          }
          const remainingKings = pieces.filter(pp => pp.type === 'king').length;
          if (remainingKings <= 1) {
            // déterminer le vainqueur (roi encore vivant)
            let winnerId = null;
            const kingPiece = pieces.find(pp => pp.type === 'king');
            if (kingPiece) winnerId = kingPiece.player;
            // construire classement
            let ranking = [];
            if (winnerId !== null) ranking.push(winnerId);
            const rest = eliminationOrder.slice().reverse();
            for (let pid of rest) {
              if (winnerId === null || pid !== winnerId) ranking.push(pid);
            }
            endGameWithRanking(ranking);
            return;
          }
        }
        moveCount++;
        if (moveCount % 5 === 0) rotateAds();
        updateAdInfo();
        currentPlayer = (currentPlayer+1) % players.length; // changer de joueur
        updateTurnUI();
        return;
      }
      // Case vide
      selectedPiece.x = pos.x;
      selectedPiece.y = pos.y;
      updatePieces();
      clearHighlights();
      selectedPiece = null;
      moveCount++;
      if (moveCount % 5 === 0) rotateAds();
      updateAdInfo();
      currentPlayer = (currentPlayer+1) % players.length; // changer de joueur
      updateTurnUI();
    } else {
      // Clic non valide: nettoyer la sélection pour éviter la confusion
      clearHighlights();
      selectedPiece = null;
    }
  }
}

function isValidMove(piece, pos) {
  const reachable = getReachablePositions(piece);
  return reachable.some(p => p.x === pos.x && p.y === pos.y);
}

function getPieceAt(pos) {
  return pieces.find(p => p.x === pos.x && p.y === pos.y);
}

function getReachablePositions(piece) {
  const positions = [];
  const rule = getRuleForPiece(piece);
  for (let dir of rule.moves) {
    for (let step = 1; step <= rule.range; step++) {
      const nx = piece.x + dir[0] * step;
      const ny = piece.y + dir[1] * step;
      if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break;
      const occ = getPieceAt({ x: nx, y: ny });
      if (!occ) {
        positions.push({ x: nx, y: ny });
        continue;
      }
      // Case occupée: on peut capturer un ennemi mais on s'arrête ensuite
      if (occ.player !== piece.player) {
        positions.push({ x: nx, y: ny });
      }
      break;
    }
  }
  return positions;
}

function getRuleForPiece(piece) {
  // Retourne l'objet { moves, range } pour la pièce, selon faction/type
  const owner = players[piece.player];
  if (!owner) return { moves: [], range: 0 };
  if (piece.type === 'king') {
    const k = kings[owner.faction];
    return k ? { moves: k.moves, range: k.range } : { moves: [], range: 0 };
  }
  const catalog = getCatalogForFaction(owner.faction);
  const entry = catalog[piece.type];
  return entry ? { moves: entry.moves, range: entry.range } : { moves: [], range: 0 };
}

function endGameWithRanking(ranking) {
  gameStarted = false;
  clearHighlights();
  let msg = '';
  if (Array.isArray(ranking) && ranking.length > 0) {
    msg = 'Classement final:\n' + ranking.map((pid, idx) => `${idx+1}. Joueur ${pid+1}`).join('\n');
  } else {
    msg = 'Partie terminée.';
  }
  if (turnText) {
    turnText.setText(msg);
  } else if (infoText) {
    infoText.setText(msg);
  }
  // Mémoriser les réglages actuels pour relancer facilement
  savePreset();
  // Bouton DOM pour relancer avec les mêmes réglages
  let btn = document.getElementById('restart-same-settings');
  if (btn) btn.remove();
  btn = document.createElement('button');
  btn.id = 'restart-same-settings';
  btn.textContent = 'Démarrer une nouvelle partie avec les mêmes réglages';
  btn.style.position = 'fixed';
  btn.style.right = '20px';
  btn.style.bottom = '20px';
  btn.style.zIndex = '9999';
  btn.style.padding = '10px 12px';
  btn.style.font = '14px Arial';
  btn.style.background = '#cfc';
  btn.style.border = '1px solid #9c9';
  btn.style.borderRadius = '6px';
  btn.onclick = () => {
    try { localStorage.setItem('vgb_start_with_preset', '1'); } catch(e) {}
    window.location.reload();
  };
  document.body.appendChild(btn);
}

function clearHighlights() {
  for (let tile of highlightedTiles) {
    tile.setFillStyle(tile.baseColor);
  }
  highlightedTiles = [];
}

function highlightPositions(positions) {
  clearHighlights();
  for (let pos of positions) {
    const tile = grid[pos.y][pos.x];
    tile.setFillStyle(0xfff59d); // jaune clair
    highlightedTiles.push(tile);
  }
}

function updateTurnUI() {
  const mid = getKingCenterIndex(GRID_SIZE);
  // Positionner l'icône de tour à côté du nom du joueur actif
  if (turnIcon && playerNameTexts[currentPlayer]) {
    const t = playerNameTexts[currentPlayer];
    turnIcon.x = t.x - t.displayWidth/2 - 16;
    turnIcon.y = t.y - t.displayHeight/2;
    // Rotation de l'icône selon côté
    const side = (currentPlayer===0)?'top':(currentPlayer===1)?'bottom':(currentPlayer===2)?'left':'right';
    if (side === 'left') turnIcon.setAngle(-90); else if (side === 'right') turnIcon.setAngle(90); else turnIcon.setAngle(0);
  }
}

function update() {}

new Phaser.Game(config);

// --- Publicités ---
const ADS = [
  { a1: 'Retro Console XL', a2: 'Promo -30%' },
  { a1: 'Figurines 8-bit', a2: 'Nouveautés' },
  { a1: 'Cartouches Repro', a2: 'Rare Loot' },
  { a1: 'T-shirts Pixel', a2: 'Collection 2025' },
];

function rotateAds() {
  adRotationIndex = (adRotationIndex + 1) % ADS.length;
  const data = ADS[adRotationIndex];
  const s1 = document.getElementById('ad-slot-1');
  const s2 = document.getElementById('ad-slot-2');
  if (s1) s1.textContent = data.a1;
  if (s2) s2.textContent = data.a2;
  updateAdInfo(true);
}

function updateAdInfo(reset = false) {
  const info = document.getElementById('ad-info');
  if (!info) return;
  const nextIn = reset ? 5 : (5 - (moveCount % 5));
  const plural = nextIn >= 2 ? 's' : '';
  info.textContent = `Mise à jour dans ${nextIn} action${plural} (toutes les 5 actions)`;
}

/* https://www.reddit.com/r/retrogaming/comments/1hkzmcw/i_redrew_some_nes_sprites_of_various_nintendo/?tl=fr */
</script>
</body>