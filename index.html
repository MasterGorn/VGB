<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title data-t="page-title">Chesstendo - Draft + Plateau</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
<link rel="stylesheet" href="public/css/header.css" />
<link rel="stylesheet" href="public/css/common.css" />
<link rel="stylesheet" href="public/css/global.css" />
<style>
/* Styles sp√©cifiques √† la page d'accueil */
.game-container {
  display: flex;
  gap: var(--spacing-md);
  align-items: flex-start;
  padding-top: var(--spacing-xl);
  max-width: 1200px;
  margin: 0 auto;
}

@media (min-width: 1280px) {
  .game-container {
    max-width: 1400px;
    margin: 0 auto;
    display: flex;
    gap: var(--spacing-md);
    align-items: flex-start;
    padding-top: var(--spacing-xl);
  }
  
  .game-root {
    flex: 1;
    max-width: 100%;
  }
  
  .sidebar {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md);
    width: 280px;
  }
  
  .rules-panel {
    order: 2;
  }
  
  .ads-panel {
    order: 1;
  }
}

.game-root {
  flex: 1;
  max-width: 100%;
  margin-left: 24px;
}

.game-root canvas {
  max-width: 100%;
  height: auto;
  display: none; /* Cach√© par d√©faut */
}

.game-root canvas.game-started {
  display: block; /* Affich√© quand la partie commence */
}

.sidebar {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  width: 436px;
  margin-right: 24px;
}

.ads-panel {
  width: 100%;
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: var(--spacing-md);
  box-shadow: var(--shadow-light);
}

.ads-title {
  font: var(--font-size-lg) Arial, sans-serif;
  margin-bottom: var(--spacing-sm);
  color: var(--text-primary);
  font-weight: bold;
}

.ad-slot {
  height: 130px;
  background: var(--secondary-bg);
  margin-bottom: var(--spacing-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color);
  color: var(--text-muted);
}

.ad-info {
  font: var(--font-size-sm) Arial, sans-serif;
  color: var(--text-muted);
  margin-bottom: var(--spacing-md);
}

/* Contr√¥les de s√©lection des personnages */
.draft-controls {
  margin-top: var(--spacing-md);
  text-align: center;
}

.draft-btn {
  background: linear-gradient(135deg, var(--accent-color), var(--accent-gold));
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: var(--border-radius);
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: var(--shadow-medium);
}

.draft-btn:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-large);
  background: linear-gradient(135deg, var(--accent-gold), var(--accent-color));
}

/* Configuration de la partie */
.game-setup {
  background: var(--primary-bg);
  padding: 40px;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
  box-shadow: var(--shadow-light);
  width: calc(100% - 40px);
  margin: 0 20px 20px;
}

.setup-card {
  background: var(--card-bg);
  border: 2px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: 40px;
  box-shadow: var(--shadow-medium);
  text-align: center;
  max-width: 600px;
  width: 100%;
}

.setup-title {
  color: var(--accent-gold);
  margin: 0 0 30px 0;
  font-size: 32px;
  font-weight: bold;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

.setup-options {
  display: flex;
  gap: 40px;
  justify-content: center;
  margin-bottom: 30px;
  flex-wrap: wrap;
}

.option-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  min-width: 150px;
}

.option-group label {
  color: var(--text-primary);
  font-weight: bold;
  font-size: 16px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.setup-select {
  padding: 8px 12px;
  border: 2px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--primary-bg);
  color: var(--text-primary);
  font-size: 14px;
  min-width: 150px;
  cursor: pointer;
  transition: border-color 0.3s ease;
}

.setup-select:focus {
  outline: none;
  border-color: var(--accent-gold);
}

.setup-btn {
  background: linear-gradient(135deg, var(--accent-color), var(--accent-gold));
  color: white;
  border: none;
  padding: 15px 35px;
  border-radius: var(--border-radius);
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: var(--shadow-medium);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.setup-btn:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-large);
  background: linear-gradient(135deg, var(--accent-gold), var(--accent-color));
}

.rules-panel {
  margin-top: var(--spacing-md);
  background: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: var(--spacing-md);
  box-shadow: var(--shadow-light);
}

.rules-title {
  font: var(--font-size-lg) Arial, sans-serif;
  margin-bottom: var(--spacing-sm);
  color: var(--text-primary);
  font-weight: bold;
}

.rules-list {
  display: inline-flex;
  flex-wrap: wrap;
  gap: 16px;
  font: var(--font-size-sm) Arial, sans-serif;
  color: var(--text-secondary);
  line-height: 1.5;
}

@media (max-width: 1279px) {
  .game-container {
    flex-direction: column;
    align-items: stretch;
    padding-top: var(--spacing-lg);
  }
  
  .game-root {
    order: 1;
    margin: 0 24px;
  }
  
  .sidebar {
    order: 2;
    width: calc(100% - 48px);
    flex-direction: column;
    margin: 0 24px;
  }
  
  .rules-panel {
    order: 1;
    margin-top: var(--spacing-lg);
    margin-bottom: 0;
  }
  
  .ads-panel {
    order: 2;
    width: 100%;
    margin-top: var(--spacing-lg);
  }
}

.tagline {
  text-align: center;
  padding: var(--spacing-xl) var(--spacing-md);
  background: var(--secondary-bg);
  border: 1px solid var(--border-color);
  border-radius: 0 0 var(--border-radius-large) var(--border-radius-large);
  margin: var(--spacing-lg) 0;
  backdrop-filter: blur(10px);
  box-shadow: var(--shadow-medium);
  position: relative;
  overflow: hidden;
}

.tagline::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: var(--accent-gold);
}

.tagline h1 {
  margin: 0;
  font: 32px Arial, sans-serif;
  font-weight: bold;
  text-shadow: var(--shadow-text);
  background: var(--accent-gold);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  position: relative;
  z-index: 1;
}

</style>
</head>
<body>
<div id="header-root"></div>

<!-- Accroche principale -->
<div class="tagline">
  <h1 data-t="tagline">Oubliez les √©checs classiques, ici les h√©ros de jeux vid√©o font les r√®gles !</h1>
</div>

<div class="game-container">
  <!-- Configuration de la partie -->
  <div id="game-setup" class="game-setup">
    <div class="setup-card">
      <h2 class="setup-title" data-t="game-title">Configuration de la partie</h2>
      
      <div class="setup-options">
        <div class="option-group">
          <label for="grid-size-select" data-t="select-board-size">Taille du plateau :</label>
          <select id="grid-size-select" class="setup-select">
            <option value="9" data-t="board-small">9x9 (Petit)</option>
            <option value="11" data-t="board-medium">11x11 (Moyen)</option>
            <option value="15" selected data-t="board-large">15x15 (Grand)</option>
          </select>
        </div>
        
        <div class="option-group">
          <label for="player-count-select" data-t="select-players">Nombre de joueurs :</label>
          <select id="player-count-select" class="setup-select">
            <option value="2">2 <span data-t="players">joueurs</span></option>
            <option value="3">3 <span data-t="players">joueurs</span></option>
            <option value="4" selected>4 <span data-t="players">joueurs</span></option>
          </select>
        </div>
      </div>
      
      <button id="start-character-selection" class="setup-btn" data-t="start-game">üéÆ S√©lection des personnages</button>
    </div>
  </div>
  
  <div id="game-root" class="game-root"></div>
  <div class="sidebar">
    <div id="rules-panel" class="rules-panel">
      <div class="rules-title" data-t="pieces-in-play">Pi√®ces en jeu</div>
      <div id="rules-list" class="rules-list"></div>
    </div>
    
    <div id="ads-panel" class="ads-panel">
      <div id="ads-title" class="ads-title" data-t="advertisements">Publicit√©s</div>
      <div id="ad-slot-1" class="ad-slot" data-t="ad-1">Annonce 1</div>
      <div id="ad-slot-2" class="ad-slot" data-t="ad-2">Annonce 2</div>
      <div id="ad-info" class="ad-info" data-t="ad-update">Mise √† jour toutes les 5 actions</div>
    </div>
  </div>
</div>
<script src="public/js/header.js"></script>
<script src="public/data/pieces.js"></script>
<script src="public/data/items.js"></script>
<script src="public/js/translations.js"></script>
<script>
VGBHeader.injectHeader('index');

const config = {
  type: Phaser.CANVAS,
  width: 900,
  height: 900,
  resolution: (window.devicePixelRatio || 1),
  backgroundColor: '#ececec',
  parent: 'game-root',
  scene: { preload, create, update },
  render: {
    antialias: true,
    pixelArt: false,
    roundPixels: false,
    mipmapFilter: Phaser.Textures.FilterMode.LINEAR
  }
};

const GRID_OFFSET_X = 60; // marge gauche
const GRID_OFFSET_Y = 60; // marge haut
let TILE_SIZE = 52;       // recalcul√© selon GRID_SIZE
let GRID_SIZE = 15;       // configurable (9, 12, 15)

let grid = [];
let pieces = [];
let currentPlayer = 0; // index joueur qui doit jouer
let gameStarted = false;
let selectedPiece = null;
let highlightedTiles = [];
let highlightOverlays = [];
let turnText;
let moveCount = 0;
let infoBackground; // Fond blanc pour les messages d'information
let isEndGameMessage = false; // Flag pour emp√™cher le masquage du message de fin
// plus de garde: d√©cr√©ment √† chaque fin de tour
let adRotationIndex = 0;
let playerNameTexts = [];
let currentChoicesFaction = null;
let choiceListBottomY = 0;
let pendingPlayerIndex = 0;
let playerSetupDiv = null;
let adIntervalId = null;
let eliminationOrder = [];
let gridSizeUIElems = [];
// Options de partie
let timerEnabled = true;
let timerOptionEl = null;
// Items & caisses
let itemCrates = []; // [{ x, y, sprite, active, lastRound }]
let playerItemIcons = []; // par joueur: tableau d'ic√¥nes [{ sprite, item }]
let currentItemAction = null; // { playerId, type: 'bomb', active: true }
let lastCrateEventMove = 0; // obsol√®te (conserv√© si besoin)
let roundCounter = 0;
let lastCrateRound = 0;
let itemUsedThisTurn = false;
// Portails
let portalOrange = null; // { x, y, sprite }
let portalBlue = null;   // { x, y, sprite }
// Variables pour la s√©lection des personnages
let characterSelectionMode = false;
let currentPlayerIndex = 0;
let playerCount = 4;
let playerNames = ['Joueur 1', 'Joueur 2', 'Joueur 3', 'Joueur 4']; // Sera mis √† jour par initTranslation
let playerFactions = ['Nintendo', 'Nintendo', 'Nintendo', 'Nintendo'];
let playerArmies = [[], [], [], []]; // Arm√©es des joueurs
let playerMoney = [100, 100, 100, 100]; // Argent de chaque joueur
let availablePieces = [];
// √âtoile d'invincibilit√©
let starInvincible = { playerId: -1, untilRound: -1, untilPlayerTurn: false };
let starPhase = 0; // pour l'effet arc-en-ciel
let starTileOverlays = new Map(); // key "x,y" -> Image overlay arc-en-ciel
// Tetriminos (murs)
let tetriminos = []; // array de { x, y, sprite } pour les murs tetrimino
// Bananes (pi√®ges)
let bananas = []; // array de { x, y, sprite } pour les bananes
// Pi√®ces perdues par joueur (pour la queue de phoenix)
let playerLostPieces = []; // array de { playerId, piece } pour chaque joueur
// Pi√®ces poss√©d√©es par le curseur Sims
let possessedPieces = []; // array de { piece, cursorSprite, originalPlayer, houseBounds }
// Pi√®ces qui ont un c≈ìur
let heartPieces = []; // array de { piece, heartSprite }
// Masque de Majora : pi√®ce forc√©e
let forcedPiece = null; // { piece, playerId, maskSprite }
// Ocarina du Temps : pi√®ces transform√©es en cavaliers
let knightPieces = []; // array de { piece, ocarinaSprite }
// Poids d'apparition des objets de caisse
// Utilisation des donn√©es des objets depuis le fichier externe
let ITEM_WEIGHTS = {};

// Initialiser les poids des objets apr√®s le chargement
function initItemWeights() {
  if (typeof getItemWeights === 'function') {
    ITEM_WEIGHTS = getItemWeights();
    console.log('ITEM_WEIGHTS initialis√©s:', ITEM_WEIGHTS);
  } else {
    console.error('getItemWeights non disponible');
    // Fallback avec des poids par d√©faut
    ITEM_WEIGHTS = {
      'bobomb': 4,
      'portals': 4,
      'lightning': 1,
      'star': 2,
      'tetrimino': 3,
      'tornado': 2,
      'banana': 5,
      'phoenix': 2,
      'cursor': 3,
      'heart': 2,
      'sandglass': 3,
      'mask': 4,
      'ocarina': 3
    };
  }
}

// Initialiser imm√©diatement au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
  initItemWeights();
  initTranslation();
});
// Timers
let playerTimersMs = [];
let timerTexts = [];
let timerEvent = null;
let timerBlinkToggle = false;

// Factions et teintes
const brandTints = {
  nintendo: 0xe60012,
  sega: 0x0089cf,
  playstation: 0x003087,
  xbox: 0x107c10
};

function parseFactionInput(input) {
  const v = (input || '').toLowerCase();
  if (v.includes('seg')) return 'sega';
  if (v.includes('play') || v.includes('sony') || v.includes('ps')) return 'playstation';
  if (v.includes('xbox') || v.includes('xb')) return 'xbox';
  return 'nintendo';
}

function getFactionDisplayName(faction) {
  if (faction === 'sega') return 'SEGA';
  if (faction === 'playstation') return 'PlayStation';
  if (faction === 'xbox') return 'Xbox';
  return 'Nintendo';
}

function applyFactionTintByPlayerId(playerId, sprite) {
  const player = players.find(p => p.id === playerId);
  const tint = brandTints[player && player.faction ? player.faction : 'nintendo'];
  if (sprite && typeof sprite.setTint === 'function') sprite.setTint(tint);
}

// --- BUDGET / DRAFT ---
let players = [];

// roi par faction (non draft√©)
const kings = {
  nintendo: { key: 'king-nintendo', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  sega: { key: 'king-sega', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  playstation: { key: 'king-playstation', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  xbox: { key: 'king-xbox', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 }
};

// catalogues par faction (draftables)
const factionCatalogs = {
  nintendo: {
    link: { cost: 5, tier: 2, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 }, // moyen
    mario: { cost: 3, tier: 1, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // faible
    zelda: { cost: 7, tier: 3, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }, // fort
    bowser: { cost: 8, tier: 4, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 3 }, // boss
    ganondorf: { cost: 9, tier: 4, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 4 }, // boss
    samus: { cost: 6, tier: 3, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 4 }, // fort
    pit: { cost: 4, tier: 2, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 3 }, // moyen
    palutena: { cost: 8, tier: 4, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 6 }, // boss
    sheik: { cost: 5, tier: 2, moves: [[1,1],[1,-1],[-1,1],[-1,-1],[2,0],[-2,0],[0,2],[0,-2]], range: 2 }, // sp√©cial
    wario: { cost: 4, tier: 2, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // moyen
    'duo-duck-hunt': { cost: 3, tier: 1, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 5 }, // sp√©cial
    'wii-fit-trainer': { cost: 2, tier: 1, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 } // faible
  },
  xbox: {
    'masterchief': { cost: 5, tier: 1, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 }, // faible
    'marcus-fenix': { cost: 3, tier: 2, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // moyen
    'joanna-dark': { cost: 7, tier: 4, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 } // unique
  },
  sega: {
    'sonic': { cost: 5, tier: 1, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 }, // faible
    'ryo': { cost: 3, tier: 2, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // moyen
    'joe-musashi': { cost: 7, tier: 3, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 } // fort
  },
  playstation: {
    'nathan-drake': { cost: 5, tier: 1, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 }, // faible
    'kratos': { cost: 3, tier: 2, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // moyen
    'astro-bot': { cost: 7, tier: 3, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 } // fort
  }
};

function getCatalogForFaction(faction) { 
  return factionCatalogs[faction] || factionCatalogs.nintendo;
}

// Game UI
let infoText;

function preload() {
  // Activer un filtrage lin√©aire pour toutes les textures pour un rendu lisse
  if (this.textures && this.textures.on) {
    this.textures.on(Phaser.Textures.Events.ADD, (key, texture) => {
      if (texture && texture.setFilter) texture.setFilter(Phaser.Textures.FilterMode.LINEAR);
    });
  }
  // Nintendo existants (actuels)
  this.load.setPath('public/images/nintendo/characters/');
  this.load.image('mario', 'mario.png');
  this.load.image('link', 'link.png');
  this.load.image('zelda', 'zelda.png');
  this.load.image('bowser', 'bowser.png');
  this.load.image('ganondorf', 'ganondorf.png');
  this.load.image('samus', 'samus.png');
  this.load.image('pit', 'pit.png');
  this.load.image('palutena', 'palutena.png');
  this.load.image('sheik', 'sheik.png');
  this.load.image('wario', 'wario.png');
  this.load.image('duo-duck-hunt', 'duo-duck-hunt.png');
  this.load.image('wii-fit-trainer', 'wii-fit-trainer.png');
  // nintendo utilise le sprite de pit (fallback)
  this.load.image('nintendo', 'pit.png');
  
  // Nouveaux personnages Nintendo
  this.load.image('luigi', 'luigi.png');
  this.load.image('peach', 'peach.png');
  this.load.image('kirby', 'kirby.png');
  this.load.image('king-k-rool', 'king-k-rool.png');
  this.load.image('waluigi', 'waluigi.png');
  this.load.image('captain-falcon', 'captain-falcon.png');
  this.load.image('bayonetta', 'bayonetta.png');
  this.load.image('banjo-kazooie', 'banjo-&.png');
  this.load.image('ayo-et-oli', 'ayo-et-oli.png');

  // Rois par faction (images √† fournir) - chemins par dossier faction
  this.load.setPath('public/images/nintendo/characters/');
  this.load.image('king-nintendo', 'king.png');
  this.load.setPath('public/images/sega/characters/');
  this.load.image('king-sega', 'king.png');
  this.load.setPath('public/images/playstation/characters/');
  this.load.image('king-playstation', 'king.png');
  
  // Personnages PlayStation
  this.load.image('nathan-drake', 'nathan-drake.png');
  this.load.image('kratos', 'kratos.png');
  this.load.image('astro-bot', 'astro-bot.png');
  this.load.image('aloy', 'aloy.png');
  this.load.image('sackboy', 'sackboy.png');
  this.load.image('jak', 'jak.png');
  this.load.image('daxter', 'daxter.png');
  this.load.image('kat', 'kat.png');
  this.load.image('parappa', 'parappa-the-rapper.png');
  this.load.image('sam-porter', 'sam-porter-bridges (1).png');
  this.load.image('ico', 'ico (1).png');
  
  this.load.setPath('public/images/xbox/characters/');
  this.load.image('king-xbox', 'king.png');

  // Sprites factionnels (images √† ajouter par faction, sans pr√©fixe dans les noms de fichiers)
  // Xbox
  this.load.setPath('public/images/xbox/characters/');
  this.load.image('masterchief', 'masterchief.png');
  this.load.image('marcus-fenix', 'marcus-fenix.png');
  this.load.image('joanna-dark', 'joanna-dark.png');
  // Nouveaux personnages Xbox
  this.load.image('cortana', 'cortana.png');
  this.load.image('juno', 'juno.png');
  this.load.image('jd-fenix', 'jd-fenix.png');
  this.load.image('general-raam', 'general-raam.png');
  this.load.image('cyclops-drone', 'cyclops-drone.png');
  this.load.image('ori', 'ori.png');
  this.load.image('reaver', 'reaver.png');
  this.load.image('senua', 'senua.png');
  this.load.image('jago', 'jago.png');
  this.load.image('orchid', 'orchid.png');
  this.load.image('capitaine-flameheart', 'capitaine-flameheart.png');
  this.load.image('pirate', 'pirate.png');
  this.load.image('rash', 'rash.png');
  this.load.image('conker', 'conker.png');
  this.load.image('blinx', 'blinx.png');
  this.load.image('crash-bandicoot', 'crash-bandicoot.png');
  this.load.image('spyro', 'spyro.png');
  this.load.image('viva-pinata', 'viva-pinata.png');
  this.load.image('joule-adams', 'joule-adams.png');
  this.load.image('steeve', 'steeve.png');
  this.load.image('cooper', 'cooper.png');
  this.load.image('hornet', 'hornet.png');
  this.load.image('shu', 'shu.png');
  this.load.image('lupus', 'lupus.png');
  this.load.image('moine', 'moine.png');
  this.load.image('vela', 'vela.png');
  // SEGA
  this.load.setPath('public/images/sega/characters/');
  this.load.image('sonic', 'sonic.png');
  this.load.image('ryo', 'ryo.png');
  this.load.image('joe-musashi', 'joe-musashi.png');
  
  // Nouveaux personnages SEGA
  this.load.image('tails', 'tails.png');
  this.load.image('dr-robotnik', 'dr.robotnik.png');
  this.load.image('blaze-fielding', 'blaze-fielding.png');
  this.load.image('axel-stone', 'axel-stone.png');
  this.load.image('adam-hunter', 'adam-hunter.png');
  this.load.image('hatsune-miku', 'hatsune-miku.png');
  this.load.image('sakura-shinguji', 'sakura-shinguji.png');
  this.load.image('vyse', 'vyse.png');
  this.load.image('aika', 'aika.png');
  this.load.image('amigo', 'amigo.png');
  this.load.image('ecco', 'ecco-the-dolphin.png');
  this.load.image('pilote-hang-on', 'pilote-hang-on.png');
  this.load.image('dj-professeur-k', 'dj-professeur-k.png');
  this.load.image('ulala', 'ulala.png');
  this.load.image('la-fille', 'la-fille.png');
  this.load.image('le-joueur', 'le-joueur.png');
  this.load.image('zombie', 'zombie-the-house-of-the-dead.png');
  this.load.image('chupea', 'chupea.png');
  this.load.image('chubach', 'chubach.png');
  this.load.image('chuih', 'chuih.png');

  // Items
  this.load.setPath('public/images/items/');
  this.load.svg('item-crate', 'box-item-mario-kart.svg');
  this.load.image('bobomb', 'bobomb.png');
  this.load.image('portals', 'portals.png'); // ic√¥ne inventaire
  this.load.image('portal-orange', 'portal-orange.png');
  this.load.image('portal-blue', 'portal-blue.png');
  this.load.image('lightning', 'Lightning.png');
  this.load.image('star', 'star.png');
  this.load.image('tetrimino', 'tetrimino.png');
  this.load.image('tornado', 'tornado.png');
  this.load.image('banana', 'banana.png');
  this.load.image('phoenix', 'phoenix-down.png');
  this.load.image('cursor', 'sims-cursor.png');
  this.load.image('heart', 'heart.png');
  this.load.image('sandglass', 'hourglass.png');
  this.load.image('mask', 'mask-majora.png');
  this.load.image('ocarina', 'oracina.png');
  // Sons (par item)
  this.load.setPath('public/sounds/items/');
  this.load.audio('bobomb', 'bobomb.mp3');
  this.load.audio('star', 'star.mp3');
  this.load.audio('ocarina', 'ocarina.wav');
}

function create() {
  // Cr√©er le texte d'information centr√© avec fond blanc et coins arrondis
  infoText = this.add.text(0, 0, "", { 
    font: "18px Arial", 
    fill: "#000",
    align: "center",
    wordWrap: { width: 400 }
  });
  infoText.setDepth(10000); // Z-index tr√®s √©lev√© pour passer devant tout
  infoText.setOrigin(0.5, 0.5);
  infoText.x = 448; // Centre du canvas (896/2)
  infoText.y = 300; // Position verticale centr√©e
  
  // Cr√©er le fond blanc avec coins arrondis
  infoBackground = this.add.rectangle(448, 300, 420, 60, 0xffffff);
  infoBackground.setDepth(9999); // Juste en dessous du texte
  infoBackground.setStrokeStyle(2, 0xcccccc);
  infoBackground.setVisible(false); // Cach√© par d√©faut
  // D√©marrage avec preset m√©moris√© ?
  const wantsPreset = localStorage.getItem('vgb_start_with_preset') === '1';
  if (wantsPreset && loadPresetAndStart(this)) {
    localStorage.removeItem('vgb_start_with_preset');
    return;
  }
  // setupGridSizeUI(this); // Supprim√© - remplac√© par l'interface de configuration
  
  // √âv√©nement pour le bouton de s√©lection des personnages
  const startCharacterSelectionBtn = document.getElementById('start-character-selection');
  if (startCharacterSelectionBtn) {
    startCharacterSelectionBtn.addEventListener('click', () => {
      startCharacterSelection();
    });
  }
}

function showInfoMessage(message, duration = 3000) {
  if (!infoText || !infoBackground) return;
  
  // Ne pas afficher de nouveaux messages si c'est un message de fin de partie permanent
  if (isEndGameMessage && duration > 0) return;
  
  // Ne pas afficher le cadre si le message est vide
  if (!message || message.trim() === '') {
    infoText.setText('');
    infoText.setVisible(false);
    infoBackground.setVisible(false);
    return;
  }
  
  // Ajuster la taille du fond selon la longueur du message
  const textWidth = Math.min(500, Math.max(200, message.length * 8));
  const textHeight = message.includes('\n') ? 80 : 60;
  
  infoBackground.setSize(textWidth + 32, textHeight); // +32 pour le padding
  infoBackground.setVisible(true);
  
  infoText.setText(message);
  infoText.setVisible(true);
  
  // Masquer apr√®s la dur√©e sp√©cifi√©e (sauf si duration = 0 pour message permanent)
  if (duration > 0 && !isEndGameMessage) {
    setTimeout(() => {
      if (infoText && !isEndGameMessage) infoText.setVisible(false);
      if (infoBackground && !isEndGameMessage) infoBackground.setVisible(false);
    }, duration);
  }
}

function hideInfoMessage() {
  // Ne pas masquer si c'est un message de fin de partie permanent
  if (isEndGameMessage) return;
  
  if (infoText) infoText.setVisible(false);
  if (infoBackground) infoBackground.setVisible(false);
}

function getNextActivePlayer() {
  // Trouver le prochain joueur non √©limin√©
  let nextPlayer = (currentPlayer + 1) % players.length;
  
  // Continuer √† chercher tant qu'on trouve un joueur √©limin√©
  while (eliminationOrder.includes(nextPlayer)) {
    nextPlayer = (nextPlayer + 1) % players.length;
    
    // Protection contre une boucle infinie si tous les joueurs sont √©limin√©s
    if (nextPlayer === currentPlayer) break;
  }
  
  return nextPlayer;
}

function shouldIncrementRoundCounter() {
  // Incr√©menter le compteur de round quand on revient au premier joueur actif
  const nextPlayer = getNextActivePlayer();
  
  // Trouver le premier joueur actif (non √©limin√©)
  let firstActivePlayer = 0;
  while (eliminationOrder.includes(firstActivePlayer) && firstActivePlayer < players.length) {
    firstActivePlayer++;
  }
  
  // Incr√©menter si on revient au premier joueur actif ou si on "boucle" vers un joueur avec un index plus petit
  return nextPlayer === firstActivePlayer || (nextPlayer < currentPlayer && !eliminationOrder.includes(nextPlayer));
}

// Fonction supprim√©e - remplac√©e par l'interface de configuration

// Fonction supprim√©e - remplac√©e par l'interface de configuration

function getKingCenterIndex(gridSize) {
  // 15x15 -> 8e case (index 7), 11x11 -> 6e (index 5), 9x9 -> 5e (index 4)
  if (gridSize === 15) return 7;
  if (gridSize === 11) return 5;
  if (gridSize === 9) return 4;
  return Math.floor(gridSize / 2);
}

function setupPlayerCountUI(scene) {
  infoText.setText(""); // Pas de message au d√©but
  const options = [2,3,4];
  let x = 10;
  let y = 40;
  // toggle timer option en haut √† gauche, bien visible
  const timerText = scene.add.text(10, 10, `Activer le timer`, { font: "14px Arial", fill: "#000", backgroundColor: "#eee" })
    .setInteractive()
    .on('pointerdown', () => {
      timerEnabled = !timerEnabled;
      timerText.setBackgroundColor(timerEnabled?"#cfc":"#fdd");
    });
  options.forEach(n => {
    const btn = scene.add.text(x, y, `${n} joueurs`, { font: "16px Arial", fill: "#000", backgroundColor: "#ddd" })
      .setInteractive()
      .on("pointerdown", () => selectPlayerCount(scene, n));
    playerCountBtns.push(btn);
    y += 30;
  });
}

function selectPlayerCount(scene, n) {
  const budget = (GRID_SIZE === 9) ? 20 : (GRID_SIZE === 11) ? 30 : 50;
  players = Array.from({ length: n }, (_, i) => ({ id: i, points: budget, army: [], name: '', faction: 'nintendo' }));
  currentPlayer = 0;
  // nettoyer UI de s√©lection
  playerCountBtns.forEach(b => b.destroy());
  playerCountBtns = [];
  // lancer le formulaire s√©quentiel Nom + Faction
  pendingPlayerIndex = 0;
  showPlayerSetupForm(scene);
}

function showPlayerSetupForm(scene) {
  if (!playerSetupDiv) {
    playerSetupDiv = document.createElement('div');
    playerSetupDiv.id = 'player-setup';
    playerSetupDiv.style.position = 'fixed';
    playerSetupDiv.style.left = '20px';
    playerSetupDiv.style.top = '20px';
    playerSetupDiv.style.zIndex = '9999';
    playerSetupDiv.style.background = 'rgba(255,255,255,0.95)';
    playerSetupDiv.style.border = '1px solid #ccc';
    playerSetupDiv.style.padding = '12px';
    playerSetupDiv.style.borderRadius = '6px';
    playerSetupDiv.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
    document.body.appendChild(playerSetupDiv);
  }
  const idx = pendingPlayerIndex;
  const formHtml = `
    <div style="font:16px Arial; margin-bottom:8px;">Configuration du Joueur ${idx+1}</div>
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
      <label style="font:14px Arial;">Nom</label>
      <input id="pset-name" type="text" value="${players[idx].name || `Joueur ${idx+1}`}" style="font:14px Arial; padding:4px;" />
    </div>
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:12px;">
      <label style="font:14px Arial;">Faction</label>
      <select id="pset-faction" style="font:14px Arial; padding:4px;">
        <option ${players[idx].faction==='nintendo'?'selected':''} value="nintendo">Nintendo</option>
        <option ${players[idx].faction==='sega'?'selected':''} value="sega">SEGA</option>
        <option ${players[idx].faction==='playstation'?'selected':''} value="playstation">PlayStation</option>
        <option ${players[idx].faction==='xbox'?'selected':''} value="xbox">Xbox</option>
      </select>
    </div>
    <div style="display:flex; gap:8px;">
      <button id="pset-validate" style="font:14px Arial; padding:6px 10px;">Valider</button>
    </div>
  `;
  playerSetupDiv.innerHTML = formHtml;
  const btn = document.getElementById('pset-validate');
  btn.onclick = () => {
    const name = (document.getElementById('pset-name').value || '').trim() || `Joueur ${idx+1}`;
    const faction = (document.getElementById('pset-faction').value || 'nintendo');
    players[idx].name = name;
    players[idx].faction = faction;
    pendingPlayerIndex++;
    if (pendingPlayerIndex >= players.length) {
      // termin√©
      playerSetupDiv.remove();
      playerSetupDiv = null;
      infoText.setText("");
      setupDraftUI(scene);
  updateDraftUI();
    } else {
      showPlayerSetupForm(scene);
    }
  };
}

function setupDraftUI(scene) {
  rebuildChoiceList(scene);

  // bouton "Terminer" avec design du site
  endDraftBtn = scene.add.text(10, choiceListBottomY+10, "‚úÖ Terminer draft", 
    { 
      font: "16px Arial", 
      fill: "#ffffff", 
      backgroundColor: "#4CAF50",
      padding: { x: 12, y: 8 },
      stroke: "#2E7D32",
      strokeThickness: 2
    })
    .setInteractive()
    .on("pointerdown", () => endDraft(scene))
    .on("pointerover", () => endDraftBtn.setStyle({ backgroundColor: "#45a049" }))
    .on("pointerout", () => endDraftBtn.setStyle({ backgroundColor: "#4CAF50" }));

  // bouton "Tout supprimer" avec design du site
  clearAllBtn = scene.add.text(180, choiceListBottomY+10, "üóëÔ∏è Tout supprimer", 
    { 
      font: "16px Arial", 
      fill: "#ffffff", 
      backgroundColor: "#f44336",
      padding: { x: 12, y: 8 },
      stroke: "#c62828",
      strokeThickness: 2
    })
    .setInteractive()
    .on("pointerdown", () => clearCurrentBasket(scene))
    .on("pointerover", () => clearAllBtn.setStyle({ backgroundColor: "#d32f2f" }))
    .on("pointerout", () => clearAllBtn.setStyle({ backgroundColor: "#f44336" }));

  // labels/panneaux/hints dynamiques selon nombre de joueurs
  armyLabels = [];
  armyPanels = [];
  armyHints = [];
  armyThumbs = Array.from({ length: players.length }, () => []);
  for (let i = 0; i < players.length; i++) {
    const baseLabelY = 50 + i*280; // Espacement pour 5 lignes de personnages par √©quipe
    armyLabels[i] = scene.add.text(450, baseLabelY, `√âquipe J${i+1}`, { font: "16px Arial", fill: "#000" });
    armyPanels[i] = scene.add.rectangle(450, baseLabelY + 120, 320, 200, 0xffffff, 0).setStrokeStyle(0, 0).setVisible(false); // Panneau pour 5 lignes
    armyHints[i] = scene.add.text(450, baseLabelY + 20, "Cliquez pour retirer", { font: "12px Arial", fill: "#555" });
  }
  renderArmyThumbnails(scene);
}

function hasTexture(scene, key) {
  return scene.textures && typeof scene.textures.exists === 'function' && scene.textures.exists(key);
}

function rebuildChoiceList(scene) {
  const faction = players[currentPlayer] && players[currentPlayer].faction ? players[currentPlayer].faction : 'nintendo';
  const draftCatalog = getCatalogForFaction(faction);
  // d√©truire anciens choix
  if (choiceThumbs.length) {
    for (let entry of choiceThumbs) {
      entry.image.destroy();
      entry.nameText.destroy();
      entry.costText.destroy();
    }
    choiceThumbs = [];
  }
  currentChoicesFaction = faction;
  
  // Organiser les personnages en 4 colonnes
  const catalogKeys = Object.keys(draftCatalog);
  const itemsPerColumn = Math.ceil(catalogKeys.length / 4);
  
  let y = 50;
  let column = 0;
  let itemInColumn = 0;
  
  for (let key of catalogKeys) {
    const displayName = getDisplayNameForKey(key);
    const texKey = hasTexture(scene, key) ? key : 'nintendo';
    
    // Position X : 35, 130, 225, 320 pour les 4 colonnes
    const x = column === 0 ? 35 : (column === 1 ? 130 : (column === 2 ? 225 : 320));
    const textX = column === 0 ? 70 : (column === 1 ? 165 : (column === 2 ? 260 : 355));
    
    const img = scene.add.image(x, y, texKey)
      .setDisplaySize(40,40)
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const nameText = scene.add.text(textX, y - 8, displayName, { font: "12px Arial", fill: "#000" })
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const costText = scene.add.text(textX, y + 6, `cost: ${draftCatalog[key].cost}` , { font: "10px Arial", fill: "#333" });
    choiceThumbs.push({ key, image: img, nameText, costText });
    
    itemInColumn++;
    y += 55;
    
    // Passer √† la colonne suivante quand on a rempli la colonne actuelle
    if (itemInColumn >= itemsPerColumn && column < 3) {
      column++;
      y = 50; // Reset Y pour la nouvelle colonne
      itemInColumn = 0;
    }
  }
  
  // Calculer la position Y du bas en prenant la plus grande des quatre colonnes
  choiceListBottomY = Math.max(y, 50 + itemsPerColumn * 55);
  
  if (endDraftBtn) endDraftBtn.setY(choiceListBottomY + 10);
  if (clearAllBtn) clearAllBtn.setY(choiceListBottomY + 10);
}

function mapCharacterToFactionSprite(faction, baseKey) {
  // baseKey est d√©j√† la cl√© du sprite √† charger dans le dossier de la faction
  return baseKey;
}

function getDisplayNameForKey(key) {
  // Capitalise chaque mot
  return key.replaceAll('-', ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function updateDraftUI() {
  let p = players[currentPlayer];
  infoText.setText(`Joueur ${p.id+1} - Points restants: ${p.points}\nChoisissez vos persos`);
  rebuildChoiceList(infoText.scene); // reconstruire au changement de joueur/faction
  updateChoiceAvailability();
  const scene = infoText.scene;
  renderArmyThumbnails(scene);
  if (clearAllBtn) {
    clearAllBtn.setText(`üóëÔ∏è Tout supprimer (J${currentPlayer+1})`);
  }
}

function updateChoiceAvailability() {
  const p = players[currentPlayer];
  const catalog = getCatalogForFaction(p.faction);
  for (let entry of choiceThumbs) {
    const affordable = p.points >= catalog[entry.key].cost;
    entry.image.setAlpha(affordable ? 1 : 0.4);
    entry.nameText.setAlpha(affordable ? 1 : 0.5);
    entry.costText.setAlpha(affordable ? 1 : 0.5);
    if (affordable) {
      entry.image.setInteractive();
      entry.nameText.setInteractive();
    } else {
      entry.image.disableInteractive();
      entry.nameText.disableInteractive();
    }
  }
}

function renderArmyThumbnails(scene) {
  // nettoyer existants
  for (let i = 0; i < armyThumbs.length; i++) {
    for (let img of armyThumbs[i]) { img.destroy(); }
    armyThumbs[i] = [];
  }
  // re-cr√©er
  players.forEach((pl,i) => {
    const baseY = 80 + i*280; // Position sous le titre de l'√©quipe
    const maxItemsPerRow = 8; // Nombre maximum d'items par ligne
    const maxRows = 5; // Maximum 5 lignes par √©quipe
    const itemSpacing = 35; // Espacement entre les items
    const rowSpacing = 35; // Espacement entre les lignes
    
    pl.army.forEach((charKey, idx) => {
      const row = Math.floor(idx / maxItemsPerRow);
      const col = idx % maxItemsPerRow;
      
      // Limiter √† 5 lignes maximum
      if (row >= maxRows) return;
      
      const x = 450 + col * itemSpacing;
      const y = baseY + row * rowSpacing;
      
      const img = scene.add.image(x, y, charKey).setDisplaySize(30,30);
      if (i === currentPlayer && !gameStarted) {
        img.setInteractive().on("pointerdown", () => removeArmyItem(scene, i, idx));
      } else {
        img.disableInteractive();
        img.setAlpha(0.9);
      }
      armyThumbs[i].push(img);
    });
  });
}

function removeArmyItem(scene, playerIndex, itemIndex) {
  if (gameStarted) return;
  if (playerIndex !== currentPlayer) return;
  const key = players[playerIndex].army[itemIndex];
  if (!key) return;
  players[playerIndex].army.splice(itemIndex, 1);
  players[playerIndex].points += getCatalogForFaction(players[playerIndex].faction)[key].cost;
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function clearCurrentBasket(scene) {
  if (gameStarted) return;
  const p = players[currentPlayer];
  // Confirmation
  if (!window.confirm(`Voulez-vous supprimer tous les choix du Joueur ${currentPlayer+1} ?`)) {
    return;
  }
  // rembourser tous les choix
  let refund = 0;
  for (let key of p.army) {
    refund += getCatalogForFaction(p.faction)[key].cost;
  }
  p.points += refund;
  p.army = [];
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function pickCharacter(scene, key) {
  let p = players[currentPlayer];
  let char = getCatalogForFaction(p.faction)[key];
  if (p.points >= char.cost) {
    p.points -= char.cost;
    p.army.push(key);
    updateDraftUI();
  }
}

function endDraft(scene) {
  if (currentPlayer === players.length-1) {
    // Tous les joueurs ont fini => lancer la partie
    startGame(scene);
  } else {
    currentPlayer++;
    updateDraftUI();
  }
}

function rulesTextForEntry(entry) {
  const name = getDisplayNameForKey(entry.key || entry.type || '');
  const moves = (entry.moves || []).map(m => `(${m[0]},${m[1]})`).join(', ');
  const range = typeof entry.range === 'number' ? entry.range : 0;
  return `${name}: d√©placements ${moves || '‚Äî'} port√©e ${range || 0}`;
}

function buildRulesCatalog() {
  const map = new Map();
  // Ajouter les rois
  for (const f of Object.keys(kings)) {
    const k = kings[f];
    map.set(k.key, { key: k.key, moves: k.moves, range: k.range });
  }
  // Ajouter les pi√®ces des factions
  for (const f of Object.keys(factionCatalogs)) {
    const cat = factionCatalogs[f];
    for (const key of Object.keys(cat)) {
      const it = cat[key];
      map.set(key, { key, moves: it.moves, range: it.range });
    }
  }
  return map;
}

// Fonction pour obtenir le chemin de l'image de d√©monstration
function getMovementDemoImage(piece) {
  // Extraire le nom de fichier de l'image du personnage
  let fileName = piece.name;
  if (piece.image) {
    const imagePath = piece.image;
    const imageName = imagePath.split('/').pop().split('.')[0];
    fileName = imageName;
  }
  
  // Convertir en minuscules et remplacer les espaces par des tirets
  fileName = fileName.toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '');
  
  // Construire le chemin vers l'image de d√©monstration
  const faction = piece.faction.toLowerCase();
  return `public/images/${faction}/demo/${fileName}-movement-demo.png`;
}

function updateRulesSidebar() {
  const el = document.getElementById('rules-list');
  if (!el) return;
  
  console.log('updateRulesSidebar - pieces:', pieces);
  console.log('updateRulesSidebar - players:', players);
  
  const rulesMap = buildRulesCatalog();
  // Helper pour trouver la source d'image selon faction et type
  const getImgSrc = (faction, type, isKing) => {
    const file = isKing ? 'king' : type;
    return `public/images/${faction}/characters/${file}.png`;
  };
  // D√©dupliquer par (faction::keyAfficher)
  const presentByKey = new Map();
  for (const p of pieces) {
    const faction = players[p.player] && players[p.player].faction ? players[p.player].faction.toLowerCase() : 'nintendo';
    const isKing = p.type === 'king';
    
    let ruleKey, img, name, pieceData;
    
    if (isKing) {
      ruleKey = kings[faction] && kings[faction].key;
      img = getImgSrc(faction, 'king', true);
      name = translateKingName(p.name);
      pieceData = {
        name: name,
        moves: p.moves || [],
        range: p.range || 0,
        faction: faction,
        image: img
      };
    } else {
      // Pour les pi√®ces normales, utiliser les donn√©es stock√©es dans la pi√®ce
      ruleKey = p.name || 'piece';
      img = p.image || getImgSrc(faction, 'piece', false);
      name = p.name || 'Pi√®ce';
      pieceData = {
        name: name,
        moves: p.moves || [],
        range: p.range || 0,
        faction: faction,
        image: img
      };
    }
    
    const uniq = `${faction}::${ruleKey}`;
    if (!presentByKey.has(uniq)) {
      const text = isKing ? 
        `Roi: Peut se d√©placer dans toutes les directions (8 cases adjacentes)` :
        `${name}: ${p.moves ? p.moves.length : 0} directions de mouvement, port√©e ${p.range || 0}`;
      
      console.log('Ajout √† la sidebar:', { uniq, name, text, pieceData });
      presentByKey.set(uniq, { img, text, name, pieceData });
    }
  }
  if (presentByKey.size === 0) {
    el.innerHTML = '<div style="color:#666;">Aucune pi√®ce en jeu</div>';
    return;
  }
  const rows = [];
  presentByKey.forEach((v) => {
    // Obtenir le chemin de l'image de d√©monstration
    const demoImagePath = getMovementDemoImage(v.pieceData);
    
    rows.push(`<div style="display:flex; align-items:center; flex-direction: column; gap:8px; padding:8px; background:var(--secondary-bg); border-radius:6px;">
      <img src="${v.img}" alt="" style="width:48px; height:48px; object-fit:contain; display:block;" />
      <div style="font-weight:bold; margin-bottom:4px;">${v.name}</div>
      <img src="${demoImagePath}" alt="D√©monstration de mouvement" style="width:80px; height:80px; border:1px solid var(--border-color); border-radius:4px;" onerror="this.style.display='none'" />
    </div>`);
  });
  el.innerHTML = rows.join('');
}

// Fonction pour g√©n√©rer les positions en cercle autour du roi (plus fortes au centre)
function generateSpiralPositions(kingX, kingY, playerCount, playerIndex) {
  const positions = [];
  
  // G√©n√©rer les positions en cercles concentriques autour du roi
  // Cercle 1 (distance 1) - pour les pi√®ces tier 3 (plus fortes)
  const circle1 = [
    {x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1},
    {x: -1, y: 0},                  {x: 1, y: 0},
    {x: -1, y: 1},  {x: 0, y: 1},  {x: 1, y: 1}
  ];
  
  // Cercle 2 (distance 2) - pour les pi√®ces tier 2 (moyennes)
  const circle2 = [
    {x: -2, y: -2}, {x: -1, y: -2}, {x: 0, y: -2}, {x: 1, y: -2}, {x: 2, y: -2},
    {x: -2, y: -1},                                 {x: 2, y: -1},
    {x: -2, y: 0},                                  {x: 2, y: 0},
    {x: -2, y: 1},                                  {x: 2, y: 1},
    {x: -2, y: 2},  {x: -1, y: 2},  {x: 0, y: 2},  {x: 1, y: 2},  {x: 2, y: 2}
  ];
  
  // Cercle 3 (distance 3) - pour les pi√®ces tier 1 (faibles)
  const circle3 = [
    {x: -3, y: -3}, {x: -2, y: -3}, {x: -1, y: -3}, {x: 0, y: -3}, {x: 1, y: -3}, {x: 2, y: -3}, {x: 3, y: -3},
    {x: -3, y: -2},                                 {x: 3, y: -2},
    {x: -3, y: -1},                                 {x: 3, y: -1},
    {x: -3, y: 0},                                  {x: 3, y: 0},
    {x: -3, y: 1},                                  {x: 3, y: 1},
    {x: -3, y: 2},                                  {x: 3, y: 2},
    {x: -3, y: 3},  {x: -2, y: 3},  {x: -1, y: 3},  {x: 0, y: 3},  {x: 1, y: 3},  {x: 2, y: 3},  {x: 3, y: 3}
  ];
  
  // Filtrer les positions selon la position du joueur pour √©viter les conflits
  let filteredCircle1 = circle1;
  let filteredCircle2 = circle2;
  let filteredCircle3 = circle3;
  
  if (playerCount === 2) {
    if (playerIndex === 0) { // Joueur 1 (haut) - garder les positions du bas
      filteredCircle1 = circle1.filter(pos => pos.y >= 0);
      filteredCircle2 = circle2.filter(pos => pos.y >= 0);
      filteredCircle3 = circle3.filter(pos => pos.y >= 0);
    } else { // Joueur 2 (bas) - garder les positions du haut
      filteredCircle1 = circle1.filter(pos => pos.y <= 0);
      filteredCircle2 = circle2.filter(pos => pos.y <= 0);
      filteredCircle3 = circle3.filter(pos => pos.y <= 0);
    }
  } else if (playerCount === 3) {
    if (playerIndex === 0) { // Joueur 1 (haut) - garder les positions du bas
      filteredCircle1 = circle1.filter(pos => pos.y >= 0);
      filteredCircle2 = circle2.filter(pos => pos.y >= 0);
      filteredCircle3 = circle3.filter(pos => pos.y >= 0);
    } else if (playerIndex === 1) { // Joueur 2 (bas) - garder les positions du haut
      filteredCircle1 = circle1.filter(pos => pos.y <= 0);
      filteredCircle2 = circle2.filter(pos => pos.y <= 0);
      filteredCircle3 = circle3.filter(pos => pos.y <= 0);
    } else { // Joueur 3 (gauche) - garder les positions de droite
      filteredCircle1 = circle1.filter(pos => pos.x >= 0);
      filteredCircle2 = circle2.filter(pos => pos.x >= 0);
      filteredCircle3 = circle3.filter(pos => pos.x >= 0);
    }
  } else { // 4 joueurs
    if (playerIndex === 0) { // Joueur 1 (haut) - garder les positions du bas
      filteredCircle1 = circle1.filter(pos => pos.y >= 0);
      filteredCircle2 = circle2.filter(pos => pos.y >= 0);
      filteredCircle3 = circle3.filter(pos => pos.y >= 0);
    } else if (playerIndex === 1) { // Joueur 2 (bas) - garder les positions du haut
      filteredCircle1 = circle1.filter(pos => pos.y <= 0);
      filteredCircle2 = circle2.filter(pos => pos.y <= 0);
      filteredCircle3 = circle3.filter(pos => pos.y <= 0);
    } else if (playerIndex === 2) { // Joueur 3 (gauche) - garder les positions de droite
      filteredCircle1 = circle1.filter(pos => pos.x >= 0);
      filteredCircle2 = circle2.filter(pos => pos.x >= 0);
      filteredCircle3 = circle3.filter(pos => pos.x >= 0);
    } else { // Joueur 4 (droite) - garder les positions de gauche
      filteredCircle1 = circle1.filter(pos => pos.x <= 0);
      filteredCircle2 = circle2.filter(pos => pos.x <= 0);
      filteredCircle3 = circle3.filter(pos => pos.x <= 0);
    }
  }
  
  // Combiner les cercles dans l'ordre (plus proches en premier)
  const allDirections = [...filteredCircle1, ...filteredCircle2, ...filteredCircle3];
  
  // G√©n√©rer les positions en cercle
  for (const dir of allDirections) {
    const x = kingX + dir.x;
    const y = kingY + dir.y;
    
    // V√©rifier que la position est dans les limites et n'est pas sur le roi
    if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && !(x === kingX && y === kingY)) {
      positions.push({x, y});
    }
  }
  
  return positions;
}

function startGame(scene) {
  // Initialiser les poids des objets
  initItemWeights();
  
  // Couleurs des √©diteurs pour les backgrounds des pi√®ces (opacit√© 50%)
  const factionColors = {
    'Nintendo': 0xff0000, // Rouge Nintendo
    'PlayStation': 0x003791, // Bleu PlayStation  
    'SEGA': 0x0066cc, // Bleu SEGA
    'Xbox': 0x107c10 // Vert Xbox
  };
  
  gameStarted = true;
  currentPlayer = 0;
  
  // Afficher un message de d√©but de partie centr√©
  showInfoMessage("üéÆ La partie commence ! Bonne chance √† tous les joueurs !", 4000);
  // reset portails
  if (portalOrange && portalOrange.sprite) { portalOrange.sprite.destroy(); }
  if (portalBlue && portalBlue.sprite) { portalBlue.sprite.destroy(); }
  portalOrange = null;
  portalBlue = null;
  
  // reset tetriminos
  for (const t of tetriminos) {
    if (t.sprite) t.sprite.destroy();
  }
  tetriminos = [];
  
  // reset bananes
  for (const b of bananas) {
    if (b.sprite) b.sprite.destroy();
  }
  bananas = [];
  
  // reset pi√®ces perdues
  playerLostPieces = [];
  
  // reset pi√®ces poss√©d√©es
  for (const pp of possessedPieces) {
    if (pp.cursorSprite) pp.cursorSprite.destroy();
  }
  possessedPieces = [];
  
  // reset c≈ìurs
  for (const hp of heartPieces) {
    if (hp.heartSprite) hp.heartSprite.destroy();
  }
  heartPieces = [];
  
  // reset masque de Majora
  if (forcedPiece && forcedPiece.maskSprite) {
    forcedPiece.maskSprite.destroy();
  }
  forcedPiece = null;
  
  // reset ocarinas (cavaliers)
  for (const kp of knightPieces) {
    if (kp.ocarinaSprite) kp.ocarinaSprite.destroy();
  }
  knightPieces = [];
  infoText.setText("");
  // cacher widget d'option timer s'il existe c√¥t√© Phaser (supprim√© - obsol√®te)
  // cacher l'UI de draft (supprim√© - obsol√®te)
  // cacher l'aper√ßu des √©quipes pendant la partie (supprim√© - obsol√®te)

  // D√©truire l'ancienne grille si elle existe
  if (grid && grid.length > 0) {
    for (let y = 0; y < grid.length; y++) {
      if (grid[y]) {
        for (let x = 0; x < grid[y].length; x++) {
          if (grid[y][x] && grid[y][x].destroy) {
            grid[y][x].destroy();
          }
        }
      }
    }
  }
  
  // Cr√©er la nouvelle grille avec la taille correcte
  grid = [];
  for (let y=0; y<GRID_SIZE; y++) {
    grid[y] = [];
    for (let x=0; x<GRID_SIZE; x++) {
      const baseColor = (x+y)%2===0 ? 0xffffff : 0xcccccc;
      const rect = scene.add.rectangle(
        GRID_OFFSET_X + x*TILE_SIZE + TILE_SIZE/2,
        GRID_OFFSET_Y + y*TILE_SIZE + TILE_SIZE/2,
        TILE_SIZE-2, TILE_SIZE-2,
        baseColor
      ).setStrokeStyle(1,0x000000).setInteractive();
      rect.baseColor = baseColor;
      rect.pos = {x,y};
      rect.on('pointerdown', () => handleClick(scene, rect.pos));
      grid[y][x] = rect;
    }
  }

  // Placer les caisses d'objets selon la taille de grille
  itemCrates = [];
  const cratePositions = [];
  if (GRID_SIZE === 9) {
    const cx = Math.floor(GRID_SIZE/2);
    const cy = Math.floor(GRID_SIZE/2);
    cratePositions.push({ x: cx, y: cy });
  } else if (GRID_SIZE === 11) {
    // Positions demand√©es (1-based): [5,5], [5,7], [7,5], [7,7]
    // Conversion 0-based:
    cratePositions.push({ x: 4, y: 4 }, { x: 4, y: 6 }, { x: 6, y: 4 }, { x: 6, y: 6 });
  } else if (GRID_SIZE === 15) {
    // Positions demand√©es (1-based): [6,6], [6,10], [8,8], [10,6], [10,10]
    // Conversion 0-based:
    cratePositions.push({ x: 5, y: 5 }, { x: 5, y: 9 }, { x: 7, y: 7 }, { x: 9, y: 5 }, { x: 9, y: 9 });
  }
  for (const pos of cratePositions) {
    const sprite = scene.add.image(0,0,'item-crate');
    sprite.setDisplaySize(TILE_SIZE*0.6, TILE_SIZE*0.6);
    sprite.setAlpha(1);
    itemCrates.push({ x: pos.x, y: pos.y, sprite, active: true, lastRound: roundCounter });
  }

  // Helpers placement
  const getPlayerSide = (index) => {
    if (index === 0) return 'top';
    if (index === 1) return 'bottom';
    if (index === 2) return 'left';
    return 'right';
  };
  const mid = getKingCenterIndex(GRID_SIZE);

  const getBlockSlotsForSide = (side) => {
    // G√©n√©rer une spirale en coordonn√©es locales (autour de 0,0) puis mapper vers la grille
    let minDX, maxDX, minDY, maxDY;
    if (side === 'top' || side === 'bottom') {
      minDX = -2; maxDX = 2; minDY = 0; maxDY = 3; // 5x4
    } else { // left / right
      minDX = 0; maxDX = 3; minDY = -2; maxDY = 2; // 4x5
    }
    const area = (maxDX - minDX + 1) * (maxDY - minDY + 1);
    const needed = area - 1; // case du roi exclue

    const dirs = [ [1,0], [0,1], [-1,0], [0,-1] ]; // droite, bas, gauche, haut
    let stepLen = 1;
    let dirIndex = 0;
    let lx = 0, ly = 0; // coords locales
    const offsets = [];
    while (offsets.length < needed && stepLen < 100) {
      for (let repeat = 0; repeat < 2; repeat++) {
        const [dxStep, dyStep] = dirs[dirIndex];
        for (let s = 0; s < stepLen; s++) {
          lx += dxStep; ly += dyStep;
          if (lx >= minDX && lx <= maxDX && ly >= minDY && ly <= maxDY && !(lx === 0 && ly === 0)) {
            offsets.push({ dx: lx, dy: ly });
            if (offsets.length >= needed) break;
          }
        }
        dirIndex = (dirIndex + 1) % 4;
        if (offsets.length >= needed) break;
      }
      stepLen++;
    }

    // Map vers les coordonn√©es grille selon le c√¥t√©
    const slots = [];
    if (side === 'top') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: 0 + o.dy });
    } else if (side === 'bottom') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: GRID_SIZE - 1 - o.dy });
    } else if (side === 'left') {
      for (const o of offsets) slots.push({ x: 0 + o.dx, y: mid + o.dy });
    } else if (side === 'right') {
      for (const o of offsets) slots.push({ x: GRID_SIZE - 1 - o.dx, y: mid + o.dy });
    }
    return slots;
  };

  // Initialiser les joueurs
  players = [];
  for (let i = 0; i < playerCount; i++) {
    players.push({
      name: playerNames[i],
      faction: playerFactions[i]
    });
  }
  
  // Initialiser les timers
  playerTimersMs = [];
  for (let i = 0; i < playerCount; i++) {
    playerTimersMs.push(300000); // 5 minutes par joueur
  }

  // 1) Placer les rois par faction au centre exact du bord
  for (let i = 0; i < playerCount; i++) {
    let kingX = Math.floor(GRID_SIZE / 2);
    let kingY;
    
    if (playerCount === 2) {
      kingY = i === 0 ? 0 : GRID_SIZE - 1;
    } else if (playerCount === 3) {
      if (i === 0) {
        kingY = 0; // Joueur 1 en haut
      } else if (i === 1) {
        kingY = GRID_SIZE - 1; // Joueur 2 en bas
      } else if (i === 2) {
        kingY = Math.floor(GRID_SIZE / 2); // Joueur 3 au centre gauche
        kingX = 0;
      }
    } else { // 4 joueurs
      if (i === 0) {
        kingY = 0; // Joueur 1 en haut
      } else if (i === 1) {
        kingY = GRID_SIZE - 1; // Joueur 2 en bas
      } else if (i === 2) {
        kingY = Math.floor(GRID_SIZE / 2); // Joueur 3 au centre gauche
        kingX = 0;
      } else if (i === 3) {
        kingY = Math.floor(GRID_SIZE / 2); // Joueur 4 au centre droit
        kingX = GRID_SIZE - 1;
      }
    }
    
    // Cr√©er le background color√© pour le roi selon l'√©diteur (opacit√© 50%)
    const factionColor = factionColors[playerFactions[i]] || 0x808080; // Gris par d√©faut
    const kingBackgroundSprite = scene.add.rectangle(0, 0, TILE_SIZE, TILE_SIZE, factionColor, 0.5);
    kingBackgroundSprite.setDepth(100); // En arri√®re-plan
    
    const kingImageKey = `king-${playerFactions[i].toLowerCase()}`;
    const kingSprite = scene.add.image(0, 0, kingImageKey);
    kingSprite.setDepth(200); // Au-dessus du background
    
    const kingPiece = {
      sprite: kingSprite,
      backgroundSprite: kingBackgroundSprite, // Ajouter la r√©f√©rence au background
      type: 'king',
      x: kingX,
      y: kingY,
      player: i,
      name: `Roi ${playerNames[i]}`,
      image: `public/images/${playerFactions[i].toLowerCase()}/characters/king.png`,
      moves: [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]],
      range: 1
    };
    
    // Rendre le roi interactive
    kingSprite.setInteractive();
    kingSprite.on('pointerdown', () => handleClick(scene, { x: kingPiece.x, y: kingPiece.y }));
    
    pieces.push(kingPiece);
    console.log(`‚úì Roi cr√©√© pour Joueur ${i + 1}:`, kingPiece.name, `√† (${kingX}, ${kingY})`);
  }

  // 2) Placer les pi√®ces s√©lectionn√©es pour chaque joueur
  for (let i = 0; i < playerCount; i++) {
    const army = playerArmies[i] || [];
    let pieceCount = 0;
    
    console.log(`Joueur ${i + 1} - Arm√©e:`, army);
    
    // Trier les pi√®ces par tier (du plus fort au plus faible) pour le placement en spirale
    const sortedArmy = [...army].sort((a, b) => (b.tier || 1) - (a.tier || 1));
    
    sortedArmy.forEach(piece => {
      // Positionner les pi√®ces autour du roi
      let kingX = Math.floor(GRID_SIZE / 2);
      let kingY;
      
      if (playerCount === 2) {
        kingY = i === 0 ? 0 : GRID_SIZE - 1;
      } else if (playerCount === 3) {
        if (i === 0) {
          kingY = 0; // Joueur 1 en haut
        } else if (i === 1) {
          kingY = GRID_SIZE - 1; // Joueur 2 en bas
        } else if (i === 2) {
          kingY = Math.floor(GRID_SIZE / 2); // Joueur 3 au centre gauche
          kingX = 0;
        }
      } else { // 4 joueurs
        if (i === 0) {
          kingY = 0; // Joueur 1 en haut
        } else if (i === 1) {
          kingY = GRID_SIZE - 1; // Joueur 2 en bas
        } else if (i === 2) {
          kingY = Math.floor(GRID_SIZE / 2); // Joueur 3 au centre gauche
          kingX = 0;
        } else if (i === 3) {
          kingY = Math.floor(GRID_SIZE / 2); // Joueur 4 au centre droit
          kingX = GRID_SIZE - 1;
        }
      }
      
      // Calculer la position de la pi√®ce en spirale
      let pieceX, pieceY;
      
      // G√©n√©rer les positions en spirale autour du roi
      const spiralPositions = generateSpiralPositions(kingX, kingY, playerCount, i);
      
      if (pieceCount < spiralPositions.length) {
        const pos = spiralPositions[pieceCount];
        pieceX = pos.x;
        pieceY = pos.y;
      } else {
        // Fallback si on d√©passe les positions de spirale
        pieceX = kingX + (pieceCount % 3) - 1;
        pieceY = kingY + Math.floor(pieceCount / 3) + 1;
      }
      
      console.log(`Joueur ${i + 1} - Pi√®ce ${pieceCount + 1}:`, {
        name: piece.name,
        kingX, kingY,
        pieceX, pieceY,
        inBounds: pieceX >= 0 && pieceX < GRID_SIZE && pieceY >= 0 && pieceY < GRID_SIZE
      });
      
      // V√©rifier que la pi√®ce n'est pas sur la case du roi
      const isOnKing = (pieceX === kingX && pieceY === kingY);
      
      if (pieceX >= 0 && pieceX < GRID_SIZE && pieceY >= 0 && pieceY < GRID_SIZE && !isOnKing) {
        // Cr√©er le background color√© selon l'√©diteur (opacit√© 50%)
        const factionColor = factionColors[playerFactions[i]] || 0x808080; // Gris par d√©faut
        const backgroundSprite = scene.add.rectangle(0, 0, TILE_SIZE, TILE_SIZE, factionColor, 0.5);
        backgroundSprite.setDepth(100); // En arri√®re-plan
        
        // Utiliser le type de la pi√®ce comme cl√© d'image
        const imageKey = piece.type;
        const sprite = scene.add.image(0, 0, imageKey);
        sprite.setDepth(200); // Au-dessus du background
        
        const gamePiece = {
          sprite: sprite,
          backgroundSprite: backgroundSprite, // Ajouter la r√©f√©rence au background
          type: 'piece',
          x: pieceX,
          y: pieceY,
          player: i,
          name: piece.name,
          image: piece.image,
          moves: piece.moves,
          range: piece.range,
          cost: piece.cost,
          tier: piece.tier
        };
        
        // Rendre la pi√®ce interactive
        sprite.setInteractive();
        sprite.on('pointerdown', () => handleClick(scene, { x: gamePiece.x, y: gamePiece.y }));
        
        pieces.push(gamePiece);
        pieceCount++;
        console.log(`‚úì Pi√®ce cr√©√©e pour Joueur ${i + 1}:`, gamePiece.name, `√† (${pieceX}, ${pieceY})`);
      } else {
        console.log(`‚úó Pi√®ce hors limites pour Joueur ${i + 1}:`, piece.name, `(${pieceX}, ${pieceY})`);
      }
    });
  }

  console.log(`Total de pi√®ces cr√©√©es: ${pieces.length}`);
  console.log('Pi√®ces par joueur:', pieces.reduce((acc, p) => {
    acc[p.player] = (acc[p.player] || 0) + 1;
    return acc;
  }, {}));

  updatePieces();
  
  console.log('Nombre total de pi√®ces cr√©√©es:', pieces.length);
  
  // Mettre √† jour la sidebar apr√®s la cr√©ation de toutes les pi√®ces
  setTimeout(() => {
    updateRulesSidebar();
  }, 100);
  
  // Bandeau "D√©but de la partie" en haut de la grille
  const startText = scene.add.text(GRID_OFFSET_X + (GRID_SIZE*TILE_SIZE)/2, GRID_OFFSET_Y - 30, "üéÆ " + t('game-start').toUpperCase() + " ! üéÆ", { 
    font: "24px Arial", 
    fill: "#ffffff", 
    backgroundColor: "#2c3e50",
    padding: { x: 20, y: 10 },
    stroke: "#000000",
    strokeThickness: 3
  })
    .setOrigin(0.5, 0)
    .setDepth(2000);
  scene.time.delayedCall(2000, () => { startText.destroy(); });

  // Timers: init par taille
  const baseMinutes = (GRID_SIZE === 9) ? 5 : (GRID_SIZE === 11) ? 10 : 15;
  playerTimersMs = players.map(() => baseMinutes * 60 * 1000);
  // Cr√©er/mettre √† jour les textes timers pr√®s des noms
  if (timerTexts.length) { timerTexts.forEach(t => t && t.destroy()); }
  timerTexts = players.map((p,i) => {
    const nameText = playerNameTexts[i];
    const t = scene.add.text(0,0, formatMs(playerTimersMs[i]), { font: "14px Arial", fill: "#333", backgroundColor: "#fff" }).setDepth(1600);
    positionTimerTextNearName(t, nameText);
    return t;
  });
  // Lancer tick si activ√©
  if (timerEvent) timerEvent.remove(false);
  if (timerEnabled) {
    timerEvent = scene.time.addEvent({ delay: 250, loop: true, callback: () => tickTimer(scene) });
  }

  // Textes des noms des joueurs hors de la grille
  playerNameTexts.forEach(t => t && t.destroy());
  playerNameTexts = [];
  const midNames = getKingCenterIndex(GRID_SIZE);
  const margin = 12;
  players.forEach((p,i) => {
    const side = (i===0)?'top':(i===1)?'bottom':(i===2)?'left':'right';
    let nx = 0, ny = 0;
    if (side === 'top') { nx = GRID_OFFSET_X + midNames*TILE_SIZE + TILE_SIZE/2; ny = GRID_OFFSET_Y - 20; }
    if (side === 'bottom') { nx = GRID_OFFSET_X + midNames*TILE_SIZE + TILE_SIZE/2; ny = GRID_OFFSET_Y + GRID_SIZE*TILE_SIZE + 20; }
    if (side === 'left') { nx = GRID_OFFSET_X - 30; ny = GRID_OFFSET_Y + midNames*TILE_SIZE + TILE_SIZE/2; }
    if (side === 'right') { nx = GRID_OFFSET_X + GRID_SIZE*TILE_SIZE + 30; ny = GRID_OFFSET_Y + midNames*TILE_SIZE + TILE_SIZE/2; }
    const tintColor = brandTints[p.faction || 'nintendo'] || 0x000000;
    const factionLabel = getFactionDisplayName(p.faction || 'nintendo');
    const label = `${p.name} (${factionLabel})`;
    const txt = scene.add.text(nx, ny, label, { font: "18px Arial", fill: `#${tintColor.toString(16).padStart(6,'0')}` }).setOrigin(0.5);
    if (side === 'left') txt.setAngle(-90);
    if (side === 'right') txt.setAngle(90);
    txt.setDepth(1500);
    playerNameTexts.push(txt);
  });

  // Plus besoin d'ic√¥ne - le nom du joueur sera mis en √©vidence
  updateTurnUI();
  updateRulesSidebar();
}

function savePreset() {
  try {
    const preset = {
      gridSize: GRID_SIZE,
      players: players.map(p => ({ name: p.name, faction: p.faction }))
    };
    localStorage.setItem('vgb_preset', JSON.stringify(preset));
  } catch(e) {}
}

function loadPresetAndStart(scene) {
  try {
    const raw = localStorage.getItem('vgb_preset');
    if (!raw) return false;
    const preset = JSON.parse(raw);
    if (!preset || !preset.gridSize || !Array.isArray(preset.players) || preset.players.length < 2) return false;
    GRID_SIZE = preset.gridSize;
    const available = 900 - 2*GRID_OFFSET_Y;
    TILE_SIZE = Math.floor(available / GRID_SIZE);
    players = preset.players.map((pp, i) => ({ id: i, points: 20, army: [], name: pp.name || `Joueur ${i+1}`, faction: pp.faction || 'nintendo' }));
    currentPlayer = 0;
    setupDraftUI(scene);
    updateDraftUI();
    return true;
  } catch(e) { return false; }
}

function updatePieces() {
  for (let p of pieces) {
    p.sprite.x = GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2;
    p.sprite.y = GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2;
    
    // Positionner le background color√© s'il existe
    if (p.backgroundSprite) {
      p.backgroundSprite.x = GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2;
      p.backgroundSprite.y = GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2;
    }
    
    // ajuster la taille pour remplir la case moins une marge de bordure
    const targetSize = TILE_SIZE; // utiliser toute la case
    p.sprite.setDisplaySize(targetSize, targetSize);
    // Forcer une mise √† l'√©chelle enti√®re pour √©viter tout flou sous-pixel
    p.sprite.setOrigin(0.5, 0.5);
    // s'assurer que les pi√®ces restent au-dessus des overlays
    if (typeof p.sprite.setDepth === 'function') p.sprite.setDepth(1000);
    if (p.sprite.texture && p.sprite.texture.setFilter) p.sprite.texture.setFilter(Phaser.Textures.FilterMode.LINEAR);
  }
  if (itemCrates && itemCrates.length) {
    for (const c of itemCrates) {
      if (c.sprite) {
        c.sprite.x = GRID_OFFSET_X + c.x*TILE_SIZE + TILE_SIZE/2;
        c.sprite.y = GRID_OFFSET_Y + c.y*TILE_SIZE + TILE_SIZE/2;
        c.sprite.setDisplaySize(TILE_SIZE*0.6, TILE_SIZE*0.6);
      }
    }
  }
  // Portails: positionner leurs sprites si pr√©sents
  const scene = infoText && infoText.scene;
  if (portalOrange && portalOrange.sprite) {
    portalOrange.sprite.x = GRID_OFFSET_X + portalOrange.x*TILE_SIZE + TILE_SIZE/2;
    portalOrange.sprite.y = GRID_OFFSET_Y + portalOrange.y*TILE_SIZE + TILE_SIZE/2;
    portalOrange.sprite.setDisplaySize(TILE_SIZE*0.8, TILE_SIZE*0.8);
    portalOrange.sprite.setAlpha(1);
  }
  if (portalBlue && portalBlue.sprite) {
    portalBlue.sprite.x = GRID_OFFSET_X + portalBlue.x*TILE_SIZE + TILE_SIZE/2;
    portalBlue.sprite.y = GRID_OFFSET_Y + portalBlue.y*TILE_SIZE + TILE_SIZE/2;
    portalBlue.sprite.setDisplaySize(TILE_SIZE*0.8, TILE_SIZE*0.8);
    portalBlue.sprite.setAlpha(1);
  }
  // Curseurs Sims: positionner les curseurs au-dessus des pi√®ces poss√©d√©es
  for (const pp of possessedPieces) {
    if (pp.cursorSprite && pp.piece) {
      pp.cursorSprite.x = GRID_OFFSET_X + pp.piece.x * TILE_SIZE + TILE_SIZE/2 + 15;
      pp.cursorSprite.y = GRID_OFFSET_Y + pp.piece.y * TILE_SIZE + TILE_SIZE/2 - 20;
    }
  }
  // Effet √©toile: afficher un overlay d√©grad√© sous les pi√®ces prot√©g√©es
  if (starInvincible && starInvincible.playerId >= 0 && scene) {
    updateStarOverlays(scene);
      } else {
    clearStarOverlays();
    for (const p of pieces) if (p.sprite) { p.sprite.clearTint && p.sprite.clearTint(); p.sprite.setAlpha && p.sprite.setAlpha(1); }
  }
  // positionner les ic√¥nes d'objets √† c√¥t√© des noms
  if (playerItemIcons.length) {
    for (let i=0; i<playerItemIcons.length; i++) {
      const entries = playerItemIcons[i] || [];
      const nameText = playerNameTexts[i];
      if (nameText && entries.length) {
        const side = (i===0)?'top':(i===1)?'bottom':(i===2)?'left':'right';
        for (let k=0; k<entries.length; k++) {
          const e = entries[k];
          if (e && e.sprite) {
            // Positionnement selon le c√¥t√© du joueur
            if (side === 'top') {
              // Joueur du haut : objets √† droite du nom, align√©s horizontalement
              e.sprite.x = nameText.x + 38 + k*25;
              e.sprite.y = nameText.y - 20;
            } else if (side === 'bottom') {
              // Joueur du bas : objets en dessous du nom, align√©s horizontalement
              e.sprite.x = nameText.x + 38 + k*25;
              e.sprite.y = nameText.y + 20;
            } else if (side === 'left') {
              // Joueur de gauche (J3) : objets au-dessus du timer, align√©s horizontalement
              e.sprite.x = nameText.x + 20 - k * 20;
              e.sprite.y = nameText.y - nameText.displayHeight - 100;
            } else { // right
              // Joueur de droite (J4) : objets au-dessus du timer, align√©s horizontalement
              e.sprite.x = nameText.x + 20 - k * 20;
              e.sprite.y = nameText.y - nameText.displayHeight - 100;
            }
            e.sprite.setAngle(0); // pas de rotation pour les objets
            
            // overlay du compteur pour lightning
            if (e.item === 'lightning') {
              if (!e.counterText) {
                e.counterText = nameText.scene.add.text(0,0, '', { font: '12px Arial', fill: '#000', backgroundColor: '#fff' }).setDepth(2001);
              }
              const txt = (e.chargeTurns && e.chargeTurns > 0) ? String(e.chargeTurns) : '';
              e.counterText.setText(txt);
              e.counterText.x = e.sprite.x + 10;
              e.counterText.y = e.sprite.y - 10;
              e.sprite.setAlpha((e.chargeTurns && e.chargeTurns > 0) ? 0.6 : 1);
            } else if (e.counterText) {
              e.counterText.destroy();
              e.counterText = null;
            }
          }
        }
      }
    }
  }
  
  // Nettoyer les compteurs orphelins (compteurs sans sprite associ√©)
  cleanupOrphanedCounters();
  // Mettre √† jour les positions des c≈ìurs
  updateHeartPositions();
  // Mettre √† jour la position du masque de Majora
  updateMaskPosition();
  // Mettre √† jour les positions des ocarinas
  updateOcarinaPositions();
  updateRulesSidebar();
}

function startStarBlink(playerId) {
  // Initialiser la phase de l'effet et s'assurer que la texture arc-en-ciel existe
  starPhase = 0;
  if (infoText && infoText.scene) {
    ensureRainbowTileTexture(infoText.scene);
  }
}

function stopStarBlink(playerId) {
  // Nettoyer imm√©diatement l‚Äôeffet visuel pour ce joueur
  for (const p of pieces) {
    if (p.player === playerId && p.sprite) {
      p.sprite.clearTint();
      p.sprite.setAlpha(1);
    }
  }
}

function ensureRainbowTileTexture(scene) {
  const key = 'rainbow-tile';
  const size = Math.max(1, TILE_SIZE - 2);
  const existing = scene.textures.exists(key) ? scene.textures.get(key) : null;
  if (existing && existing.source[0] && existing.source[0].width === size && existing.source[0].height === size) return key;
  if (existing) scene.textures.remove(key);
  const tex = scene.textures.createCanvas(key, size, size);
  const ctx = tex.getContext();
  const grd = ctx.createLinearGradient(0, 0, size, size);
  grd.addColorStop(0.00, '#ff0040');
  grd.addColorStop(0.20, '#ff8000');
  grd.addColorStop(0.40, '#ffee00');
  grd.addColorStop(0.60, '#00dd55');
  grd.addColorStop(0.80, '#00aaff');
  grd.addColorStop(1.00, '#7a00ff');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, size, size);
  tex.refresh();
  return key;
}

function updateStarOverlays(scene) {
  if (!starInvincible || starInvincible.playerId < 0) { clearStarOverlays(); return; }
  const key = ensureRainbowTileTexture(scene);
  const desired = new Set();
  
  // Animation de l'effet arc-en-ciel
  starPhase += 0.1;
  const hue = (starPhase * 50) % 360;
  
  for (const p of pieces) {
    if (p.player === starInvincible.playerId) {
      const k = p.x + ',' + p.y;
      desired.add(k);
      if (!starTileOverlays.has(k)) {
        const img = scene.add.image(
          GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2,
          GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2,
          key
        );
        img.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
        img.setDepth(900); // sous la pi√®ce, au-dessus de la case
        img.setAlpha(0.85);
        starTileOverlays.set(k, img);
      } else {
        const img = starTileOverlays.get(k);
        img.x = GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2;
        img.y = GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2;
        img.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
        // Appliquer l'effet de couleur arc-en-ciel
        img.setTint(Phaser.Display.Color.HSVToRGB(hue/360, 0.8, 1).color);
      }
    }
  }
  // supprimer overlays non d√©sir√©s
  for (const [k, img] of Array.from(starTileOverlays.entries())) {
    if (!desired.has(k)) {
      if (img && img.destroy) img.destroy();
      starTileOverlays.delete(k);
    }
  }
}

function clearStarOverlays() {
  for (const [, img] of Array.from(starTileOverlays.entries())) {
    if (img && img.destroy) img.destroy();
  }
  starTileOverlays.clear();
}

function cleanupOrphanedCounters() {
  // Nettoyer les compteurs de lightning orphelins (sans sprite associ√©)
  for (let i=0; i<playerItemIcons.length; i++) {
    const entries = playerItemIcons[i] || [];
    for (let k=0; k<entries.length; k++) {
      const e = entries[k];
      if (e && e.counterText && (!e.sprite || e.sprite.destroyed)) {
        // Le sprite n'existe plus ou est d√©truit, supprimer le compteur
        e.counterText.destroy();
        e.counterText = null;
      }
    }
  }
}

function placePortal(color, pos) {
  const scene = infoText.scene;
  if (color === 'orange') {
    if (portalOrange && portalOrange.sprite) portalOrange.sprite.destroy();
    const spr = scene.add.image(0,0,'portal-orange');
    portalOrange = { x: pos.x, y: pos.y, sprite: spr };
  } else {
    if (portalBlue && portalBlue.sprite) portalBlue.sprite.destroy();
    const spr = scene.add.image(0,0,'portal-blue');
    portalBlue = { x: pos.x, y: pos.y, sprite: spr };
  }
}

function handleClick(scene, pos) {
  console.log('handleClick appel√©:', { pos, gameStarted, currentPlayer });
  if (!gameStarted) {
    console.log('Jeu pas encore d√©marr√©');
    return;
  }
  
  // Emp√™cher les joueurs √©limin√©s de jouer
  if (eliminationOrder.includes(currentPlayer)) {
    currentPlayer = getNextActivePlayer();
    updateTurnUI();
    return;
  }
  
  const clickedPiece = getPieceAt(pos);
  // Si un item est actif (ex: bombe), g√©rer l'effet et retourner
  if (currentItemAction && currentItemAction.active && currentItemAction.playerId === currentPlayer) {
    if (currentItemAction.type === 'bomb') {
      // Limite de placement: √† <=3 cases d'une pi√®ce du joueur
      const canPlace = canPlaceBombAt(pos, currentPlayer);
      if (!canPlace) return;
      detonateBombAt(pos);
      const bombInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null; // sortir du mode pose de bombe
      itemUsedThisTurn = true;
      clearHighlights(); // retirer l'indicateur de placement
      // consommer l'item bombe s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof bombInventoryIndex === 'number') ? bombInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'bobomb');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'portal_orange' && currentItemAction.stage === 'orange') {
      if (getPieceAt(pos)) return; // doit √™tre vide
      placePortal('orange', pos);
      currentItemAction.type = 'portal_blue';
      currentItemAction.stage = 'blue';
      if (infoText) infoText.setText(`Joueur ${currentPlayer+1}: placez le portail BLEU`);
      const allowed = getAllEmptyCells();
      highlightPositions(allowed, 0x90caf9); // bleu p√¢le
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'portal_blue' && currentItemAction.stage === 'blue') {
      if (getPieceAt(pos)) return; // doit √™tre vide
      placePortal('blue', pos);
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      // consommer l'item portals s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (currentItemAction && typeof currentItemAction.inventoryIndex === 'number') ? currentItemAction.inventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'portals');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'tetrimino') {
      // V√©rifier si le tetrimino peut √™tre plac√© √† cette position
      if (!canPlaceTetriminoAt(pos.x, pos.y)) return;
      placeTetrimino(pos);
      const tetriminoInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      // consommer l'item tetrimino s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof tetriminoInventoryIndex === 'number') ? tetriminoInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'tetrimino');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'tornado') {
      // V√©rifier si le roi peut √™tre t√©l√©port√© √† cette position
      if (!canTeleportKingTo(pos.x, pos.y)) return;
      teleportKingTo(currentPlayer, pos);
      const tornadoInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      // consommer l'item tornado s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof tornadoInventoryIndex === 'number') ? tornadoInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'tornado');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'banana') {
      // V√©rifier si la banane peut √™tre plac√©e √† cette position
      if (!canPlaceBananaAt(pos.x, pos.y)) return;
      placeBanana(pos);
      const bananaInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      // consommer l'item banane s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof bananaInventoryIndex === 'number') ? bananaInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'banana');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'cursor') {
      // V√©rifier si une pi√®ce peut √™tre poss√©d√©e √† cette position
      const targetPiece = getPieceAt(pos);
      if (!targetPiece || !canPossessPiece(targetPiece, currentPlayer)) return;
      possessPiece(targetPiece, currentPlayer);
      const cursorInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights(); // Effacer le fond vert p√¢le
      hideInfoMessage();
      // consommer l'item curseur s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof cursorInventoryIndex === 'number') ? cursorInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'cursor');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'heart') {
      // V√©rifier si une pi√®ce est cliqu√©e
      if (!clickedPiece) return;
      
      // Donner un c≈ìur √† la pi√®ce
      giveHeartToPiece(clickedPiece);
      const heartInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      
      // Consommer l'item c≈ìur
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof heartInventoryIndex === 'number') ? heartInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'heart');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'mask') {
      // V√©rifier si une pi√®ce adverse est cliqu√©e
      if (!clickedPiece || clickedPiece.player === currentPlayer) return;
      
      // Appliquer le masque de Majora √† la pi√®ce adverse
      applyMaskToPiece(clickedPiece);
      const maskInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      
      // Consommer l'item masque
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof maskInventoryIndex === 'number') ? maskInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'mask');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'ocarina') {
      // V√©rifier si une pi√®ce est cliqu√©e
      if (!clickedPiece) return;
      
      // Appliquer l'Ocarina du Temps √† la pi√®ce
      applyOcarinaToPiece(clickedPiece);
      const ocarinaInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      
      // Consommer l'item ocarina
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof ocarinaInventoryIndex === 'number') ? ocarinaInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'ocarina');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
  }

  // Si le joueur a une pi√®ce forc√©e, emp√™cher la s√©lection d'autres pi√®ces
  if (forcedPiece && forcedPiece.playerId === currentPlayer && forcedPiece.piece && clickedPiece && clickedPiece !== forcedPiece.piece) {
    showInfoMessage(`Vous √™tes forc√© de jouer cette pi√®ce par le Masque de Majora !`, 3000);
    return;
  }
  
  // S√©lection/d√©s√©lection d'une pi√®ce du joueur courant (y compris les pi√®ces poss√©d√©es qui restent contr√¥l√©es par leur joueur d'origine)
  if (clickedPiece && clickedPiece.player === currentPlayer) {
    // Si c'est la m√™me pi√®ce d√©j√† s√©lectionn√©e, la d√©s√©lectionner
    if (selectedPiece && selectedPiece === clickedPiece) {
      selectedPiece = null;
      clearHighlights();
      return;
    }
    
    // Sinon, s√©lectionner la nouvelle pi√®ce
    selectedPiece = clickedPiece;
    const reachable = getReachablePositions(selectedPiece);
    highlightPositions(reachable);
    return;
  }
  
  // Afficher les mouvements d'une pi√®ce adverse (en rouge) quand on clique dessus
  if (clickedPiece && clickedPiece.player !== currentPlayer) {
    // D√©s√©lectionner toute pi√®ce du joueur courant
    selectedPiece = null;
    clearHighlights();
    
    // Afficher les mouvements de la pi√®ce adverse en rouge
    const enemyReachable = getReachablePositions(clickedPiece);
    highlightPositions(enemyReachable, 0xff0000); // Rouge pour les mouvements adverses
    return;
  }

  // D√©placement si une pi√®ce est s√©lectionn√©e et la case est atteignable
  if (selectedPiece) {
    const reachable = getReachablePositions(selectedPiece);
    const isReachable = reachable.some(p => p.x === pos.x && p.y === pos.y);
    if (isReachable) {
      // Capture √©ventuelle sur la case cible
      const target = getPieceAt(pos);
      if (target && target.player !== selectedPiece.player) {
        // Protection √©toile: impossible de capturer si la cible est prot√©g√©e
        if (starInvincible && starInvincible.playerId === target.player && starInvincible.untilPlayerTurn) {
          // annuler la capture
          return;
        }
        const capturedKing = target.type === 'king';
        
        // V√©rifier si la pi√®ce cible a un c≈ìur
        const hasHeart = heartPieces.some(hp => hp.piece === target);
        if (hasHeart) {
          // La pi√®ce a un c≈ìur : elle reste en place mais perd son c≈ìur
          removeHeartFromPiece(target);
          showInfoMessage(`La pi√®ce a perdu son c≈ìur !`, 2000);
          // La pi√®ce reste en place, pas de capture
        } else {
          // Pas de c≈ìur : capture normale
          // Enregistrer la pi√®ce perdue pour la queue de phoenix
          playerLostPieces.push({ playerId: target.player, piece: { ...target } });
          // Nettoyer l'exposant du curseur Sims si la pi√®ce √©tait poss√©d√©e
          cleanupCursorForPiece(target);
          // Nettoyer l'ocarina si la pi√®ce en avait un
          removeOcarinaFromPiece(target);
        target.sprite.destroy();
        if (target.backgroundSprite) target.backgroundSprite.destroy();
        pieces = pieces.filter(p => p !== target);
        }
        // V√©rifier si la pi√®ce tr√©buche sur une banane
        if (checkBananaTrip(selectedPiece, pos)) {
          // La pi√®ce tr√©buche, elle est d√©plac√©e sur la case de la banane
          updatePieces();
          clearHighlights();
          selectedPiece = null;
          // Terminer le tour et passer au joueur suivant
          moveCount++;
          if (moveCount % 5 === 0) rotateAds();
          currentPlayer = getNextActivePlayer(); // changer de joueur en sautant les √©limin√©s
          updateTurnUI();
          return;
        }
        // D√©placer la pi√®ce du joueur sur la case captur√©e
        selectedPiece.x = pos.x;
        selectedPiece.y = pos.y;
        // R√©cup√©ration de la caisse
        maybePickupItem(selectedPiece);
        updatePieces();
        clearHighlights();
        selectedPiece = null;
        // Gestion √©limination et condition de fin
        if (capturedKing) {
          if (!eliminationOrder.includes(target.player)) {
            eliminationOrder.push(target.player);
            
            // Supprimer TOUTES les pi√®ces du joueur √©limin√©
            const eliminatedPlayerId = target.player;
            const piecesToRemove = pieces.filter(p => p.player === eliminatedPlayerId);
            
            for (const piece of piecesToRemove) {
              // Nettoyer les √©l√©ments associ√©s avant suppression
              cleanupCursorForPiece(piece);
              removeHeartFromPiece(piece);
              removeOcarinaFromPiece(piece);
              if (piece.sprite) piece.sprite.destroy();
              if (piece.backgroundSprite) piece.backgroundSprite.destroy();
            }
            
            // Retirer toutes les pi√®ces du joueur √©limin√© du tableau pieces
            pieces = pieces.filter(p => p.player !== eliminatedPlayerId);
            
            // Annoncer l'√©limination du joueur
            const eliminatedPlayer = players[eliminatedPlayerId];
            showInfoMessage(`‚öîÔ∏è ${eliminatedPlayer.name} a √©t√© √©limin√© ! Toutes ses pi√®ces ont disparu.`, 3000);
          }
          const remainingKings = pieces.filter(pp => pp.type === 'king').length;
          if (remainingKings <= 1) {
            // d√©terminer le vainqueur (roi encore vivant)
            let winnerId = null;
            const kingPiece = pieces.find(pp => pp.type === 'king');
            if (kingPiece) winnerId = kingPiece.player;
            // construire classement
            let ranking = [];
            if (winnerId !== null) ranking.push(winnerId);
            const rest = eliminationOrder.slice().reverse();
            for (let pid of rest) {
              if (winnerId === null || pid !== winnerId) ranking.push(pid);
            }
            endGameWithRanking(ranking);
          return;
        }
        }
        moveCount++;
        if (moveCount % 5 === 0) rotateAds();
        updateAdInfo();
        
        // Supprimer le masque de Majora si la pi√®ce forc√©e a √©t√© jou√©e
        if (forcedPiece && forcedPiece.piece === selectedPiece) {
          if (forcedPiece.maskSprite) {
            forcedPiece.maskSprite.destroy();
          }
          forcedPiece = null;
        }
        
        // fin de tour
        let oldRound = roundCounter;
        if (shouldIncrementRoundCounter()) { roundCounter++; }
        currentPlayer = getNextActivePlayer(); // changer de joueur en sautant les √©limin√©s
        if (roundCounter !== oldRound) {
          decrementLightningCharges();
          // L'effet √©toile est maintenant g√©r√© dans updateTurnUI()
        }
        itemUsedThisTurn = false;
        maybeRespawnCrate(scene);
        updateTurnUI();
        // repositionner tous les timers
        if (timerTexts && playerNameTexts) {
          for (let i=0;i<timerTexts.length;i++) {
            if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
          }
        }
        return;
      }
      // V√©rifier si la pi√®ce tr√©buche sur une banane
      if (checkBananaTrip(selectedPiece, pos)) {
        // La pi√®ce tr√©buche, elle est d√©plac√©e sur la case de la banane
        updatePieces();
        clearHighlights();
        
        // Supprimer le masque de Majora si la pi√®ce forc√©e a √©t√© jou√©e
        if (forcedPiece && forcedPiece.piece === selectedPiece) {
          if (forcedPiece.maskSprite) {
            forcedPiece.maskSprite.destroy();
          }
          forcedPiece = null;
        }
        
        selectedPiece = null;
        // Terminer le tour et passer au joueur suivant
        moveCount++;
        if (moveCount % 5 === 0) rotateAds();
        currentPlayer = getNextActivePlayer(); // changer de joueur en sautant les √©limin√©s
        updateTurnUI();
        return;
      }
      // Case vide
      selectedPiece.x = pos.x;
      selectedPiece.y = pos.y;
      // R√©cup√©ration de la caisse
      maybePickupItem(selectedPiece);
      updatePieces();
      clearHighlights();
      
      // Supprimer le masque de Majora si la pi√®ce forc√©e a √©t√© jou√©e
      if (forcedPiece && forcedPiece.piece === selectedPiece) {
        if (forcedPiece.maskSprite) {
          forcedPiece.maskSprite.destroy();
        }
        forcedPiece = null;
      }
      
      selectedPiece = null;
      moveCount++;
      if (moveCount % 5 === 0) rotateAds();
      updateAdInfo();
      // fin de tour
      let oldRound = roundCounter;
      if (shouldIncrementRoundCounter()) { roundCounter++; }
      currentPlayer = getNextActivePlayer(); // changer de joueur en sautant les √©limin√©s
      // d√©cr√©menter les charges uniquement quand un round complet vient de s'achever
      if (roundCounter !== oldRound) {
        decrementLightningCharges();
        // L'effet √©toile est maintenant g√©r√© dans updateTurnUI()
      }
      itemUsedThisTurn = false;
      maybeRespawnCrate(scene);
      updateTurnUI();
      // repositionner tous les timers
      if (timerTexts && playerNameTexts) {
        for (let i=0;i<timerTexts.length;i++) {
          if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
        }
      }
    } else {
      // Clic non valide: nettoyer la s√©lection pour √©viter la confusion
      clearHighlights();
      selectedPiece = null;
    }
  }
}

function isValidMove(piece, pos) {
  const reachable = getReachablePositions(piece);
  return reachable.some(p => p.x === pos.x && p.y === pos.y);
}

function getPieceAt(pos) {
  return pieces.find(p => p.x === pos.x && p.y === pos.y);
}

function getReachablePositions(piece) {
  const positions = [];
  const rule = getRuleForPiece(piece);
  
  // V√©rifier si la pi√®ce est poss√©d√©e et limiter ses mouvements √† sa "maison"
  const possessed = possessedPieces.find(pp => pp.piece === piece);
  if (possessed) {
    // Limiter les mouvements aux limites de la maison
    const houseBounds = possessed.houseBounds;
    const iterateFrom = (startX, startY, dir, maxSteps, usedTeleport) => {
      for (let step = 1; step <= maxSteps; step++) {
        const nx = startX + dir[0] * step;
        const ny = startY + dir[1] * step;
        
        // V√©rifier les limites de la maison
        if (nx < houseBounds.startX || nx > houseBounds.endX || 
            ny < houseBounds.startY || ny > houseBounds.endY) {
          break; // Sortir des limites de la maison
        }
        
        const occ = getPieceAt({ x: nx, y: ny });
        if (occ && occ.player === piece.player) break; // Pi√®ce alli√©e
        if (occ && occ.player !== piece.player) {
          // V√©rifier protection √©toile
          if (starInvincible && starInvincible.playerId === occ.player && starInvincible.untilPlayerTurn) {
            continue; // Pi√®ce prot√©g√©e, continuer
          }
          positions.push({ x: nx, y: ny }); // Capturer
          break;
        }
        positions.push({ x: nx, y: ny }); // Case vide
      }
    };
    
    // Appliquer les mouvements selon les r√®gles
    for (const dir of rule.moves) {
      iterateFrom(piece.x, piece.y, dir, rule.range, false);
    }
    
    return positions;
  }

  const isPortalPos = (x, y, color) => {
    if (color === 'orange' && portalOrange) return portalOrange.x === x && portalOrange.y === y;
    if (color === 'blue' && portalBlue) return portalBlue.x === x && portalBlue.y === y;
    return false;
  };

  const isTetriminoPos = (x, y) => {
    return tetriminos.some(t => t.x === x && t.y === y);
  };

  const iterateFrom = (startX, startY, dir, maxSteps, usedTeleport) => {
    for (let step = 1; step <= maxSteps; step++) {
      const nx = startX + dir[0] * step;
      const ny = startY + dir[1] * step;
      if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break;
      
      // V√©rifier si la case contient un tetrimino (mur)
      if (isTetriminoPos(nx, ny)) {
        // Les cavaliers peuvent sauter par-dessus les tetriminos
        // Un cavalier se d√©place en L (2+1 ou 1+2), donc range = 1 et step = 1
        const isKnightMove = (rule.range === 1 && step === 1 && 
          (Math.abs(dir[0]) === 2 && Math.abs(dir[1]) === 1) || 
          (Math.abs(dir[0]) === 1 && Math.abs(dir[1]) === 2));
        
        if (isKnightMove) {
          continue; // continuer le mouvement (sauter par-dessus)
        } else {
          break; // s'arr√™ter pour les autres pi√®ces
        }
      }
      
      const occ = getPieceAt({ x: nx, y: ny });

      // Portail: si on touche ORANGE et BLUE existe, on permet de poursuivre depuis BLUE
      if (!usedTeleport && isPortalPos(nx, ny, 'orange') && portalBlue) {
        // On peut s'arr√™ter sur orange si vide
        if (!occ) positions.push({ x: nx, y: ny });
        // Calculer pas restants apr√®s avoir atteint orange
        const remaining = maxSteps - step;
        // Si la case BLEUE est occup√©e
        const occBlue = getPieceAt({ x: portalBlue.x, y: portalBlue.y });
        if (occBlue) {
        // Si ennemi: on peut capturer BLEU puis on s'arr√™te (si pas prot√©g√© par √©toile)
        if (occBlue.player !== piece.player && !(starInvincible && starInvincible.playerId === occBlue.player && starInvincible.untilPlayerTurn)) {
          positions.push({ x: portalBlue.x, y: portalBlue.y });
        }
          break;
        } else {
          // Ajouter la case BLEUE comme atteignable et poursuivre au-del√†
          positions.push({ x: portalBlue.x, y: portalBlue.y });
          if (remaining > 0) {
            // continuer depuis BLEU dans la m√™me direction
            iterateFrom(portalBlue.x, portalBlue.y, dir, remaining, true);
          }
          break;
        }
      }

      if (!occ) {
        positions.push({ x: nx, y: ny });
        continue;
      }
      // Case occup√©e: on peut capturer un ennemi mais on s'arr√™te ensuite
      if (occ.player !== piece.player) {
        // V√©rifier si la pi√®ce cible est prot√©g√©e par l'√©toile
        if (!(starInvincible && starInvincible.playerId === occ.player && starInvincible.untilPlayerTurn)) {
        positions.push({ x: nx, y: ny });
        }
      }
      break;
    }
  };

  // Gestion sp√©ciale pour les cavaliers (mouvements en L)
  const isKnightMove = (dir) => {
    return rule.range === 1 && (
      (Math.abs(dir[0]) === 2 && Math.abs(dir[1]) === 1) || 
      (Math.abs(dir[0]) === 1 && Math.abs(dir[1]) === 2)
    );
  };

  for (let dir of rule.moves) {
    if (isKnightMove(dir)) {
      // Mouvement de cavalier : sauter directement √† la case de destination
      const nx = piece.x + dir[0];
      const ny = piece.y + dir[1];
      if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
        const occ = getPieceAt({ x: nx, y: ny });
        if (!occ) {
          positions.push({ x: nx, y: ny });
        } else if (occ.player !== piece.player) {
          // V√©rifier si la pi√®ce cible est prot√©g√©e par l'√©toile
          if (!(starInvincible && starInvincible.playerId === occ.player && starInvincible.untilPlayerTurn)) {
            positions.push({ x: nx, y: ny });
          }
        }
      }
    } else {
      iterateFrom(piece.x, piece.y, dir, rule.range, false);
    }
  }
  return positions;
}

function getRuleForPiece(piece) {
  // Retourne l'objet { moves, range } pour la pi√®ce
  // Utiliser directement les mouvements de la pi√®ce si disponibles
  if (piece.moves && piece.range !== undefined) {
    return { moves: piece.moves, range: piece.range };
  }
  
  // Fallback pour les anciennes pi√®ces
  const owner = players[piece.player];
  if (!owner) return { moves: [], range: 0 };
  if (piece.type === 'king') {
    const k = kings[owner.faction];
    return k ? { moves: k.moves, range: k.range } : { moves: [], range: 0 };
  }
  const catalog = getCatalogForFaction(owner.faction);
  const entry = catalog[piece.type];
  return entry ? { moves: entry.moves, range: entry.range } : { moves: [], range: 0 };
}

function endGameWithRanking(ranking) {
  gameStarted = false;
  clearHighlights();
  let msg = '';
  if (Array.isArray(ranking) && ranking.length > 0) {
    msg = 'Classement final:\n' + ranking.map((pid, idx) => `${idx+1}. Joueur ${pid+1}`).join('\n');
  } else {
    msg = 'Partie termin√©e.';
  }
  if (turnText) {
    turnText.setText(msg);
  } else if (infoText) {
    infoText.setText(msg);
  }
  // M√©moriser les r√©glages actuels pour relancer facilement
  savePreset();
  // Bouton DOM pour relancer avec les m√™mes r√©glages
  let btn = document.getElementById('restart-same-settings');
  if (btn) btn.remove();
  btn = document.createElement('button');
  btn.id = 'restart-same-settings';
  btn.textContent = 'D√©marrer une nouvelle partie avec les m√™mes r√©glages';
  btn.style.position = 'fixed';
  btn.style.right = '20px';
  btn.style.bottom = '20px';
  btn.style.zIndex = '9999';
  btn.style.padding = '10px 12px';
  btn.style.font = '14px Arial';
  btn.style.background = '#cfc';
  btn.style.border = '1px solid #9c9';
  btn.style.borderRadius = '6px';
  btn.onclick = () => {
    try { localStorage.setItem('vgb_start_with_preset', '1'); } catch(e) {}
    window.location.reload();
  };
  document.body.appendChild(btn);
}

function maybePickupItem(piece) {
  if (!itemCrates || !itemCrates.length) return;
  for (const c of itemCrates) {
    if (!c.active) continue;
    if (piece.x === c.x && piece.y === c.y) {
      const item = rollRandomItem();
      giveItemToPlayer(piece.player, item);
      c.active = false;
      if (c.sprite) { c.sprite.setAlpha(0.25); }
      c.lastRound = roundCounter;
    }
  }
}

function giveItemToPlayer(playerId, itemKey) {
  const scene = infoText.scene;
  // cr√©er une ic√¥ne (empilement jusqu'√† 3 max)
  if (!playerItemIcons[playerId]) playerItemIcons[playerId] = [];
  if (playerItemIcons[playerId].length >= 3) return; // limite 3 objets
  const textureKey = (itemKey === 'portals') ? 'portals' : itemKey;
  const icon = scene.add.image(0,0,textureKey).setDisplaySize(24,24).setInteractive();
  icon.on('pointerdown', () => tryUseItem(playerId, icon));
  // Pour lightning: ajouter compteur 4 tours complets avant utilisation
  const entry = { sprite: icon, item: itemKey };
  if (itemKey === 'lightning') entry.chargeTurns = 5;
  playerItemIcons[playerId].push(entry);
  updatePieces();
}

function tryUseItem(playerId, clickedIconSprite) {
  if (!gameStarted) return;
  if (playerId !== currentPlayer) return; // utiliser √† son tour
  if (itemUsedThisTurn) return; // un seul objet par tour
  const arr = playerItemIcons[playerId] || [];
  if (arr.length === 0) return;
  let idx = 0;
  if (clickedIconSprite) {
    const found = arr.findIndex(e => e && e.sprite === clickedIconSprite);
    if (found >= 0) idx = found;
  }
  const icon = arr[idx];
  if (!icon || !icon.item) return;
  if (icon.item === 'bobomb') {
    // Activer mode pose de bombe: prochain clic sur une case pose et r√©sout l'effet
    currentItemAction = { playerId, type: 'bomb', active: true, inventoryIndex: idx };
    if (infoText) infoText.setText(`Joueur ${playerId+1}: cliquez sur une case pour poser la bombe`);
    // Highlight des cases possibles
    const allowed = getBombPlacablePositions(playerId);
    highlightPositions(allowed, 0xff8a80); // rouge/ros√©
  }
  if (icon.item === 'portals') {
    currentItemAction = { playerId, type: 'portal_orange', active: true, stage: 'orange', inventoryIndex: idx };
    if (infoText) infoText.setText(`Joueur ${playerId+1}: placez le portail ORANGE`);
    const allowed = getAllEmptyCells();
    highlightPositions(allowed, 0xffcc80); // orange p√¢le
  }
  if (icon.item === 'lightning') {
    // Non utilisable tant que charge > 0
    if (icon.chargeTurns && icon.chargeTurns > 0) return;
    // D√©clencher effet √©clair
    triggerLightningEffect();
    // Tuer toutes les pi√®ces sur cases blanches
    applyLightningKill();
    // Consommer l'item s√©lectionn√©
    const useIdx = idx;
    if (playerItemIcons[playerId] && playerItemIcons[playerId].length && useIdx >= 0) {
      const used = playerItemIcons[playerId].splice(useIdx, 1)[0];
      if (used && used.sprite) used.sprite.destroy();
      if (used && used.counterText) used.counterText.destroy();
    }
    itemUsedThisTurn = true;
    updatePieces();
    // Fin de tour apr√®s usage de l'√©clair
    moveCount++;
    if (moveCount % 5 === 0) rotateAds();
    updateAdInfo();
    if (shouldIncrementRoundCounter()) { roundCounter++; }
    currentPlayer = getNextActivePlayer();
    itemUsedThisTurn = false;
    decrementLightningCharges();
    // L'effet √©toile est maintenant g√©r√© dans updateTurnUI()
    maybeRespawnCrate(infoText.scene);
    updateTurnUI();
    // repositionner timers si pr√©sents
    if (timerTexts && playerNameTexts) {
      for (let i=0;i<timerTexts.length;i++) {
        if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
      }
    }
  }
  if (icon.item === 'star') {
    // Activer invincibilit√© jusqu'√† ce que le joueur rejoue
    starInvincible = { playerId, untilRound: -1, untilPlayerTurn: true };
    startStarBlink(playerId);
    try {
      // Arr√™ter un √©ventuel son pr√©c√©dent et jouer celui de l'√©toile
      const s = infoText.scene.sound;
      if (s && s.stopAll) s.stopAll();
      s.play('star', { volume: 0.7, loop: true });
    } catch(e) {}
    // Forcer la mise √† jour imm√©diate de l'effet visuel
    updatePieces();
    // Consommer l'item s√©lectionn√©
    const useIdx = idx;
    if (playerItemIcons[playerId] && playerItemIcons[playerId].length && useIdx >= 0) {
      const used = playerItemIcons[playerId].splice(useIdx, 1)[0];
      if (used && used.sprite) used.sprite.destroy();
    }
    itemUsedThisTurn = true;
    updatePieces();
    // Fin de tour apr√®s usage de l'√©toile
    moveCount++;
    if (moveCount % 5 === 0) rotateAds();
    updateAdInfo();
        let oldRound = roundCounter;
        if (shouldIncrementRoundCounter()) { roundCounter++; }
        currentPlayer = getNextActivePlayer();
        if (roundCounter !== oldRound) {
      decrementLightningCharges();
      // L'effet √©toile est maintenant g√©r√© dans updateTurnUI()
    }
    itemUsedThisTurn = false;
    decrementLightningCharges();
    maybeRespawnCrate(infoText.scene);
    updateTurnUI();
    // repositionner timers si pr√©sents
    if (timerTexts && playerNameTexts) {
      for (let i=0;i<timerTexts.length;i++) {
        if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
      }
    }
  }
  if (icon.item === 'tetrimino') {
    // Activer mode pose de tetrimino: prochain clic sur une case pose le mur
    currentItemAction = { playerId, type: 'tetrimino', active: true, inventoryIndex: idx };
    showInfoMessage(`${t('player')} ${playerId+1}: ${t('select-position')} ${t('tetrimino').toLowerCase()}`, 5000);
    // Highlight des cases possibles
    const allowed = getTetriminoPlacablePositions();
    highlightPositions(allowed, 0xce93d8); // violet p√¢le
  }
  if (icon.item === 'tornado') {
    // Activer mode t√©l√©portation du roi: prochain clic sur une case vide t√©l√©porte le roi
    currentItemAction = { playerId, type: 'tornado', active: true, inventoryIndex: idx };
    showInfoMessage(`${t('player')} ${playerId+1}: ${t('select-position')} ${t('tornado').toLowerCase()}`, 5000);
    // Highlight des cases possibles (cases vides sauf caisses d'objets)
    const allowed = getTornadoTeleportPositions();
    highlightPositions(allowed, 0x81c784); // vert p√¢le
  }
  if (icon.item === 'banana') {
    // Activer mode pose de banane: prochain clic sur une case vide pose la banane
    currentItemAction = { playerId, type: 'banana', active: true, inventoryIndex: idx };
    showInfoMessage(`${t('player')} ${playerId+1}: ${t('select-position')} ${t('banana').toLowerCase()}`, 5000);
    // Highlight des cases possibles (cases vides)
    const allowed = getBananaPlacablePositions();
    highlightPositions(allowed, 0xffd54f); // jaune p√¢le
  }
  if (icon.item === 'phoenix') {
    // Utiliser la queue de phoenix pour ressusciter la derni√®re pi√®ce perdue
    if (tryResurrectLastPiece(playerId)) {
      // Consommer l'item
      if (playerItemIcons[playerId] && playerItemIcons[playerId].length) {
        const used = playerItemIcons[playerId].splice(idx, 1)[0];
        if (used && used.sprite) used.sprite.destroy();
      }
      updatePieces();
    } else {
      // Aucune pi√®ce √† ressusciter
      showInfoMessage(`${t('player')} ${playerId+1}: ${t('phoenix-desc')}`, 2000);
    }
  }
  if (icon.item === 'cursor') {
    // Activer mode possession: prochain clic sur une pi√®ce faible/moyenne adverse la poss√®de
    currentItemAction = { playerId, type: 'cursor', active: true, inventoryIndex: idx };
    showInfoMessage(`${t('player')} ${playerId+1}: ${t('select-target')} ${t('cursor').toLowerCase()}`, 5000);
    // Highlight des pi√®ces possibles (faibles et moyennes adverses) en vert p√¢le
    const allowed = getPossessablePieces(playerId);
    highlightPieces(allowed, 0x81c784); // vert p√¢le
  }
  if (icon.item === 'heart') {
    // Activer mode don de c≈ìur: prochain clic sur une pi√®ce lui donne un c≈ìur
    currentItemAction = { playerId, type: 'heart', active: true, inventoryIndex: idx };
    showInfoMessage(`${t('player')} ${playerId+1}: ${t('select-target')} ${t('heart').toLowerCase()}`, 5000);
    // Highlight de toutes les pi√®ces (alli√©es et adverses)
    highlightPieces(pieces, 0xffb3ba); // rose p√¢le
  }
  if (icon.item === 'sandglass') {
    // Utiliser la sabli√®re du temps: r√©duire le temps des adversaires selon la taille du plateau
    if (timerEnabled && playerTimersMs.length > 0) {
      // Calculer le temps √† soustraire selon la taille du plateau
      let timeToSubtract;
      let timeText;
      if (GRID_SIZE === 9) {
        timeToSubtract = 60000; // 1 minute
        timeText = "1 minute";
      } else if (GRID_SIZE === 11) {
        timeToSubtract = 120000; // 2 minutes
        timeText = "2 minutes";
      } else if (GRID_SIZE === 15) {
        timeToSubtract = 180000; // 3 minutes
        timeText = "3 minutes";
      } else {
        timeToSubtract = 60000; // fallback: 1 minute
        timeText = "1 minute";
      }
      
      let affectedPlayers = 0;
      for (let i = 0; i < playerTimersMs.length; i++) {
        if (i !== playerId) {
          // R√©duire le temps de l'adversaire selon la taille du plateau
          playerTimersMs[i] = Math.max(0, playerTimersMs[i] - timeToSubtract);
          affectedPlayers++;
        }
      }
      const plural = affectedPlayers > 1 ? 's' : '';
      showInfoMessage(`Sabli√®re du Temps ! -${timeText} pour ${affectedPlayers} adversaire${plural}`, 3000);
      // Consommer l'item
      if (playerItemIcons[playerId] && playerItemIcons[playerId].length) {
        const used = playerItemIcons[playerId].splice(idx, 1)[0];
        if (used && used.sprite) used.sprite.destroy();
      }
      updatePieces();
    } else {
      showInfoMessage(`${t('player')} ${playerId+1}: ${t('timer')} ${t('not-activated')}`, 2000);
    }
  }
  if (icon.item === 'mask') {
    // Activer mode masque de Majora: prochain clic sur une pi√®ce adverse la force
    currentItemAction = { playerId, type: 'mask', active: true, inventoryIndex: idx };
    showInfoMessage(`${t('player')} ${playerId+1}: ${t('select-target')} ${t('mask').toLowerCase()}`, 5000);
    // Highlight des pi√®ces adverses possibles
    const allowed = pieces.filter(p => p.player !== playerId);
    highlightPieces(allowed, 0xff9800); // orange
  }
  if (icon.item === 'ocarina') {
    // Activer mode ocarina: prochain clic sur une pi√®ce la transforme en cavalier
    currentItemAction = { playerId, type: 'ocarina', active: true, inventoryIndex: idx };
    showInfoMessage(`${t('player')} ${playerId+1}: ${t('select-target')} ${t('ocarina').toLowerCase()}`, 5000);
    // Highlight de toutes les pi√®ces (alli√©es et adverses)
    highlightPieces(pieces, 0x9c27b0); // violet
  }
}

function getBananaPlacablePositions() {
  const positions = [];
  // V√©rifier toutes les cases vides
  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      // V√©rifier si la banane peut √™tre plac√©e √† cette position
      if (canPlaceBananaAt(x, y)) {
        positions.push({ x, y });
      }
    }
  }
  return positions;
}

function canPlaceBananaAt(x, y) {
  // V√©rifier que la case est dans la grille
  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de pi√®ce sur cette case
  if (getPieceAt({ x, y })) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de caisse d'objet sur cette case
  if (itemCrates.some(c => c.x === x && c.y === y)) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de tetrimino sur cette case
  if (tetriminos.some(t => t.x === x && t.y === y)) {
    return false;
  }
  // V√©rifier qu'il n'y a pas d√©j√† une banane sur cette case
  if (bananas.some(b => b.x === x && b.y === y)) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de portail sur cette case
  if ((portalOrange && portalOrange.x === x && portalOrange.y === y) ||
      (portalBlue && portalBlue.x === x && portalBlue.y === y)) {
    return false;
  }
  return true;
}

function placeBanana(pos) {
  const scene = infoText.scene;
  const sprite = scene.add.image(
    GRID_OFFSET_X + pos.x * TILE_SIZE + TILE_SIZE/2,
    GRID_OFFSET_Y + pos.y * TILE_SIZE + TILE_SIZE/2,
    'banana'
  );
  sprite.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
  sprite.setDepth(150); // au-dessus des cases mais sous les pi√®ces
  bananas.push({ x: pos.x, y: pos.y, sprite });
}

function checkBananaTrip(piece, destination) {
  // V√©rifier si la pi√®ce traverse une banane sur son chemin
  const path = getPathBetween(piece.x, piece.y, destination.x, destination.y);
  
  for (const pos of path) {
    const banana = bananas.find(b => b.x === pos.x && b.y === pos.y);
    if (banana) {
      // 33% de chance de tr√©bucher
      if (Math.random() < 0.33) {
        // La pi√®ce tr√©buche, la d√©placer sur la case de la banane
        piece.x = banana.x;
        piece.y = banana.y;
        // Supprimer la banane
        if (banana.sprite) banana.sprite.destroy();
        const index = bananas.indexOf(banana);
        if (index > -1) bananas.splice(index, 1);
        return true; // tr√©buch√©
      }
    }
  }
  return false; // pas tr√©buch√©
}

function getPathBetween(x1, y1, x2, y2) {
  const path = [];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const steps = Math.max(Math.abs(dx), Math.abs(dy));
  
  if (steps === 0) return path;
  
  for (let i = 1; i <= steps; i++) {
    const x = x1 + Math.round((dx * i) / steps);
    const y = y1 + Math.round((dy * i) / steps);
    path.push({ x, y });
  }
  
  return path;
}

function tryResurrectLastPiece(playerId) {
  // Trouver la derni√®re pi√®ce perdue par ce joueur
  const playerLostPiecesList = playerLostPieces.filter(lp => lp.playerId === playerId);
  if (playerLostPiecesList.length === 0) {
    return false; // Aucune pi√®ce perdue
  }
  
  // Prendre la derni√®re pi√®ce perdue (la plus r√©cente)
  const lastLostPiece = playerLostPiecesList[playerLostPiecesList.length - 1];
  
  // Trouver une case libre pr√®s du roi
  const king = pieces.find(p => p.player === playerId && p.type === 'king');
  if (!king) {
    return false; // Pas de roi trouv√©
  }
  
  const resurrectionPos = findNearestEmptyPosition(king.x, king.y);
  if (!resurrectionPos) {
    return false; // Aucune case libre trouv√©e
  }
  
  // Ressusciter la pi√®ce
  const resurrectedPiece = {
    ...lastLostPiece.piece,
    x: resurrectionPos.x,
    y: resurrectionPos.y,
    player: playerId,
    name: lastLostPiece.piece.name || lastLostPiece.piece.type
  };
  
  // Cr√©er le sprite pour la pi√®ce ressuscit√©e
  const scene = infoText.scene;
  const faction = players[playerId].faction;
  let spriteKey;
  
  if (resurrectedPiece.type === 'king') {
    spriteKey = `king-${faction}`;
  } else {
    // Utiliser le nom de la pi√®ce tel qu'il est d√©fini dans le catalogue
    spriteKey = resurrectedPiece.type;
  }
  
  const sprite = scene.add.image(
    GRID_OFFSET_X + resurrectedPiece.x * TILE_SIZE + TILE_SIZE/2,
    GRID_OFFSET_Y + resurrectedPiece.y * TILE_SIZE + TILE_SIZE/2,
    spriteKey
  );
  sprite.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
  sprite.setDepth(200);
  sprite.setInteractive();
  sprite.on('pointerdown', () => handleClick(scene, { x: resurrectedPiece.x, y: resurrectedPiece.y }));
  
  // Ajouter le sprite √† la pi√®ce
  resurrectedPiece.sprite = sprite;
  
  // Ajouter la pi√®ce au tableau des pi√®ces
  pieces.push(resurrectedPiece);
  
  // Supprimer la pi√®ce de la liste des pi√®ces perdues
  const index = playerLostPieces.findIndex(lp => lp === lastLostPiece);
  if (index > -1) {
    playerLostPieces.splice(index, 1);
  }
  
  if (infoText) infoText.setText(`Joueur ${playerId+1}: ${resurrectedPiece.name} ressuscit√©e !`);
  setTimeout(() => {
    if (infoText) infoText.setText("");
  }, 2000);
  
  return true;
}

function findNearestEmptyPosition(kingX, kingY) {
  // Chercher dans un rayon croissant autour du roi
  for (let radius = 1; radius <= 3; radius++) {
    for (let dx = -radius; dx <= radius; dx++) {
      for (let dy = -radius; dy <= radius; dy++) {
        // Ignorer les cases en dehors du rayon actuel
        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
        
        const x = kingX + dx;
        const y = kingY + dy;
        
        // V√©rifier que la position est dans la grille
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
        
        // V√©rifier que la case est libre
        if (isPositionEmpty(x, y)) {
          return { x, y };
        }
      }
    }
  }
  return null; // Aucune case libre trouv√©e
}

function isPositionEmpty(x, y) {
  // V√©rifier qu'il n'y a pas de pi√®ce sur cette case
  if (getPieceAt({ x, y })) return false;
  
  // V√©rifier qu'il n'y a pas de caisse d'objet sur cette case
  if (itemCrates.some(c => c.x === x && c.y === y)) return false;
  
  // V√©rifier qu'il n'y a pas de tetrimino sur cette case
  if (tetriminos.some(t => t.x === x && t.y === y)) return false;
  
  // V√©rifier qu'il n'y a pas de banane sur cette case
  if (bananas.some(b => b.x === x && b.y === y)) return false;
  
  // V√©rifier qu'il n'y a pas de portail sur cette case
  if ((portalOrange && portalOrange.x === x && portalOrange.y === y) ||
      (portalBlue && portalBlue.x === x && portalBlue.y === y)) {
    return false;
  }
  
  return true;
}

function getPossessablePieces(playerId) {
  const possessablePieces = [];
  for (const piece of pieces || []) {
    if (canPossessPiece(piece, playerId)) {
      possessablePieces.push(piece);
    }
  }
  return possessablePieces;
}

function canPossessPiece(piece, playerId) {
  // Ne peut pas poss√©der ses propres pi√®ces
  if (piece.player === playerId) return false;
  
  // Ne peut pas poss√©der les rois
  if (piece.type === 'king') return false;
  
  // V√©rifier le tier de la pi√®ce (faible ou moyen)
  const faction = players[piece.player] && players[piece.player].faction ? players[piece.player].faction : 'nintendo';
  const catalog = getCatalogForFaction(faction);
  
  // Essayer d'abord avec piece.type, puis avec piece.name si piece.type ne fonctionne pas
  let pieceData = catalog[piece.type];
  if (!pieceData && piece.name) {
    pieceData = catalog[piece.name];
  }
  
  if (!pieceData) return false;
  
  // Seulement les pi√®ces de tier 1 (faible) ou 2 (moyen)
  return pieceData.tier === 1 || pieceData.tier === 2;
}

function possessPiece(piece, playerId) {
  const scene = infoText.scene;
  const originalPlayer = piece.player;
  
  // NE PAS changer le propri√©taire de la pi√®ce - elle reste contr√¥l√©e par son joueur d'origine
  
  // D√©placer la pi√®ce pr√®s du roi du joueur d'ORIGINE
  const originalKing = pieces.find(p => p.player === originalPlayer && p.type === 'king');
  if (originalKing) {
    const newPos = findPositionNearKing(originalKing.x, originalKing.y);
    if (newPos) {
      piece.x = newPos.x;
      piece.y = newPos.y;
      if (piece.sprite) {
        piece.sprite.x = GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2;
        piece.sprite.y = GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2;
      }
    }
  }
  
  // Cr√©er le curseur au-dessus de la pi√®ce
  const cursorSprite = scene.add.image(
    GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2 + 15,
    GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2 - 20,
    'cursor'
  );
  cursorSprite.setDisplaySize(20, 20);
  cursorSprite.setDepth(1500); // Au-dessus des pi√®ces
  cursorSprite.setVisible(true);
  
  // Calculer les limites de la "maison" bas√©e sur le joueur d'origine
  const houseBounds = calculateHouseBounds(originalPlayer);
  
  // Enregistrer la possession
  possessedPieces.push({
    piece: piece,
    cursorSprite: cursorSprite,
    originalPlayer: originalPlayer,
    possessorPlayer: playerId,
    houseBounds: houseBounds
  });
  
  if (infoText) infoText.setText(`Joueur ${playerId+1}: ${piece.type} poss√©d√©e !`);
  setTimeout(() => {
    if (infoText) infoText.setText("");
  }, 2000);
}

function findPositionNearKing(kingX, kingY) {
  // Chercher une case libre pr√®s du roi
  for (let radius = 1; radius <= 2; radius++) {
    for (let dx = -radius; dx <= radius; dx++) {
      for (let dy = -radius; dy <= radius; dy++) {
        if (dx === 0 && dy === 0) continue;
        
        const x = kingX + dx;
        const y = kingY + dy;
        
        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && isPositionEmpty(x, y)) {
          return { x, y };
        }
      }
    }
  }
  return null;
}

function calculateHouseBounds(originalPlayer) {
  // Zones fixes selon la taille du plateau et le joueur
  if (GRID_SIZE === 9) {
    switch(originalPlayer) {
      case 0: return { startX: 2, endX: 6, startY: 0, endY: 2 }; // J1: [1,3] √† [3,7]
      case 1: return { startX: 2, endX: 6, startY: 6, endY: 8 }; // J2: [9,3] √† [7,7]
      case 2: return { startX: 0, endX: 3, startY: 2, endY: 6 }; // J3: [3,1] √† [7,4]
      case 3: return { startX: 6, endX: 8, startY: 2, endY: 6 }; // J4: [3,9] √† [7,7]
      default: return { startX: 0, endX: 0, startY: 0, endY: 0 };
    }
  } else if (GRID_SIZE === 11) {
    switch(originalPlayer) {
      case 0: return { startX: 2, endX: 8, startY: 0, endY: 3 }; // J1: [1,3] √† [4,9]
      case 1: return { startX: 2, endX: 8, startY: 7, endY: 10 }; // J2: [11,3] √† [9,9]
      case 2: return { startX: 0, endX: 3, startY: 2, endY: 8 }; // J3: [3,1] √† [9,4]
      case 3: return { startX: 7, endX: 10, startY: 2, endY: 8 }; // J4: [3,11] √† [9,9]
      default: return { startX: 0, endX: 0, startY: 0, endY: 0 };
    }
  } else { // 15x15
    switch(originalPlayer) {
      case 0: return { startX: 4, endX: 10, startY: 0, endY: 3 }; // J1: [1,5] √† [4,11]
      case 1: return { startX: 4, endX: 10, startY: 11, endY: 14 }; // J2: [15,5] √† [12,11]
      case 2: return { startX: 0, endX: 3, startY: 4, endY: 10 }; // J3: [5,1] √† [11,4]
      case 3: return { startX: 11, endX: 14, startY: 4, endY: 10 }; // J4: [5,15] √† [11,12]
      default: return { startX: 0, endX: 0, startY: 0, endY: 0 };
    }
  }
}

function isWithinHouseBounds(x, y, houseBounds) {
  return x >= houseBounds.startX && x <= houseBounds.endX && 
         y >= houseBounds.startY && y <= houseBounds.endY;
}

function cleanupCursorForPiece(piece) {
  // Nettoyer l'exposant du curseur Sims si la pi√®ce √©tait poss√©d√©e
  const possessedIndex = possessedPieces.findIndex(pp => pp.piece === piece);
  if (possessedIndex >= 0) {
    const possessed = possessedPieces[possessedIndex];
    if (possessed.cursorSprite && possessed.cursorSprite.destroy) {
      possessed.cursorSprite.destroy();
    }
    possessedPieces.splice(possessedIndex, 1);
  }
}

function highlightPieces(pieces, color) {
  clearHighlights();
  for (const piece of pieces) {
    if (piece && piece.sprite) {
      const highlight = piece.sprite.scene.add.rectangle(
        GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2,
        GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2,
        TILE_SIZE,
        TILE_SIZE,
        color
      ).setAlpha(0.3).setDepth(100);
      highlightOverlays.push(highlight);
    }
  }
}

function giveHeartToPiece(piece) {
  // V√©rifier si la pi√®ce a d√©j√† un c≈ìur
  if (heartPieces.some(hp => hp.piece === piece)) {
    if (infoText) infoText.setText("Cette pi√®ce a d√©j√† un c≈ìur !");
    return;
  }
  
  // Cr√©er le sprite du c≈ìur
  const scene = infoText.scene;
  const heartSprite = scene.add.image(
    GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2 + 15,
    GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2 - 15,
    'heart'
  );
  heartSprite.setDisplaySize(16, 16);
  heartSprite.setDepth(1500);
  heartSprite.setVisible(true);
  
  // Ajouter √† la liste des pi√®ces avec c≈ìur
  heartPieces.push({ piece: piece, heartSprite: heartSprite });
  
  if (infoText) infoText.setText(`C≈ìur donn√© √† la pi√®ce !`);
}

function removeHeartFromPiece(piece) {
  // Trouver et supprimer le c≈ìur de la pi√®ce
  const heartIndex = heartPieces.findIndex(hp => hp.piece === piece);
  if (heartIndex >= 0) {
    const heart = heartPieces[heartIndex];
    if (heart.heartSprite && heart.heartSprite.destroy) {
      heart.heartSprite.destroy();
    }
    heartPieces.splice(heartIndex, 1);
  }
}

function removeOcarinaFromPiece(piece) {
  // Trouver et supprimer l'ocarina de la pi√®ce
  const ocarinaIndex = knightPieces.findIndex(kp => kp.piece === piece);
  if (ocarinaIndex >= 0) {
    const knight = knightPieces[ocarinaIndex];
    if (knight.ocarinaSprite && knight.ocarinaSprite.destroy) {
      knight.ocarinaSprite.destroy();
    }
    knightPieces.splice(ocarinaIndex, 1);
  }
}

function updateHeartPositions() {
  // Mettre √† jour la position des c≈ìurs pour qu'ils suivent leurs pi√®ces
  for (const hp of heartPieces) {
    if (hp.heartSprite && hp.piece) {
      hp.heartSprite.x = GRID_OFFSET_X + hp.piece.x * TILE_SIZE + TILE_SIZE/2 + 15;
      hp.heartSprite.y = GRID_OFFSET_Y + hp.piece.y * TILE_SIZE + TILE_SIZE/2 - 15;
    }
  }
}

function updateMaskPosition() {
  // Mettre √† jour la position du masque de Majora
  if (forcedPiece && forcedPiece.maskSprite && forcedPiece.piece) {
    forcedPiece.maskSprite.x = GRID_OFFSET_X + forcedPiece.piece.x * TILE_SIZE + TILE_SIZE/2;
    forcedPiece.maskSprite.y = GRID_OFFSET_Y + forcedPiece.piece.y * TILE_SIZE + TILE_SIZE/2 - 25;
  }
}

function updateOcarinaPositions() {
  // Mettre √† jour les positions des ocarinas
  for (const kp of knightPieces) {
    if (kp.ocarinaSprite && kp.piece) {
      kp.ocarinaSprite.x = GRID_OFFSET_X + kp.piece.x * TILE_SIZE + TILE_SIZE/2;
      kp.ocarinaSprite.y = GRID_OFFSET_Y + kp.piece.y * TILE_SIZE + TILE_SIZE/2 - 25;
    }
  }
}

function applyMaskToPiece(piece) {
  // Nettoyer l'ancien masque s'il existe
  if (forcedPiece && forcedPiece.maskSprite) {
    forcedPiece.maskSprite.destroy();
  }
  
  // Cr√©er le sprite du masque
  const scene = infoText.scene;
  const maskSprite = scene.add.image(0, 0, 'mask');
  maskSprite.setDisplaySize(20, 20);
  maskSprite.setDepth(1500);
  
  // Positionner le masque au-dessus de la pi√®ce
  maskSprite.x = GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2;
  maskSprite.y = GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2 - 25;
  
  // Stocker l'information du masque
  forcedPiece = {
    piece: piece,
    playerId: piece.player,
    maskSprite: maskSprite
  };
  
  showInfoMessage(`Masque de Majora ! Le joueur ${piece.player + 1} devra jouer cette pi√®ce !`, 3000);
}

function applyOcarinaToPiece(piece) {
  // V√©rifier si la pi√®ce n'est pas d√©j√† un cavalier
  const existingKnight = knightPieces.find(kp => kp.piece === piece);
  if (existingKnight) {
    showInfoMessage(`Cette pi√®ce est d√©j√† transform√©e en cavalier !`, 2000);
    return;
  }
  
  // Cr√©er le sprite de l'ocarina
  const scene = infoText.scene;
  const ocarinaSprite = scene.add.image(0, 0, 'ocarina');
  ocarinaSprite.setDisplaySize(18, 18);
  ocarinaSprite.setDepth(1500);
  
  // Positionner l'ocarina au-dessus de la pi√®ce
  ocarinaSprite.x = GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2;
  ocarinaSprite.y = GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2 - 25;
  
  // Stocker l'information du cavalier
  knightPieces.push({
    piece: piece,
    ocarinaSprite: ocarinaSprite
  });
  
  // Jouer le son de l'Ocarina
  scene.sound.play('ocarina');
  
  showInfoMessage(`Ocarina du Temps ! Cette pi√®ce devient un cavalier !`, 3000);
}

function getSimpleReachablePositions(piece) {
  if (!piece) return [];
  
  // V√©rifier si la pi√®ce est transform√©e en cavalier par l'Ocarina
  const isKnight = knightPieces.some(kp => kp.piece === piece);
  
  if (isKnight) {
    return getKnightMoves(piece);
  } else {
    // Utiliser la logique de mouvement originale du jeu
    // Pour l'instant, on retourne un mouvement simple en attendant d'identifier la vraie logique
    return getOriginalMoves(piece);
  }
}

function getKnightMoves(piece) {
  const moves = [];
  const knightOffsets = [
    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
    [1, -2], [1, 2], [2, -1], [2, 1]
  ];
  
  // Fonction pour v√©rifier si une position contient un tetrimino
  const isTetriminoPos = (x, y) => {
    return tetriminos.some(t => t.x === x && t.y === y);
  };
  
  for (const [dx, dy] of knightOffsets) {
    const newX = piece.x + dx;
    const newY = piece.y + dy;
    
    // V√©rifier que la position est dans la grille
    if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) continue;
    
    // V√©rifier si la case de destination contient un tetrimino
    // Les cavaliers peuvent sauter par-dessus les tetriminos mais ne peuvent pas atterrir dessus
    if (isTetriminoPos(newX, newY)) continue;
    
    // V√©rifier s'il y a une pi√®ce sur cette case
    const targetPiece = getPieceAt({x: newX, y: newY});
    
    if (!targetPiece) {
      // Case vide - mouvement valide
      moves.push({x: newX, y: newY});
    } else if (targetPiece.player !== piece.player) {
      // Pi√®ce ennemie - capture possible
      moves.push({x: newX, y: newY});
    }
    // Si c'est une pi√®ce alli√©e, on ne peut pas aller sur cette case
  }
  
  return moves;
}

function getOriginalMoves(piece) {
  const moves = [];
  
  // Obtenir les donn√©es de mouvement de la pi√®ce
  const pieceData = getPieceMovementData(piece);
  if (!pieceData) {
    // Fallback : mouvement de roi si pas de donn√©es
    return getBasicKingMoves(piece);
  }
  
  const { moves: moveDirections, range } = pieceData;
  
  // Fonction pour v√©rifier si une position contient un tetrimino
  const isTetriminoPos = (x, y) => {
    return tetriminos.some(t => t.x === x && t.y === y);
  };
  
  // Appliquer chaque direction de mouvement
  for (const [dx, dy] of moveDirections) {
    // Parcourir dans cette direction jusqu'√† la port√©e maximale
    for (let distance = 1; distance <= range; distance++) {
      const newX = piece.x + dx * distance;
      const newY = piece.y + dy * distance;
      
      // V√©rifier limites de grille
      if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) break;
      
      // V√©rifier si la case contient un tetrimino (mur)
      if (isTetriminoPos(newX, newY)) {
        // Les cavaliers peuvent sauter par-dessus les tetriminos
        const isKnightMove = (range === 1 && distance === 1 && 
          (Math.abs(dx) === 2 && Math.abs(dy) === 1) || 
          (Math.abs(dx) === 1 && Math.abs(dy) === 2));
        
        if (isKnightMove) {
          continue; // continuer le mouvement (sauter par-dessus)
        } else {
          break; // s'arr√™ter pour les autres pi√®ces
        }
      }
      
      const targetPiece = getPieceAt({x: newX, y: newY});
      
      if (!targetPiece) {
        // Case vide - mouvement valide
        moves.push({x: newX, y: newY});
      } else if (targetPiece.player !== piece.player) {
        // Pi√®ce ennemie - capture possible puis arr√™t
        moves.push({x: newX, y: newY});
        break;
      } else {
        // Pi√®ce alli√©e - arr√™t
        break;
      }
    }
  }
  
  return moves;
}

function getPieceMovementData(piece) {
  // Obtenir la faction du joueur
  const player = players[piece.player];
  const faction = player ? player.faction : 'nintendo';
  
  if (piece.type === 'king') {
    // Donn√©es du roi pour cette faction
    return kings[faction];
  } else {
    // Utiliser les donn√©es de mouvement stock√©es dans la pi√®ce
    if (piece.moves && piece.range) {
      return {
        moves: piece.moves,
        range: piece.range
      };
    }
    
    // Fallback : chercher dans le catalogue par nom
    const catalog = factionCatalogs[faction];
    if (catalog && piece.name) {
      // Chercher par nom de pi√®ce
      const pieceKey = Object.keys(catalog).find(key => 
        piece.name.toLowerCase().includes(key.toLowerCase())
      );
      return pieceKey ? catalog[pieceKey] : null;
    }
    
    return null;
  }
}

function getBasicKingMoves(piece) {
  // Mouvement de base du roi en cas de fallback
  const moves = [];
  const directions = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],           [0, 1],
    [1, -1],  [1, 0],  [1, 1]
  ];
  
  for (const [dx, dy] of directions) {
    const newX = piece.x + dx;
    const newY = piece.y + dy;
    if (isValidMove(piece, newX, newY)) {
      moves.push({x: newX, y: newY});
    }
  }
  
  return moves;
}

function isValidMove(piece, x, y) {
  // V√©rifier que la position est dans la grille
  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return false;
  
  // V√©rifier si la case contient un tetrimino (mur)
  const isTetriminoPos = tetriminos.some(t => t.x === x && t.y === y);
  if (isTetriminoPos) return false; // Aucune pi√®ce ne peut atterrir sur un tetrimino
  
  // V√©rifier s'il y a une pi√®ce sur cette case
  const targetPiece = getPieceAt({x, y});
  
  if (!targetPiece) {
    // Case vide - mouvement valide
    return true;
  } else if (targetPiece.player !== piece.player) {
    // Pi√®ce ennemie - capture possible
    return true;
  }
  
  // Pi√®ce alli√©e - mouvement invalide
  return false;
}

function isPiecePossessedByCurrentPlayer(piece) {
  const possessed = possessedPieces.find(pp => pp.piece === piece);
  return possessed && possessed.possessorPlayer === currentPlayer;
}

function getTornadoTeleportPositions() {
  const positions = [];
  // V√©rifier toutes les cases vides (sauf caisses d'objets)
  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      // V√©rifier si la case est vide et peut recevoir le roi
      if (canTeleportKingTo(x, y)) {
        positions.push({ x, y });
      }
    }
  }
  return positions;
}

function canTeleportKingTo(x, y) {
  // V√©rifier que la case est dans la grille
  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de pi√®ce sur cette case
  if (getPieceAt({ x, y })) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de caisse d'objet sur cette case
  if (itemCrates.some(c => c.x === x && c.y === y)) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de tetrimino sur cette case
  if (tetriminos.some(t => t.x === x && t.y === y)) {
    return false;
  }
  return true;
}

function teleportKingTo(playerId, newPos) {
  // Trouver le roi du joueur
  const king = pieces.find(p => p.player === playerId && p.type === 'king');
  if (!king) return;
  
  // Mettre √† jour la position du roi
  king.x = newPos.x;
  king.y = newPos.y;
  
  // Mettre √† jour la position visuelle du sprite
  if (king.sprite) {
    king.sprite.x = GRID_OFFSET_X + newPos.x * TILE_SIZE + TILE_SIZE/2;
    king.sprite.y = GRID_OFFSET_Y + newPos.y * TILE_SIZE + TILE_SIZE/2;
  }
}

function getTetriminoPlacablePositions() {
  const positions = [];
  // V√©rifier toutes les positions possibles pour le tetrimino (forme T invers√©)
  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      // V√©rifier si le tetrimino peut √™tre plac√© √† cette position
      if (canPlaceTetriminoAt(x, y)) {
        positions.push({ x, y });
      }
    }
  }
  return positions;
}

function canPlaceTetriminoAt(centerX, centerY) {
  // Forme T invers√© : 3 cases horizontales + 1 case en dessous du milieu
  const positions = [
    { x: centerX - 1, y: centerY },     // gauche
    { x: centerX, y: centerY },         // centre
    { x: centerX + 1, y: centerY },     // droite
    { x: centerX, y: centerY + 1 }      // en dessous du centre
  ];
  
  // V√©rifier que toutes les positions sont dans la grille
  for (const pos of positions) {
    if (pos.x < 0 || pos.x >= GRID_SIZE || pos.y < 0 || pos.y >= GRID_SIZE) {
      return false;
    }
    // V√©rifier qu'il n'y a pas de pi√®ce sur cette case
    if (getPieceAt(pos)) {
      return false;
    }
    // V√©rifier qu'il n'y a pas d√©j√† un tetrimino sur cette case
    if (tetriminos.some(t => t.x === pos.x && t.y === pos.y)) {
      return false;
    }
    // V√©rifier qu'il n'y a pas de caisse d'objet sur cette case
    if (itemCrates.some(c => c.x === pos.x && c.y === pos.y)) {
      return false;
    }
    // V√©rifier qu'il n'y a pas de portail sur cette case
    if ((portalOrange && portalOrange.x === pos.x && portalOrange.y === pos.y) ||
        (portalBlue && portalBlue.x === pos.x && portalBlue.y === pos.y)) {
      return false;
    }
  }
  return true;
}

function placeTetrimino(centerPos) {
  const scene = infoText.scene;
  const positions = [
    { x: centerPos.x - 1, y: centerPos.y },     // gauche
    { x: centerPos.x, y: centerPos.y },         // centre
    { x: centerPos.x + 1, y: centerPos.y },     // droite
    { x: centerPos.x, y: centerPos.y + 1 }      // en dessous du centre
  ];
  
  // Cr√©er des rectangles violets pour chaque case du tetrimino
  for (const pos of positions) {
    const rect = scene.add.rectangle(
      GRID_OFFSET_X + pos.x * TILE_SIZE + TILE_SIZE/2,
      GRID_OFFSET_Y + pos.y * TILE_SIZE + TILE_SIZE/2,
      TILE_SIZE-2,
      TILE_SIZE-2,
      0x9c27b0 // violet
    );
    rect.setDepth(100); // au-dessus des cases mais sous les pi√®ces
    tetriminos.push({ x: pos.x, y: pos.y, sprite: rect });
  }
}

function getBombPlacablePositions(playerId) {
  const positions = [];
  // toutes cases √† distance de Manhattan <= 2 d'au moins une pi√®ce du joueur
  const myPieces = pieces.filter(p => p.player === playerId);
  const seen = new Set();
  for (let mp of myPieces) {
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = -2; dy <= 2; dy++) {
        const x = mp.x + dx;
        const y = mp.y + dy;
        if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) continue;
        const manhattan = Math.abs(dx) + Math.abs(dy);
        if (manhattan <= 2) {
          const key = x+","+y;
          if (!seen.has(key)) { positions.push({ x, y }); seen.add(key); }
        }
      }
    }
  }
  return positions;
}

function canPlaceBombAt(pos, playerId) {
  const allowed = getBombPlacablePositions(playerId);
  return allowed.some(p => p.x === pos.x && p.y === pos.y);
}

function getAllEmptyCells() {
  const cells = [];
  for (let y=0; y<GRID_SIZE; y++) {
    for (let x=0; x<GRID_SIZE; x++) {
      if (!getPieceAt({x,y})) cells.push({x,y});
    }
  }
  return cells;
}

function detonateBombAt(pos) {
  // Effets visuels et sonores
  const scene = infoText.scene;
  try { scene.sound.play('bobomb', { volume: 0.6 }); } catch(e) {}
  // flash rouge sur la zone
  const centerX = GRID_OFFSET_X + pos.x*TILE_SIZE + TILE_SIZE/2;
  const centerY = GRID_OFFSET_Y + pos.y*TILE_SIZE + TILE_SIZE/2;
  const flash = scene.add.rectangle(centerX, centerY, TILE_SIZE*3, TILE_SIZE*3, 0xff5252).setAlpha(0.4).setDepth(3000);
  scene.tweens.add({ targets: flash, alpha: 0, duration: 220, onComplete: () => flash.destroy() });
  // onde circulaire
  const ring = scene.add.circle(centerX, centerY, 6, 0xff1744).setAlpha(0.7).setDepth(3001);
  scene.tweens.add({ targets: ring, radius: TILE_SIZE*1.2, alpha: 0, duration: 300, onComplete: () => ring.destroy() });

  // D√©truire pi√®ces sur la case et les 8 adjacentes (zone 3x3)
  const deltas = [];
  for (let dx=-1; dx<=1; dx++) {
    for (let dy=-1; dy<=1; dy++) {
      deltas.push({x:dx,y:dy});
    }
  }
  for (let d of deltas) {
    const tx = pos.x + d.x;
    const ty = pos.y + d.y;
    if (tx < 0 || ty < 0 || tx >= GRID_SIZE || ty >= GRID_SIZE) continue;
    const victim = getPieceAt({ x: tx, y: ty });
    if (victim) {
      // V√©rifier si la pi√®ce est prot√©g√©e par l'√©toile
      if (starInvincible && starInvincible.playerId === victim.player && starInvincible.untilPlayerTurn) {
        continue; // Pi√®ce immunis√©e, passer √† la suivante
      }
      const wasKing = victim.type === 'king';
      // Enregistrer la pi√®ce perdue pour la queue de phoenix
      playerLostPieces.push({ playerId: victim.player, piece: { ...victim } });
      // Nettoyer l'exposant du curseur Sims si la pi√®ce √©tait poss√©d√©e
      cleanupCursorForPiece(victim);
      // Nettoyer l'ocarina si la pi√®ce en avait un
      removeOcarinaFromPiece(victim);
      victim.sprite.destroy();
      if (victim.backgroundSprite) victim.backgroundSprite.destroy();
      pieces = pieces.filter(p => !(p.x === tx && p.y === ty && p.player === victim.player && p.type === victim.type));
      if (wasKing) {
        if (!eliminationOrder.includes(victim.player)) eliminationOrder.push(victim.player);
      }
    }
  }
  // L'item bombe est d√©j√† consomm√© dans handleClick, pas besoin de le refaire ici
  updatePieces();
  // V√©rifier condition de fin
  const remainingKings = pieces.filter(pp => pp.type === 'king').length;
  if (infoText) infoText.setText("");
  if (remainingKings <= 1) {
    let winnerId = null;
    const kingPiece = pieces.find(pp => pp.type === 'king');
    if (kingPiece) winnerId = kingPiece.player;
    let ranking = [];
    if (winnerId !== null) ranking.push(winnerId);
    const rest = eliminationOrder.slice().reverse();
    for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
    endGameWithRanking(ranking);
  }
}

function maybeRespawnCrate(scene) {
  if (!itemCrates || !itemCrates.length) return;
  // R√©appara√Æt tous les 3 tours depuis la derni√®re interaction de chaque caisse
  for (const c of itemCrates) {
    if (c.active) continue;
    if ((roundCounter - c.lastRound) >= 3) {
      c.active = true;
      if (!c.sprite) {
        c.sprite = scene.add.image(0,0,'item-crate');
        c.sprite.setDisplaySize(TILE_SIZE*0.6, TILE_SIZE*0.6);
      }
      c.sprite.setAlpha(1);
      // pas besoin de recaler x/y ici, updatePieces() le fera
    }
  }
  updatePieces();
}

function rollRandomItem() {
  // Tirage pond√©r√© selon ITEM_WEIGHTS
  const entries = Object.entries(ITEM_WEIGHTS);
  const total = entries.reduce((s, [,w]) => s + (w||0), 0);
  if (total <= 0) return 'bobomb';
  let r = Math.random() * total;
  for (const [key, weight] of entries) {
    r -= weight;
    if (r <= 0) return key;
  }
  return entries[entries.length-1][0];
}

function clearHighlights() {
  for (let tile of highlightedTiles) {
    tile.setFillStyle(tile.baseColor);
  }
  highlightedTiles = [];
  
  // Nettoyer aussi les overlays de pi√®ces (pour le curseur Sims)
  for (let overlay of highlightOverlays) {
    if (overlay && overlay.destroy) {
      overlay.destroy();
    }
  }
  highlightOverlays = [];
}

function highlightPositions(positions, color = 0xfff59d) {
  clearHighlights();
  for (let pos of positions) {
    const tile = grid[pos.y][pos.x];
    tile.setFillStyle(color);
    highlightedTiles.push(tile);
  }
}

function checkStarEffect() {
  // V√©rifier si l'effet de l'√©toile doit se terminer
  if (starInvincible && starInvincible.playerId >= 0 && starInvincible.untilPlayerTurn && starInvincible.playerId === currentPlayer) {
    // L'√©toile se termine car le joueur qui l'a utilis√©e rejoue
    stopStarBlink(starInvincible.playerId);
    clearStarOverlays();
    try {
      const s = infoText.scene.sound;
      if (s && s.stopByKey) s.stopByKey('star'); else if (s && s.stopAll) s.stopAll();
    } catch(e) {}
    starInvincible = { playerId: -1, untilRound: -1, untilPlayerTurn: false };
  }
}

function updateTurnUI() {
  const mid = getKingCenterIndex(GRID_SIZE);
  
  // V√©rifier si le joueur actuel est √©limin√© et passer au suivant si n√©cessaire
  if (eliminationOrder.includes(currentPlayer)) {
    currentPlayer = getNextActivePlayer();
    // Appeler r√©cursivement pour s'assurer que le nouveau joueur n'est pas √©limin√© non plus
    updateTurnUI();
    return;
  }
  
  // V√©rifier si l'effet de l'√©toile doit se terminer
  checkStarEffect();
  
  // Si le joueur actuel a une pi√®ce forc√©e par le masque de Majora, la s√©lectionner automatiquement
  if (forcedPiece && forcedPiece.playerId === currentPlayer && forcedPiece.piece) {
    selectedPiece = forcedPiece.piece;
    const reachable = getReachablePositions(selectedPiece);
    highlightPositions(reachable);
    showInfoMessage(`Vous √™tes forc√© de jouer cette pi√®ce par le Masque de Majora !`, 5000);
  } else {
    // D√©s√©lectionner toute pi√®ce si pas de contrainte
    selectedPiece = null;
    clearHighlights();
  }
  
  // Mettre en √©vidence le nom du joueur actif (vert et bold)
  playerNameTexts.forEach((text, index) => {
    if (text) {
      if (index === currentPlayer) {
        // Joueur actif : vert et bold
        text.setStyle({ 
          font: "bold 16px Arial", 
          fill: "#27ae60",
          stroke: "#ffffff",
          strokeThickness: 2
        });
      } else {
        // Autres joueurs : style normal
        text.setStyle({ 
          font: "16px Arial", 
          fill: "#333",
          stroke: "#ffffff",
          strokeThickness: 1
        });
      }
    }
  });
  // Mettre √† jour la position des ic√¥nes d'objets √† c√¥t√© des noms
  updatePieces();
}

function decrementLightningCharges() {
  for (let i=0; i<playerItemIcons.length; i++) {
    const arr = playerItemIcons[i] || [];
    for (const e of arr) {
      if (e && e.item === 'lightning' && e.chargeTurns && e.chargeTurns > 0) {
        e.chargeTurns = Math.max(0, e.chargeTurns - 1);
      }
    }
  }
  updatePieces();
}

function triggerLightningEffect() {
  const scene = infoText.scene;
  // flash global
  const flash = scene.add.rectangle(GRID_OFFSET_X + GRID_SIZE*TILE_SIZE/2, GRID_OFFSET_Y + GRID_SIZE*TILE_SIZE/2, GRID_SIZE*TILE_SIZE, GRID_SIZE*TILE_SIZE, 0xffff8d).setAlpha(0.35).setDepth(2900);
  scene.tweens.add({ targets: flash, alpha: 0, duration: 250, onComplete: () => flash.destroy() });
}

function isWhiteSquare(x, y) {
  // m√™me logique que baseColor (x+y)%2===0 blanc
  return ((x + y) % 2) === 0;
}

function applyLightningKill() {
  // Supprimer toutes les pi√®ces sur cases blanches (y compris celles du lanceur)
  const victims = pieces.filter(p => isWhiteSquare(p.x, p.y) && !(starInvincible && starInvincible.playerId === p.player && starInvincible.untilPlayerTurn));
  let kingDied = false;
  for (const v of victims) {
    // Enregistrer la pi√®ce perdue pour la queue de phoenix
    playerLostPieces.push({ playerId: v.player, piece: { ...v } });
    // Nettoyer l'exposant du curseur Sims si la pi√®ce √©tait poss√©d√©e
    cleanupCursorForPiece(v);
    // Nettoyer l'ocarina si la pi√®ce en avait un
    removeOcarinaFromPiece(v);
    if (v && v.sprite) v.sprite.destroy();
    if (v && v.backgroundSprite) v.backgroundSprite.destroy();
    if (v.type === 'king') {
      kingDied = true;
      if (!eliminationOrder.includes(v.player)) eliminationOrder.push(v.player);
    }
  }
  // Conserver les pi√®ces prot√©g√©es par l'√©toile m√™me si elles sont sur case blanche
  pieces = pieces.filter(p => !(isWhiteSquare(p.x, p.y) && !(starInvincible && starInvincible.playerId === p.player && starInvincible.untilPlayerTurn)));
  updatePieces();
  if (kingDied) {
    const remainingKings = pieces.filter(pp => pp.type === 'king').length;
    if (remainingKings <= 1) {
      let winnerId = null;
      const kingPiece = pieces.find(pp => pp.type === 'king');
      if (kingPiece) winnerId = kingPiece.player;
      let ranking = [];
      if (winnerId !== null) ranking.push(winnerId);
      const rest = eliminationOrder.slice().reverse();
      for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
      endGameWithRanking(ranking);
    }
  }
}

function update() {}

function positionTimerTextNearName(timerText, nameText) {
  if (!timerText || !nameText) return;
  // D√©terminer le c√¥t√© du joueur pour positionner le timer
  const playerIndex = playerNameTexts.indexOf(nameText);
  const side = (playerIndex===0)?'top':(playerIndex===1)?'bottom':(playerIndex===2)?'left':'right';
  
  if (side === 'top') {
    // Joueur du haut : timer √† droite du nom, align√© avec les objets
    timerText.x = nameText.x - 20;
    timerText.y = nameText.y - 28;
  } else if (side === 'bottom') {
    // Joueur du bas : timer en dessous du nom, align√© avec les objets
    timerText.x = nameText.x - 20;
    timerText.y = nameText.y + nameText.displayHeight - 5;
  } else if (side === 'left') {
    // Joueur de gauche (J3) : timer plus haut, bien espac√© du nom et du plateau
    timerText.x = nameText.x - 20;
    timerText.y = nameText.y - nameText.displayHeight - 75;
  } else { // right
    // Joueur de droite (J4) : timer plus haut, bien espac√© du nom et du plateau
    timerText.x = nameText.x - 22;
    timerText.y = nameText.y - nameText.displayHeight - 75;
  }
}

function formatMs(ms) {
  const s = Math.max(0, Math.floor(ms/1000));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

function tickTimer(scene) {
  if (!gameStarted || !timerEnabled) return;
  if (players.length === 0) return;
  const nowIdx = currentPlayer;
  playerTimersMs[nowIdx] = Math.max(0, playerTimersMs[nowIdx] - 250);
  // MAJ texte
  if (timerTexts[nowIdx]) timerTexts[nowIdx].setText(formatMs(playerTimersMs[nowIdx]));
  // feedback visuel sous 10s
  const under10 = playerTimersMs[nowIdx] <= 30000;
  if (timerTexts[nowIdx]) {
    if (under10) {
      timerBlinkToggle = !timerBlinkToggle;
      timerTexts[nowIdx].setColor('#b00020');
      timerTexts[nowIdx].setAlpha(timerBlinkToggle ? 1 : 0.4);
    } else {
      timerTexts[nowIdx].setColor('#333333');
      timerTexts[nowIdx].setAlpha(1);
    }
  }
  // repositionner (si layout bouge)
  if (timerTexts[nowIdx] && playerNameTexts[nowIdx]) positionTimerTextNearName(timerTexts[nowIdx], playerNameTexts[nowIdx]);
  // D√©faite sur timeout
  if (playerTimersMs[nowIdx] === 0) {
    if (!eliminationOrder.includes(nowIdx)) {
      eliminationOrder.push(nowIdx);
      
      // Supprimer TOUTES les pi√®ces du joueur √©limin√© par timeout
      const eliminatedPlayerId = nowIdx;
      const piecesToRemove = pieces.filter(p => p.player === eliminatedPlayerId);
      
      for (const piece of piecesToRemove) {
        // Nettoyer les √©l√©ments associ√©s avant suppression
        cleanupCursorForPiece(piece);
        removeHeartFromPiece(piece);
        removeOcarinaFromPiece(piece);
        if (piece.sprite) piece.sprite.destroy();
        if (piece.backgroundSprite) piece.backgroundSprite.destroy();
      }
      
      // Retirer toutes les pi√®ces du joueur √©limin√© du tableau pieces
      pieces = pieces.filter(p => p.player !== eliminatedPlayerId);
      
      // Annoncer l'√©limination par timeout
      const eliminatedPlayer = players[nowIdx];
      showInfoMessage(`‚è∞ ${eliminatedPlayer.name} a perdu par timeout ! Toutes ses pi√®ces ont disparu.`, 3000);
      
      // Passer au joueur suivant si le joueur √©limin√© √©tait le joueur actuel
      if (nowIdx === currentPlayer) {
        currentPlayer = getNextActivePlayer();
        updateTurnUI();
      }
    }
    // v√©rifier fin
    const remainingKings = pieces.filter(pp => pp.type === 'king').length;
    if (remainingKings <= 1) {
      let winnerId = null;
      const kingPiece = pieces.find(pp => pp.type === 'king');
      if (kingPiece) winnerId = kingPiece.player;
      let ranking = [];
      if (winnerId !== null) ranking.push(winnerId);
      const rest = eliminationOrder.slice().reverse();
      for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
      endGameWithRanking(ranking);
    }
  }
}

function endGameWithRanking(ranking) {
  // Cr√©er le message de fin de partie avec le classement
  let message = "üèÜ FIN DE PARTIE üèÜ\n\n";
  
  for (let i = 0; i < ranking.length; i++) {
    const playerId = ranking[i];
    const player = players[playerId];
    const position = i + 1;
    const emoji = position === 1 ? "ü•á" : position === 2 ? "ü•à" : position === 3 ? "ü•â" : "üèÖ";
    
    message += `${emoji} ${position}er : ${player.name}\n`;
  }
  
  // Afficher le message de mani√®re permanente avec le bouton int√©gr√©
  showEndGameMessage(message);
}

function showEndGameMessage(message) {
  if (!infoText || !infoBackground) return;
  
  // Marquer que c'est un message de fin de partie permanent
  isEndGameMessage = true;
  
  const scene = infoText.scene;
  
  // Calculer la taille n√©cessaire pour le message + bouton
  const textWidth = Math.min(500, Math.max(300, message.length * 8));
  const textHeight = 140; // Hauteur fixe pour message + bouton plus bas
  
  // Ajuster la taille du fond pour inclure le bouton
  infoBackground.setSize(textWidth + 32, textHeight); // +32 pour le padding
  infoBackground.setVisible(true);
  
  // Afficher le message (PERMANENT - pas de timeout)
  infoText.setText(message);
  infoText.setVisible(true);
  
  // Cr√©er le bouton "Nouvelle Partie" int√©gr√© dans le message
  const buttonY = 380; // Position du bouton plus bas sous le message
  
  // Cr√©er le fond du bouton
  const buttonBackground = scene.add.rectangle(448, buttonY, 180, 40, 0x4CAF50);
  buttonBackground.setDepth(10001);
  buttonBackground.setStrokeStyle(2, 0x2E7D32);
  buttonBackground.setInteractive();
  
  // Cr√©er le texte du bouton
  const button = scene.add.text(448, buttonY, "üéÆ Nouvelle Partie", {
    font: "18px Arial",
    fill: "#ffffff"
  });
  button.setOrigin(0.5, 0.5);
  button.setDepth(10002);
  button.setInteractive();
  
  // Style du bouton au survol
  buttonBackground.on('pointerover', () => {
    buttonBackground.setFillStyle(0x45a049);
  });
  
  buttonBackground.on('pointerout', () => {
    buttonBackground.setFillStyle(0x4CAF50);
  });
  
  // Action du bouton : recharger la page
  const reloadGame = () => {
    location.reload();
  };
  
  buttonBackground.on('pointerdown', reloadGame);
  button.on('pointerdown', reloadGame);
}

const game = new Phaser.Game(config);

// --- Publicit√©s ---
const ADS = [
  { a1: 'Retro Console XL', a2: 'Promo -30%' },
  { a1: 'Figurines 8-bit', a2: 'Nouveaut√©s' },
  { a1: 'Cartouches Repro', a2: 'Rare Loot' },
  { a1: 'T-shirts Pixel', a2: 'Collection 2025' },
];

function rotateAds() {
  adRotationIndex = (adRotationIndex + 1) % ADS.length;
  const data = ADS[adRotationIndex];
  const s1 = document.getElementById('ad-slot-1');
  const s2 = document.getElementById('ad-slot-2');
  if (s1) s1.textContent = data.a1;
  if (s2) s2.textContent = data.a2;
  updateAdInfo(true);
}

function updateAdInfo(reset = false) {
  const info = document.getElementById('ad-info');
  if (!info) return;
  const nextIn = reset ? 5 : (5 - (moveCount % 5));
  const plural = nextIn >= 2 ? 's' : '';
  info.textContent = `Mise √† jour dans ${nextIn} action${plural} (toutes les 5 actions)`;
}

// ========================================
// SYST√àME DE S√âLECTION DES PERSONNAGES
// ========================================

function startCharacterSelection() {
  // R√©cup√©rer les param√®tres de configuration
  const gridSizeSelect = document.getElementById('grid-size-select');
  const playerCountSelect = document.getElementById('player-count-select');
  
  GRID_SIZE = parseInt(gridSizeSelect.value);
  TILE_SIZE = Math.floor(780 / GRID_SIZE);
  playerCount = parseInt(playerCountSelect.value);
  
  // R√©initialiser les donn√©es
  characterSelectionMode = true;
  currentPlayerIndex = 0;
  playerArmies = [];
  playerMoney = [];
  playerNames = [];
  playerFactions = [];
  
  // Initialiser les joueurs avec les points selon la taille du plateau
  const budget = (GRID_SIZE === 9) ? 30 : (GRID_SIZE === 11) ? 60 : 100;
  for (let i = 0; i < playerCount; i++) {
    playerArmies.push([]);
    playerMoney.push(budget);
    playerNames.push(`Joueur ${i + 1}`);
    playerFactions.push('Nintendo');
  }
  
  // Charger toutes les pi√®ces disponibles
  availablePieces = piecesData.filter(piece => piece.type !== 'king');
  
  // Cr√©er l'interface de s√©lection
  createCharacterSelectionUI();
}

function createCharacterSelectionUI() {
  // Cr√©er le conteneur principal
  const selectionContainer = document.createElement('div');
  selectionContainer.id = 'character-selection-container';
  selectionContainer.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--primary-bg);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    font-family: var(--font-family);
  `;
  
  // Header
  const header = document.createElement('div');
  header.style.cssText = `
    background: var(--secondary-bg);
    padding: 20px;
    border-bottom: 2px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
  `;
  
  const title = document.createElement('h1');
  title.textContent = 'üéÆ ' + t('game-title');
  title.style.cssText = `
    color: var(--accent-gold);
    margin: 0;
    font-size: 28px;
    font-weight: bold;
  `;
  
  const closeBtn = document.createElement('button');
  closeBtn.innerHTML = '‚úï';
  closeBtn.style.cssText = `
    background: var(--accent-color);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 18px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  `;
  closeBtn.addEventListener('click', () => {
    const container = document.getElementById('character-selection-container');
    if (container) container.remove();
    characterSelectionMode = false;
  });
  
  header.appendChild(title);
  header.appendChild(closeBtn);
  
  // Contenu principal
  const mainContent = document.createElement('div');
  mainContent.style.cssText = `
    display: flex;
    flex: 1;
    overflow: hidden;
  `;
  
  // Zone de s√©lection (2/3)
  const selectionArea = document.createElement('div');
  selectionArea.style.cssText = `
    width: 66.67%;
    padding: 20px;
    overflow-y: auto;
    background: var(--primary-bg);
  `;
  
  // Informations du joueur actuel
  const playerInfo = document.createElement('div');
  playerInfo.style.cssText = `
    background: var(--accent-color);
    color: white;
    padding: 20px;
    border-radius: var(--border-radius);
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  `;
  
  const playerNameDiv = document.createElement('div');
  playerNameDiv.style.cssText = `
    display: flex;
    align-items: center;
    gap: 15px;
  `;
  
  const playerNameInput = document.createElement('input');
  playerNameInput.type = 'text';
  playerNameInput.value = playerNames[currentPlayerIndex];
  playerNameInput.id = 'player-name-input';
  playerNameInput.setAttribute('data-t', 'player');
  playerNameInput.style.cssText = `
    background: white;
    color: #000000;
    border: none;
    padding: 8px 12px;
    border-radius: var(--border-radius);
    font-size: 18px;
    font-weight: bold;
    min-width: 150px;
  `;
  
  const factionSelect = document.createElement('select');
  factionSelect.id = 'faction-select';
  factionSelect.style.cssText = `
    background: white;
    color: #000000;
    border: none;
    padding: 8px 12px;
    border-radius: var(--border-radius);
    font-size: 14px;
    min-width: 120px;
  `;
  
  const factions = ['Nintendo', 'PlayStation', 'Xbox', 'SEGA'];
  factions.forEach(faction => {
    const option = document.createElement('option');
    option.value = faction;
    option.textContent = faction.charAt(0).toUpperCase() + faction.slice(1);
    if (faction === playerFactions[currentPlayerIndex]) option.selected = true;
    factionSelect.appendChild(option);
  });
  
  playerNameDiv.appendChild(playerNameInput);
  playerNameDiv.appendChild(factionSelect);
  
  const moneyDisplay = document.createElement('div');
  moneyDisplay.id = 'money-display';
  moneyDisplay.style.cssText = `
    font-size: 18px;
    font-weight: bold;
  `;
  
  playerInfo.appendChild(playerNameDiv);
  playerInfo.appendChild(moneyDisplay);
  
  // Grille des personnages
  const charactersGrid = document.createElement('div');
  charactersGrid.id = 'characters-grid';
  charactersGrid.style.cssText = `
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    margin-bottom: 20px;
  `;
  
  // Zone des √©quipes (1/3)
  const teamsArea = document.createElement('div');
  teamsArea.style.cssText = `
    width: 33.33%;
    background: var(--secondary-bg);
    padding: 20px;
    overflow-y: auto;
    border-left: 2px solid var(--border-color);
  `;
  
  const teamsTitle = document.createElement('h2');
  teamsTitle.textContent = t('team');
  teamsTitle.style.cssText = `
    color: var(--accent-gold);
    text-align: center;
    margin-bottom: 20px;
    font-size: 20px;
  `;
  
  const teamsContainer = document.createElement('div');
  teamsContainer.id = 'teams-container';
  teamsContainer.style.cssText = `
    display: flex;
    flex-direction: column;
    gap: 15px;
  `;
  
  // Cr√©er les √©quipes
  for (let i = 0; i < playerCount; i++) {
    const teamDiv = document.createElement('div');
    teamDiv.id = `team-${i}`;
    teamDiv.style.cssText = `
      background: var(--card-bg);
      border: 2px solid ${i === currentPlayerIndex ? 'var(--accent-gold)' : 'var(--border-color)'};
      border-radius: var(--border-radius);
      padding: 15px;
      box-shadow: var(--shadow-light);
    `;
    
    const teamHeader = document.createElement('div');
    teamHeader.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    `;
    
    const teamTitle = document.createElement('h3');
    teamTitle.textContent = playerNames[i];
    teamTitle.id = `team-title-${i}`;
    teamTitle.style.cssText = `
      color: var(--accent-gold);
      margin: 0;
      font-size: 16px;
    `;
    
    const teamMoney = document.createElement('div');
    teamMoney.id = `team-money-${i}`;
    teamMoney.style.cssText = `
      color: var(--text-secondary);
      font-size: 12px;
    `;
    
    teamHeader.appendChild(teamTitle);
    teamHeader.appendChild(teamMoney);
    
    const teamUnits = document.createElement('div');
    teamUnits.id = `team-units-${i}`;
    teamUnits.style.cssText = `
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 40px;
    `;
    
    teamDiv.appendChild(teamHeader);
    teamDiv.appendChild(teamUnits);
    teamsContainer.appendChild(teamDiv);
  }
  
  // Boutons de contr√¥le
  const controlsDiv = document.createElement('div');
  controlsDiv.style.cssText = `
    background: var(--secondary-bg);
    padding: 20px;
    border-top: 2px solid var(--border-color);
    display: flex;
    justify-content: center;
    gap: 15px;
  `;
  
  const prevPlayerBtn = document.createElement('button');
  prevPlayerBtn.textContent = '‚Üê ' + t('previous-player');
  prevPlayerBtn.id = 'prev-player-btn';
  prevPlayerBtn.style.cssText = `
    padding: 12px 24px;
    background: ${currentPlayerIndex > 0 ? 'var(--accent-color)' : 'var(--text-muted)'};
    color: white;
    border: none;
    border-radius: var(--border-radius);
    font-size: 14px;
    font-weight: bold;
    cursor: ${currentPlayerIndex > 0 ? 'pointer' : 'not-allowed'};
    transition: all 0.3s ease;
    opacity: ${currentPlayerIndex > 0 ? '1' : '0.5'};
  `;
  
  const nextPlayerBtn = document.createElement('button');
  nextPlayerBtn.textContent = t('next-player') + ' ‚Üí';
  nextPlayerBtn.id = 'next-player-btn';
  nextPlayerBtn.style.cssText = `
    padding: 12px 24px;
    background: var(--accent-gold);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
  `;
  
  const startGameBtn = document.createElement('button');
  startGameBtn.textContent = 'üöÄ ' + t('start-game-button');
  startGameBtn.id = 'start-game-btn';
  startGameBtn.style.cssText = `
    padding: 12px 24px;
    background: var(--accent-gold);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    display: none;
    transition: all 0.3s ease;
  `;
  
  // Assembler l'interface
  selectionArea.appendChild(playerInfo);
  selectionArea.appendChild(charactersGrid);
  
  teamsArea.appendChild(teamsTitle);
  teamsArea.appendChild(teamsContainer);
  
  mainContent.appendChild(selectionArea);
  mainContent.appendChild(teamsArea);
  
  controlsDiv.appendChild(prevPlayerBtn);
  controlsDiv.appendChild(nextPlayerBtn);
  controlsDiv.appendChild(startGameBtn);
  
  selectionContainer.appendChild(header);
  selectionContainer.appendChild(mainContent);
  selectionContainer.appendChild(controlsDiv);
  
  document.body.appendChild(selectionContainer);
  
  // G√©n√©rer les cartes de personnages
  generateCharacterCards();
  updateTeamsDisplay();
  updatePlayerInfo();
  
  // √âv√©nements
  prevPlayerBtn.addEventListener('click', prevPlayer);
  nextPlayerBtn.addEventListener('click', nextPlayer);
  startGameBtn.addEventListener('click', startGameFromSelection);
  playerNameInput.addEventListener('change', (e) => {
    playerNames[currentPlayerIndex] = e.target.value;
    updateTeamsDisplay();
  });
  factionSelect.addEventListener('change', (e) => {
    const newFaction = e.target.value;
    const oldFaction = playerFactions[currentPlayerIndex];
    
    // Si l'√©diteur change, supprimer tous les personnages d√©j√† s√©lectionn√©s
    if (newFaction !== oldFaction) {
      // Rembourser les points des personnages s√©lectionn√©s
      const totalRefund = playerArmies[currentPlayerIndex].reduce((sum, piece) => sum + piece.cost, 0);
      playerMoney[currentPlayerIndex] += totalRefund;
      
      // Vider l'arm√©e du joueur
      playerArmies[currentPlayerIndex] = [];
      
      // Mettre √† jour l'affichage
      updateTeamsDisplay();
      updatePlayerInfo();
      
      showInfoMessage(`√âditeur chang√© ! ${totalRefund} points rembours√©s.`, 3000);
    }
    
    playerFactions[currentPlayerIndex] = newFaction;
    generateCharacterCards();
  });
}

function generateCharacterCards() {
  const grid = document.getElementById('characters-grid');
  grid.innerHTML = '';
  
  // Filtrer les pi√®ces par faction du joueur actuel
  const currentFaction = playerFactions[currentPlayerIndex];
  const factionPieces = availablePieces.filter(piece => piece.faction === currentFaction);
  
  factionPieces.forEach(piece => {
    const card = document.createElement('div');
    card.className = 'character-card';
    card.dataset.pieceId = piece.name;
    
    // V√©rifier si le personnage peut √™tre achet√©
    const canAfford = playerMoney[currentPlayerIndex] >= piece.cost;
    const selectedCount = playerArmies[currentPlayerIndex].filter(p => p.name === piece.name).length;
    
    card.style.cssText = `
      background: var(--card-bg);
      border: 2px solid ${selectedCount > 0 ? 'var(--accent-gold)' : canAfford ? 'var(--border-color)' : 'var(--text-muted)'};
      border-radius: var(--border-radius);
      padding: 12px;
      text-align: center;
      cursor: ${canAfford ? 'pointer' : 'not-allowed'};
      transition: all 0.3s ease;
      position: relative;
      opacity: ${canAfford ? '1' : '0.5'};
      box-shadow: var(--shadow-light);
    `;
    
    // Image du personnage
    const img = document.createElement('img');
    img.src = piece.image;
    img.alt = piece.name;
    img.style.cssText = `
      width: 60px;
      height: 60px;
      object-fit: contain;
      display: block;
      margin: 0 auto 8px auto;
    `;
    
    // Nom et co√ªt
    const nameDiv = document.createElement('div');
    nameDiv.textContent = piece.name;
    nameDiv.style.cssText = `
      font-weight: bold;
      color: var(--text-primary);
      margin-bottom: 4px;
      font-size: 14px;
    `;
    
    const costDiv = document.createElement('div');
    costDiv.textContent = `${piece.cost} pts`;
    costDiv.style.cssText = `
      color: ${canAfford ? 'var(--accent-gold)' : 'var(--text-muted)'};
      font-weight: bold;
      font-size: 12px;
    `;
    
    // Compteur de s√©lection
    if (selectedCount > 0) {
      const countBadge = document.createElement('div');
      countBadge.textContent = selectedCount;
      countBadge.style.cssText = `
        position: absolute;
        top: 5px;
        left: 5px;
        background: var(--accent-gold);
        color: white;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
      `;
      card.appendChild(countBadge);
    }
    
    card.appendChild(img);
    card.appendChild(nameDiv);
    card.appendChild(costDiv);
    
    // √âv√©nement de clic
    if (canAfford) {
      card.addEventListener('click', () => selectCharacter(piece));
    }
    
    // Hover effect
    if (canAfford) {
      card.addEventListener('mouseenter', () => {
        card.style.borderColor = selectedCount > 0 ? 'var(--accent-color)' : 'var(--accent-gold)';
        card.style.transform = 'translateY(-2px)';
        card.style.boxShadow = 'var(--shadow-medium)';
      });
      
      card.addEventListener('mouseleave', () => {
        card.style.borderColor = selectedCount > 0 ? 'var(--accent-gold)' : 'var(--border-color)';
        card.style.transform = 'translateY(0)';
        card.style.boxShadow = 'var(--shadow-light)';
      });
    }
    
    grid.appendChild(card);
  });
}

function selectCharacter(piece) {
  if (playerMoney[currentPlayerIndex] < piece.cost) {
    showInfoMessage('Pas assez de points !', 2000);
    return;
  }
  
  // Ajouter √† l'arm√©e du joueur
  playerArmies[currentPlayerIndex].push(piece);
  playerMoney[currentPlayerIndex] -= piece.cost;
  
  updateTeamsDisplay();
  updatePlayerInfo();
  generateCharacterCards();
}

function removeCharacter(piece) {
  // Trouver et supprimer le personnage de l'arm√©e du joueur
  const index = playerArmies[currentPlayerIndex].findIndex(p => p.name === piece.name);
  if (index !== -1) {
    playerArmies[currentPlayerIndex].splice(index, 1);
    playerMoney[currentPlayerIndex] += piece.cost;
    
    updateTeamsDisplay();
    updatePlayerInfo();
    generateCharacterCards();
  }
}

function nextPlayer() {
  if (currentPlayerIndex < playerCount - 1) {
    currentPlayerIndex++;
    
    // Changer automatiquement l'√©diteur au suivant (rotation Nintendo -> SEGA -> PlayStation -> Xbox)
    const defaultFactions = ['Nintendo', 'SEGA', 'PlayStation', 'Xbox'];
    if (currentPlayerIndex < defaultFactions.length) {
      playerFactions[currentPlayerIndex] = defaultFactions[currentPlayerIndex];
    }
    
    updatePlayerInfo();
    updateTeamsDisplay();
    generateCharacterCards();
  } else {
    // Dernier joueur - afficher le bouton de d√©marrage
    document.getElementById('next-player-btn').style.display = 'none';
    document.getElementById('prev-player-btn').style.display = 'none';
    document.getElementById('start-game-btn').style.display = 'block';
    showInfoMessage('Tous les joueurs ont termin√© leur s√©lection ! Vous pouvez d√©marrer la partie.', 3000);
  }
}

function prevPlayer() {
  if (currentPlayerIndex > 0) {
    currentPlayerIndex--;
    updatePlayerInfo();
    updateTeamsDisplay();
    generateCharacterCards();
  }
}

function updatePlayerInfo() {
  const playerNameInput = document.getElementById('player-name-input');
  const factionSelect = document.getElementById('faction-select');
  const moneyDisplay = document.getElementById('money-display');
  
  if (playerNameInput) {
    playerNameInput.value = playerNames[currentPlayerIndex];
    playerNameInput.placeholder = t('player') + ' ' + (currentPlayerIndex + 1);
  }
  
  if (factionSelect) {
    factionSelect.value = playerFactions[currentPlayerIndex];
  }
  
  if (moneyDisplay) {
    moneyDisplay.textContent = `${playerMoney[currentPlayerIndex]} points restants`;
  }
  
  // Mettre √† jour l'argent de chaque √©quipe
  for (let i = 0; i < playerCount; i++) {
    const teamMoney = document.getElementById(`team-money-${i}`);
    const teamTitle = document.getElementById(`team-title-${i}`);
    if (teamMoney) {
      teamMoney.textContent = `${playerMoney[i]} points`;
    }
    if (teamTitle) {
      teamTitle.textContent = playerNames[i];
    }
  }
  
  // Mettre √† jour les bordures des √©quipes
  for (let i = 0; i < playerCount; i++) {
    const teamDiv = document.getElementById(`team-${i}`);
    if (teamDiv) {
      teamDiv.style.borderColor = i === currentPlayerIndex ? 'var(--accent-gold)' : 'var(--border-color)';
    }
  }
  
  // Mettre √† jour l'√©tat des boutons de navigation
  updateNavigationButtons();
}

function updateNavigationButtons() {
  const prevPlayerBtn = document.getElementById('prev-player-btn');
  const nextPlayerBtn = document.getElementById('next-player-btn');
  const startGameBtn = document.getElementById('start-game-btn');
  
  if (prevPlayerBtn) {
    const canGoBack = currentPlayerIndex > 0;
    prevPlayerBtn.style.background = canGoBack ? 'var(--accent-color)' : 'var(--text-muted)';
    prevPlayerBtn.style.cursor = canGoBack ? 'pointer' : 'not-allowed';
    prevPlayerBtn.style.opacity = canGoBack ? '1' : '0.5';
  }
  
  if (nextPlayerBtn) {
    const canGoForward = currentPlayerIndex < playerCount - 1;
    nextPlayerBtn.style.background = canGoForward ? 'var(--accent-gold)' : 'var(--text-muted)';
    nextPlayerBtn.style.cursor = canGoForward ? 'pointer' : 'not-allowed';
    nextPlayerBtn.style.opacity = canGoForward ? '1' : '0.5';
    
    // Si c'est le dernier joueur, changer le texte du bouton
    if (currentPlayerIndex === playerCount - 1) {
      nextPlayerBtn.textContent = 'Terminer la s√©lection ‚Üí';
      nextPlayerBtn.style.background = 'var(--accent-gold)';
      nextPlayerBtn.style.cursor = 'pointer';
      nextPlayerBtn.style.opacity = '1';
    } else {
      nextPlayerBtn.textContent = 'Joueur suivant ‚Üí';
    }
  }
  
  // Afficher le bouton de d√©marrage si tous les joueurs ont fini
  if (startGameBtn) {
    const allPlayersFinished = currentPlayerIndex === playerCount - 1;
    startGameBtn.style.display = allPlayersFinished ? 'block' : 'none';
  }
}

function updateTeamsDisplay() {
  for (let i = 0; i < playerCount; i++) {
    const teamUnits = document.getElementById(`team-units-${i}`);
    teamUnits.innerHTML = '';
    
    playerArmies[i].forEach((piece, index) => {
      const unitDiv = document.createElement('div');
      unitDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        background: var(--primary-bg);
        padding: 6px;
        border-radius: 4px;
        border: 1px solid var(--border-color);
        min-width: 50px;
        position: relative;
        transition: all 0.3s ease;
        box-shadow: var(--shadow-light);
      `;
      
      // Bouton de suppression (seulement pour le joueur actuel)
      if (i === currentPlayerIndex) {
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '√ó';
        removeBtn.style.cssText = `
          position: absolute;
          top: -5px;
          right: -5px;
          background: var(--accent-color);
          color: white;
          border: none;
          border-radius: 50%;
          width: 20px;
          height: 20px;
          font-size: 12px;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1;
        `;
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          removeCharacter(piece);
        });
        unitDiv.appendChild(removeBtn);
      }
      
      const img = document.createElement('img');
      img.src = piece.image;
      img.alt = piece.name;
      img.style.cssText = `
        width: 30px;
        height: 30px;
        object-fit: contain;
      `;
      
      unitDiv.appendChild(img);
      
      // Hover effect
      unitDiv.addEventListener('mouseenter', () => {
        unitDiv.style.transform = 'translateY(-2px)';
        unitDiv.style.boxShadow = 'var(--shadow-medium)';
      });
      
      unitDiv.addEventListener('mouseleave', () => {
        unitDiv.style.transform = 'translateY(0)';
        unitDiv.style.boxShadow = 'var(--shadow-light)';
      });
      
      teamUnits.appendChild(unitDiv);
    });
  }
}

function startGameFromSelection() {
  // R√©cup√©rer et mettre √† jour la taille du plateau s√©lectionn√©e
  const gridSizeSelect = document.getElementById('grid-size-select');
  if (gridSizeSelect) {
    GRID_SIZE = parseInt(gridSizeSelect.value);
    TILE_SIZE = Math.floor(780 / GRID_SIZE);
    console.log(`Taille du plateau mise √† jour: ${GRID_SIZE}x${GRID_SIZE}, TILE_SIZE: ${TILE_SIZE}`);
  }
  
  // Cacher l'interface de s√©lection
  const selectionContainer = document.getElementById('character-selection-container');
  if (selectionContainer) {
    selectionContainer.remove();
  }
  
  // Cacher la configuration de la partie
  const gameSetup = document.getElementById('game-setup');
  if (gameSetup) {
    gameSetup.style.display = 'none';
  }
  
  characterSelectionMode = false;
  
  // Cr√©er les pi√®ces sur le plateau selon les s√©lections
  createPiecesFromSelection();
  
  // Les pi√®ces seront mises √† jour dans startGame apr√®s cr√©ation des sprites
  
  // Mettre √† jour l'affichage des pi√®ces en jeu apr√®s la cr√©ation des pi√®ces
  setTimeout(() => {
    updateRulesSidebar();
  }, 200);
  
  // Afficher le canvas apr√®s un court d√©lai pour s'assurer qu'il est cr√©√©
  setTimeout(() => {
    const canvas = document.querySelector('.game-root canvas');
    if (canvas) {
      canvas.classList.add('game-started');
    }
  }, 100);
  
  showInfoMessage('La partie commence !', 3000);
  
  // D√©marrer le jeu directement
  startGame(game.scene.scenes[0]);
}

function createPiecesFromSelection() {
  // Cette fonction ne fait que pr√©parer les donn√©es
  // Les sprites et joueurs seront cr√©√©s dans startGame
  console.log('Donn√©es de s√©lection pr√©par√©es');
}

// Fonction supprim√©e - les sprites sont cr√©√©s dans startGame

/* https://www.reddit.com/r/retrogaming/comments/1hkzmcw/i_redrew_some_nes_sprites_of_various_nintendo/?tl=fr */
</script>
</body>