<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Chesstendo - Draft + Plateau</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
<header style="position:sticky; top:0; z-index:5000; background:#ffffffcc; backdrop-filter:saturate(120%) blur(6px); box-shadow:0 4px 16px rgba(0,0,0,0.12); overflow:visible;">
  <div style="max-width:1200px; margin:0 auto; padding:10px 16px; display:flex; align-items:center; justify-content:space-between; position:relative; height:64px;">
    <nav style="display:flex; gap:14px; align-items:center;">
      <a href="index.html" style="font:14px Arial; color:#111; text-decoration:none; padding:6px 10px; border-radius:6px;">Jouer</a>
      <a href="pieces.html" style="font:14px Arial; color:#111; text-decoration:none; padding:6px 10px; border-radius:6px;">Les pi√®ces</a>
      <a href="regles.html" style="font:14px Arial; color:#111; text-decoration:none; padding:6px 10px; border-radius:6px;">Les r√®gles</a>
      <a href="objets.html" style="font:14px Arial; color:#111; text-decoration:none; padding:6px 10px; border-radius:6px;">Les objets</a>
      <a href="credits.html" style="font:14px Arial; color:#111; text-decoration:none; padding:6px 10px; border-radius:6px;">Cr√©dits</a>
    </nav>
    <a href="index.html" aria-label="Accueil" style="position:absolute; left:50%; top:0; transform:translateX(-50%); display:inline-flex; align-items:center;">
      <img src="public/images/site/logo-video-games-battle-256.png" alt="Video Games Battle" style="height:128px; width:128px; object-fit:contain; display:block;" />
    </a>
    <div>
      <a href="login.html" style="font:14px Arial; color:#111; text-decoration:none; padding:6px 10px; border-radius:6px;">Se connecter</a>
    </div>
  </div>
</header>
<div id="app" style="display:flex; gap:16px; align-items:flex-start; padding-top:96px;">
  <div id="game-root"></div>
  <div id="ads-panel" style="width:280px;">
    <div id="ads-title" style="font:16px Arial; margin-bottom:8px;">Publicit√©s</div>
    <div id="ad-slot-1" style="height:130px; background:#f0f0f0; margin-bottom:10px; display:flex; align-items:center; justify-content:center;">Annonce 1</div>
    <div id="ad-slot-2" style="height:130px; background:#f0f0f0; margin-bottom:10px; display:flex; align-items:center; justify-content:center;">Annonce 2</div>
    <div id="ad-info" style="font:12px Arial; color:#555;">Mise √† jour toutes les 5 actions</div>
    <div id="rules-panel" style="margin-top:14px;">
      <div style="font:16px Arial; margin-bottom:6px;">Pi√®ces en jeu</div>
      <div id="rules-list" style="font:12px Arial; color:#222; line-height:1.5;"></div>
    </div>
  </div>
</div>
<script>

const config = {
  type: Phaser.CANVAS,
  width: 900,
  height: 900,
  resolution: (window.devicePixelRatio || 1),
  backgroundColor: '#ececec',
  parent: 'game-root',
  scene: { preload, create, update },
  render: {
    antialias: true,
    pixelArt: false,
    roundPixels: false,
    mipmapFilter: Phaser.Textures.FilterMode.LINEAR
  }
};

const GRID_OFFSET_X = 60; // marge gauche
const GRID_OFFSET_Y = 60; // marge haut
let TILE_SIZE = 52;       // recalcul√© selon GRID_SIZE
let GRID_SIZE = 15;       // configurable (9, 12, 15)

let grid = [];
let pieces = [];
let currentPlayer = 0; // index joueur qui doit jouer
let gameStarted = false;
let selectedPiece = null;
let highlightedTiles = [];
let turnText;
let moveCount = 0;
// plus de garde: d√©cr√©ment √† chaque fin de tour
let adRotationIndex = 0;
let playerNameTexts = [];
let turnIcon;
let currentChoicesFaction = null;
let choiceListBottomY = 0;
let pendingPlayerIndex = 0;
let playerSetupDiv = null;
let adIntervalId = null;
let eliminationOrder = [];
let gridSizeUIElems = [];
// Options de partie
let timerEnabled = true;
let timerOptionEl = null;
// Items & caisses
let itemCrates = []; // [{ x, y, sprite, active, lastRound }]
let playerItemIcons = []; // par joueur: tableau d'ic√¥nes [{ sprite, item }]
let currentItemAction = null; // { playerId, type: 'bomb', active: true }
let lastCrateEventMove = 0; // obsol√®te (conserv√© si besoin)
let roundCounter = 0;
let lastCrateRound = 0;
let itemUsedThisTurn = false;
// Portails
let portalOrange = null; // { x, y, sprite }
let portalBlue = null;   // { x, y, sprite }
// √âtoile d'invincibilit√©
let starInvincible = { playerId: -1, untilRound: -1 };
let starPhase = 0; // pour l‚Äôeffet arc-en-ciel
let starTileOverlays = new Map(); // key "x,y" -> Image overlay arc-en-ciel
// Poids d'apparition des objets de caisse
const ITEM_WEIGHTS = {
  bobomb: 4,
  portals: 4,
  lightning: 1,
  star: 2,
};
// Timers
let playerTimersMs = [];
let timerTexts = [];
let timerEvent = null;
let timerBlinkToggle = false;

// Factions et teintes
const brandTints = {
  nintendo: 0xe60012,
  sega: 0x0089cf,
  playstation: 0x003087,
  xbox: 0x107c10
};

function parseFactionInput(input) {
  const v = (input || '').toLowerCase();
  if (v.includes('seg')) return 'sega';
  if (v.includes('play') || v.includes('sony') || v.includes('ps')) return 'playstation';
  if (v.includes('xbox') || v.includes('xb')) return 'xbox';
  return 'nintendo';
}

function getFactionDisplayName(faction) {
  if (faction === 'sega') return 'SEGA';
  if (faction === 'playstation') return 'PlayStation';
  if (faction === 'xbox') return 'Xbox';
  return 'Nintendo';
}

function applyFactionTintByPlayerId(playerId, sprite) {
  const player = players.find(p => p.id === playerId);
  const tint = brandTints[player && player.faction ? player.faction : 'nintendo'];
  if (sprite && typeof sprite.setTint === 'function') sprite.setTint(tint);
}

// --- BUDGET / DRAFT ---
let players = [];

// roi par faction (non draft√©)
const kings = {
  nintendo: { key: 'king-nintendo', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  sega: { key: 'king-sega', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  playstation: { key: 'king-playstation', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  xbox: { key: 'king-xbox', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 }
};

// catalogues par faction (draftables)
const factionCatalogs = {
  nintendo: {
    link: { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 },
    mario: { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 },
    zelda: { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }
  },
  xbox: {
    'masterchief': { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 },
    'marcus-fenix': { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 },
    'joanna-dark': { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }
  },
  sega: {
    'sonic': { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 },
    'ryo': { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 },
    'joe-musashi': { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }
  },
  playstation: {
    'nathan-drake': { cost: 5, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 },
    'kratos': { cost: 3, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 },
    'astro-bot': { cost: 7, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 }
  }
};

function getCatalogForFaction(faction) {
  return factionCatalogs[faction] || factionCatalogs.nintendo;
}

// Draft UI
let infoText;
let choiceButtons = [];
let choiceThumbs = [];
let armyThumbs = [];
let armyLabels = [];
let endDraftBtn;
let armyPanels = [];
let armyHints = [];
let clearAllBtn;
let playerCountBtns = [];

function preload() {
  // Activer un filtrage lin√©aire pour toutes les textures pour un rendu lisse
  if (this.textures && this.textures.on) {
    this.textures.on(Phaser.Textures.Events.ADD, (key, texture) => {
      if (texture && texture.setFilter) texture.setFilter(Phaser.Textures.FilterMode.LINEAR);
    });
  }
  // Nintendo existants (actuels)
  this.load.setPath('public/images/nintendo/characters/');
  this.load.image('mario', 'mario.png');
  this.load.image('link', 'link.png');
  this.load.image('zelda', 'zelda.png');
  // nintendo utilise le sprite de pit (fallback)
  this.load.image('nintendo', 'pit.png');

  // Rois par faction (images √† fournir) - chemins par dossier faction
  this.load.setPath('public/images/nintendo/characters/');
  this.load.image('king-nintendo', 'king.png');
  this.load.setPath('public/images/sega/characters/');
  this.load.image('king-sega', 'king.png');
  this.load.setPath('public/images/playstation/characters/');
  this.load.image('king-playstation', 'king.png');
  this.load.setPath('public/images/xbox/characters/');
  this.load.image('king-xbox', 'king.png');

  // Sprites factionnels (images √† ajouter par faction, sans pr√©fixe dans les noms de fichiers)
  // Xbox
  this.load.setPath('public/images/xbox/characters/');
  this.load.image('masterchief', 'masterchief.png');
  this.load.image('marcus-fenix', 'marcus-fenix.png');
  this.load.image('joanna-dark', 'joanna-dark.png');
  // SEGA
  this.load.setPath('public/images/sega/characters/');
  this.load.image('sonic', 'sonic.png');
  this.load.image('ryo', 'ryo.png');
  this.load.image('joe-musashi', 'joe-musashi.png');
  // PlayStation
  this.load.setPath('public/images/playstation/characters/');
  this.load.image('nathan-drake', 'nathan-drake.png');
  this.load.image('kratos', 'kratos.png');
  this.load.image('astro-bot', 'astro-bot.png');

  // Items
  this.load.setPath('public/images/items/');
  this.load.svg('item-crate', 'box-item-mario-kart.svg');
  this.load.image('bobomb', 'bobomb.png');
  this.load.image('portals', 'portals.png'); // ic√¥ne inventaire
  this.load.image('portal-orange', 'portal-orange.png');
  this.load.image('portal-blue', 'portal-blue.png');
  this.load.image('lightning', 'Lightning.png');
  this.load.image('star', 'star.png');
  // Sons (par item)
  this.load.setPath('public/sounds/items/');
  this.load.audio('bobomb', 'bobomb.mp3');
  this.load.audio('star', 'star.mp3');
}

function create() {
  infoText = this.add.text(10, 10, "", { font: "16px Arial", fill: "#000" });
  infoText.setDepth(1000);
  // D√©marrage avec preset m√©moris√© ?
  const wantsPreset = localStorage.getItem('vgb_start_with_preset') === '1';
  if (wantsPreset && loadPresetAndStart(this)) {
    localStorage.removeItem('vgb_start_with_preset');
    return;
  }
  setupGridSizeUI(this);
}

function setupGridSizeUI(scene) {
  const last = parseInt(localStorage.getItem('vgb_grid_size') || '0', 10);
  infoText.setText("Choisissez la taille du plateau (9x9 / 12x12 / 15x15)");
  const options = [9,11,15];
  let x = 10;
  let y = 40;
  options.forEach(size => {
    const isDefault = (last === size);
    const label = isDefault ? `${size} x ${size} (d√©faut)` : `${size} x ${size}`;
    const btn = scene.add.text(x, y, label, { font: "16px Arial", fill: "#000", backgroundColor: isDefault ? "#bdf" : "#ddd" })
      .setInteractive()
      .on("pointerdown", () => selectGridSize(scene, size));
    gridSizeUIElems.push(btn);
    y += 30;
  });
  // Bouton pour utiliser directement la taille par d√©faut m√©moris√©e
  if (options.includes(last)) {
    const defBtn = scene.add.text(x, y + 10, `‚û°Ô∏è Utiliser la taille par d√©faut (${last}x${last})`, { font: "16px Arial", fill: "#000", backgroundColor: "#cfc" })
      .setInteractive()
      .on("pointerdown", () => selectGridSize(scene, last));
    gridSizeUIElems.push(defBtn);
  }
}

function selectGridSize(scene, size) {
  GRID_SIZE = size;
  // ajuster automatiquement la taille de tuile pour tenir dans 900x900 avec les offsets
  const available = 900 - 2*GRID_OFFSET_Y; // carr√©
  TILE_SIZE = Math.floor(available / GRID_SIZE);
  // m√©moriser le choix
  try { localStorage.setItem('vgb_grid_size', String(size)); } catch(e) {}
  // passer au choix du nombre de joueurs
  gridSizeUIElems.forEach(e => e && e.setVisible(false));
  setupPlayerCountUI(scene);
}

function getKingCenterIndex(gridSize) {
  // 15x15 -> 8e case (index 7), 11x11 -> 6e (index 5), 9x9 -> 5e (index 4)
  if (gridSize === 15) return 7;
  if (gridSize === 11) return 5;
  if (gridSize === 9) return 4;
  return Math.floor(gridSize / 2);
}

function setupPlayerCountUI(scene) {
  infoText.setText("Choisissez le nombre de joueurs (2 √† 4)");
  const options = [2,3,4];
  let x = 10;
  let y = 40;
  // toggle timer option √† c√¥t√© des boutons
  const timerText = scene.add.text(x, y, `Activer le timer`, { font: "14px Arial", fill: "#000", backgroundColor: "#eee" })
    .setInteractive()
    .on('pointerdown', () => {
      timerEnabled = !timerEnabled;
      timerText.setBackgroundColor(timerEnabled?"#cfc":"#fdd");
    });
  y += 28;
  options.forEach(n => {
    const btn = scene.add.text(x, y, `${n} joueurs`, { font: "16px Arial", fill: "#000", backgroundColor: "#ddd" })
      .setInteractive()
      .on("pointerdown", () => selectPlayerCount(scene, n));
    playerCountBtns.push(btn);
    y += 30;
  });
}

function selectPlayerCount(scene, n) {
  const budget = (GRID_SIZE === 9) ? 20 : (GRID_SIZE === 11) ? 30 : 50;
  players = Array.from({ length: n }, (_, i) => ({ id: i, points: budget, army: [], name: '', faction: 'nintendo' }));
  currentPlayer = 0;
  // nettoyer UI de s√©lection
  playerCountBtns.forEach(b => b.destroy());
  playerCountBtns = [];
  // lancer le formulaire s√©quentiel Nom + Faction
  pendingPlayerIndex = 0;
  showPlayerSetupForm(scene);
}

function showPlayerSetupForm(scene) {
  if (!playerSetupDiv) {
    playerSetupDiv = document.createElement('div');
    playerSetupDiv.id = 'player-setup';
    playerSetupDiv.style.position = 'fixed';
    playerSetupDiv.style.left = '20px';
    playerSetupDiv.style.top = '20px';
    playerSetupDiv.style.zIndex = '9999';
    playerSetupDiv.style.background = 'rgba(255,255,255,0.95)';
    playerSetupDiv.style.border = '1px solid #ccc';
    playerSetupDiv.style.padding = '12px';
    playerSetupDiv.style.borderRadius = '6px';
    playerSetupDiv.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
    document.body.appendChild(playerSetupDiv);
  }
  const idx = pendingPlayerIndex;
  const formHtml = `
    <div style="font:16px Arial; margin-bottom:8px;">Configuration du Joueur ${idx+1}</div>
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
      <label style="font:14px Arial;">Nom</label>
      <input id="pset-name" type="text" value="${players[idx].name || `Joueur ${idx+1}`}" style="font:14px Arial; padding:4px;" />
    </div>
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:12px;">
      <label style="font:14px Arial;">Faction</label>
      <select id="pset-faction" style="font:14px Arial; padding:4px;">
        <option ${players[idx].faction==='nintendo'?'selected':''} value="nintendo">Nintendo</option>
        <option ${players[idx].faction==='sega'?'selected':''} value="sega">SEGA</option>
        <option ${players[idx].faction==='playstation'?'selected':''} value="playstation">PlayStation</option>
        <option ${players[idx].faction==='xbox'?'selected':''} value="xbox">Xbox</option>
      </select>
    </div>
    <div style="display:flex; gap:8px;">
      <button id="pset-validate" style="font:14px Arial; padding:6px 10px;">Valider</button>
    </div>
  `;
  playerSetupDiv.innerHTML = formHtml;
  const btn = document.getElementById('pset-validate');
  btn.onclick = () => {
    const name = (document.getElementById('pset-name').value || '').trim() || `Joueur ${idx+1}`;
    const faction = (document.getElementById('pset-faction').value || 'nintendo');
    players[idx].name = name;
    players[idx].faction = faction;
    pendingPlayerIndex++;
    if (pendingPlayerIndex >= players.length) {
      // termin√©
      playerSetupDiv.remove();
      playerSetupDiv = null;
      infoText.setText("");
      setupDraftUI(scene);
      updateDraftUI();
    } else {
      showPlayerSetupForm(scene);
    }
  };
}

function setupDraftUI(scene) {
  rebuildChoiceList(scene);

  // bouton "Terminer"
  endDraftBtn = scene.add.text(10, choiceListBottomY+10, "‚úÖ Terminer draft", 
    { font: "16px Arial", fill: "#000", backgroundColor: "#afa" })
    .setInteractive()
    .on("pointerdown", () => endDraft(scene));

  // bouton "Tout supprimer"
  clearAllBtn = scene.add.text(180, choiceListBottomY+10, "üóëÔ∏è Tout supprimer", 
    { font: "16px Arial", fill: "#000", backgroundColor: "#faa" })
    .setInteractive()
    .on("pointerdown", () => clearCurrentBasket(scene));

  // labels/panneaux/hints dynamiques selon nombre de joueurs
  armyLabels = [];
  armyPanels = [];
  armyHints = [];
  armyThumbs = Array.from({ length: players.length }, () => []);
  for (let i = 0; i < players.length; i++) {
    const baseLabelY = 30 + i*70;
    armyLabels[i] = scene.add.text(300, baseLabelY, `√âquipe J${i+1}`, { font: "16px Arial", fill: "#000" });
    armyPanels[i] = scene.add.rectangle(450, baseLabelY + 35, 280, 50, 0xffffff, 0).setStrokeStyle(0);
    armyHints[i] = scene.add.text(300, baseLabelY + 15, "Cliquez pour retirer", { font: "12px Arial", fill: "#555" });
  }
  renderArmyThumbnails(scene);
}

function hasTexture(scene, key) {
  return scene.textures && typeof scene.textures.exists === 'function' && scene.textures.exists(key);
}

function rebuildChoiceList(scene) {
  const faction = players[currentPlayer] && players[currentPlayer].faction ? players[currentPlayer].faction : 'nintendo';
  const draftCatalog = getCatalogForFaction(faction);
  // d√©truire anciens choix
  if (choiceThumbs.length) {
    for (let entry of choiceThumbs) {
      entry.image.destroy();
      entry.nameText.destroy();
      entry.costText.destroy();
    }
    choiceThumbs = [];
  }
  currentChoicesFaction = faction;
  let y = 50;
  for (let key in draftCatalog) {
    const displayName = getDisplayNameForKey(key);
    const texKey = hasTexture(scene, key) ? key : 'nintendo';
    const img = scene.add.image(35, y, texKey)
      .setDisplaySize(52,52)
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const nameText = scene.add.text(70, y - 12, displayName, { font: "16px Arial", fill: "#000" })
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const costText = scene.add.text(70, y + 10, `cost: ${draftCatalog[key].cost}` , { font: "12px Arial", fill: "#333" });
    choiceThumbs.push({ key, image: img, nameText, costText });
    y += 70;
  }
  choiceListBottomY = y;
  if (endDraftBtn) endDraftBtn.setY(choiceListBottomY + 10);
  if (clearAllBtn) clearAllBtn.setY(choiceListBottomY + 10);
}

function mapCharacterToFactionSprite(faction, baseKey) {
  // baseKey est d√©j√† la cl√© du sprite √† charger dans le dossier de la faction
  return baseKey;
}

function getDisplayNameForKey(key) {
  // Capitalise chaque mot
  return key.replaceAll('-', ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function updateDraftUI() {
  let p = players[currentPlayer];
  infoText.setText(`Joueur ${p.id+1} - Points restants: ${p.points}\nChoisissez vos persos`);
  rebuildChoiceList(infoText.scene); // reconstruire au changement de joueur/faction
  updateChoiceAvailability();
  const scene = infoText.scene;
  renderArmyThumbnails(scene);
  if (clearAllBtn) {
    clearAllBtn.setText(`üóëÔ∏è Tout supprimer (J${currentPlayer+1})`);
  }
}

function updateChoiceAvailability() {
  const p = players[currentPlayer];
  const catalog = getCatalogForFaction(p.faction);
  for (let entry of choiceThumbs) {
    const affordable = p.points >= catalog[entry.key].cost;
    entry.image.setAlpha(affordable ? 1 : 0.4);
    entry.nameText.setAlpha(affordable ? 1 : 0.5);
    entry.costText.setAlpha(affordable ? 1 : 0.5);
    if (affordable) {
      entry.image.setInteractive();
      entry.nameText.setInteractive();
    } else {
      entry.image.disableInteractive();
      entry.nameText.disableInteractive();
    }
  }
}

function renderArmyThumbnails(scene) {
  // nettoyer existants
  for (let i = 0; i < armyThumbs.length; i++) {
    for (let img of armyThumbs[i]) { img.destroy(); }
    armyThumbs[i] = [];
  }
  // re-cr√©er
  players.forEach((pl,i) => {
    const baseY = 60 + i*70;
    pl.army.forEach((charKey, idx) => {
      const img = scene.add.image(300 + idx*45, baseY, charKey).setDisplaySize(32,32);
      if (i === currentPlayer && !gameStarted) {
        img.setInteractive().on("pointerdown", () => removeArmyItem(scene, i, idx));
      } else {
        img.disableInteractive();
        img.setAlpha(0.9);
      }
      armyThumbs[i].push(img);
    });
  });
}

function removeArmyItem(scene, playerIndex, itemIndex) {
  if (gameStarted) return;
  if (playerIndex !== currentPlayer) return;
  const key = players[playerIndex].army[itemIndex];
  if (!key) return;
  players[playerIndex].army.splice(itemIndex, 1);
  players[playerIndex].points += getCatalogForFaction(players[playerIndex].faction)[key].cost;
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function clearCurrentBasket(scene) {
  if (gameStarted) return;
  const p = players[currentPlayer];
  // Confirmation
  if (!window.confirm(`Voulez-vous supprimer tous les choix du Joueur ${currentPlayer+1} ?`)) {
    return;
  }
  // rembourser tous les choix
  let refund = 0;
  for (let key of p.army) {
    refund += getCatalogForFaction(p.faction)[key].cost;
  }
  p.points += refund;
  p.army = [];
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function pickCharacter(scene, key) {
  let p = players[currentPlayer];
  let char = getCatalogForFaction(p.faction)[key];
  if (p.points >= char.cost) {
    p.points -= char.cost;
    p.army.push(key);
    updateDraftUI();
  }
}

function endDraft(scene) {
  if (currentPlayer === players.length-1) {
    // Tous les joueurs ont fini => lancer la partie
    startGame(scene);
  } else {
    currentPlayer++;
    updateDraftUI();
  }
}

function rulesTextForEntry(entry) {
  const name = getDisplayNameForKey(entry.key || entry.type || '');
  const moves = (entry.moves || []).map(m => `(${m[0]},${m[1]})`).join(', ');
  const range = typeof entry.range === 'number' ? entry.range : 0;
  return `${name}: d√©placements ${moves || '‚Äî'} port√©e ${range || 0}`;
}

function buildRulesCatalog() {
  const map = new Map();
  // Ajouter les rois
  for (const f of Object.keys(kings)) {
    const k = kings[f];
    map.set(k.key, { key: k.key, moves: k.moves, range: k.range });
  }
  // Ajouter les pi√®ces des factions
  for (const f of Object.keys(factionCatalogs)) {
    const cat = factionCatalogs[f];
    for (const key of Object.keys(cat)) {
      const it = cat[key];
      map.set(key, { key, moves: it.moves, range: it.range });
    }
  }
  return map;
}

function updateRulesSidebar() {
  const el = document.getElementById('rules-list');
  if (!el) return;
  const rulesMap = buildRulesCatalog();
  // Helper pour trouver la source d'image selon faction et type
  const getImgSrc = (faction, type, isKing) => {
    const file = isKing ? 'king' : type;
    return `public/images/${faction}/characters/${file}.png`;
  };
  // D√©dupliquer par (faction::keyAfficher)
  const presentByKey = new Map();
  for (const p of pieces) {
    const faction = players[p.player] && players[p.player].faction ? players[p.player].faction : 'nintendo';
    const isKing = p.type === 'king';
    const ruleKey = isKing ? (kings[faction].key) : p.type;
    const uniq = `${faction}::${ruleKey}`;
    if (!presentByKey.has(uniq)) {
      const entry = rulesMap.get(ruleKey);
      if (entry) {
        const text = rulesTextForEntry(entry);
        const img = getImgSrc(faction, isKing ? 'king' : p.type, isKing);
        presentByKey.set(uniq, { img, text });
      }
    }
  }
  if (presentByKey.size === 0) {
    el.innerHTML = '<div style="color:#666;">Aucune pi√®ce en jeu</div>';
    return;
  }
  const rows = [];
  presentByKey.forEach((v) => {
    rows.push(`<div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
      <img src="${v.img}" alt="" style="width:24px; height:24px; object-fit:contain; display:block;" />
      <div>${v.text}</div>
    </div>`);
  });
  el.innerHTML = rows.join('');
}

function startGame(scene) {
  gameStarted = true;
  currentPlayer = 0;
  // reset portails
  if (portalOrange && portalOrange.sprite) { portalOrange.sprite.destroy(); }
  if (portalBlue && portalBlue.sprite) { portalBlue.sprite.destroy(); }
  portalOrange = null;
  portalBlue = null;
  infoText.setText("");
  // cacher widget d'option timer s'il existe c√¥t√© Phaser
  if (playerCountBtns && playerCountBtns.length) { playerCountBtns.forEach(b => b && b.setVisible(false)); }
  // cacher l'UI de draft
  choiceButtons.forEach(btn => btn.setVisible(false));
  if (endDraftBtn) endDraftBtn.setVisible(false);
  if (choiceThumbs && choiceThumbs.length) {
    choiceThumbs.forEach(entry => {
      entry.image.setVisible(false);
      entry.nameText.setVisible(false);
      entry.costText.setVisible(false);
    });
  }
  if (clearAllBtn) clearAllBtn.setVisible(false);
  // cacher l'aper√ßu des √©quipes pendant la partie
  if (armyLabels && armyLabels.length) {
    armyLabels.forEach(lbl => lbl && lbl.setVisible(false));
  }
  if (armyThumbs && armyThumbs.length) {
    armyThumbs.forEach(list => list.forEach(img => img && img.setVisible(false)));
  }
  if (armyPanels && armyPanels.length) {
    armyPanels.forEach(r => r && r.setVisible(false));
  }
  if (armyHints && armyHints.length) {
    armyHints.forEach(t => t && t.setVisible(false));
  }

  // cr√©er la grille
  for (let y=0; y<GRID_SIZE; y++) {
    grid[y] = [];
    for (let x=0; x<GRID_SIZE; x++) {
      const baseColor = (x+y)%2===0 ? 0xffffff : 0xcccccc;
      const rect = scene.add.rectangle(
        GRID_OFFSET_X + x*TILE_SIZE + TILE_SIZE/2,
        GRID_OFFSET_Y + y*TILE_SIZE + TILE_SIZE/2,
        TILE_SIZE-2, TILE_SIZE-2,
        baseColor
      ).setStrokeStyle(1,0x000000).setInteractive();
      rect.baseColor = baseColor;
      rect.pos = {x,y};
      rect.on('pointerdown', () => handleClick(scene, rect.pos));
      grid[y][x] = rect;
    }
  }

  // Placer les caisses d'objets selon la taille de grille
  itemCrates = [];
  const cratePositions = [];
  if (GRID_SIZE === 9) {
    const cx = Math.floor(GRID_SIZE/2);
    const cy = Math.floor(GRID_SIZE/2);
    cratePositions.push({ x: cx, y: cy });
  } else if (GRID_SIZE === 11) {
    // Positions demand√©es (1-based): [5,5], [5,7], [7,5], [7,7]
    // Conversion 0-based:
    cratePositions.push({ x: 4, y: 4 }, { x: 4, y: 6 }, { x: 6, y: 4 }, { x: 6, y: 6 });
  } else if (GRID_SIZE === 15) {
    // Positions demand√©es (1-based): [6,6], [6,10], [8,8], [10,6], [10,10]
    // Conversion 0-based:
    cratePositions.push({ x: 5, y: 5 }, { x: 5, y: 9 }, { x: 7, y: 7 }, { x: 9, y: 5 }, { x: 9, y: 9 });
  }
  for (const pos of cratePositions) {
    const sprite = scene.add.image(0,0,'item-crate');
    sprite.setDisplaySize(TILE_SIZE*0.6, TILE_SIZE*0.6);
    sprite.setAlpha(1);
    itemCrates.push({ x: pos.x, y: pos.y, sprite, active: true, lastRound: roundCounter });
  }

  // Helpers placement
  const getPlayerSide = (index) => {
    if (index === 0) return 'top';
    if (index === 1) return 'bottom';
    if (index === 2) return 'left';
    return 'right';
  };
  const mid = getKingCenterIndex(GRID_SIZE);

  const getBlockSlotsForSide = (side) => {
    // G√©n√©rer une spirale en coordonn√©es locales (autour de 0,0) puis mapper vers la grille
    let minDX, maxDX, minDY, maxDY;
    if (side === 'top' || side === 'bottom') {
      minDX = -2; maxDX = 2; minDY = 0; maxDY = 3; // 5x4
    } else { // left / right
      minDX = 0; maxDX = 3; minDY = -2; maxDY = 2; // 4x5
    }
    const area = (maxDX - minDX + 1) * (maxDY - minDY + 1);
    const needed = area - 1; // case du roi exclue

    const dirs = [ [1,0], [0,1], [-1,0], [0,-1] ]; // droite, bas, gauche, haut
    let stepLen = 1;
    let dirIndex = 0;
    let lx = 0, ly = 0; // coords locales
    const offsets = [];
    while (offsets.length < needed && stepLen < 100) {
      for (let repeat = 0; repeat < 2; repeat++) {
        const [dxStep, dyStep] = dirs[dirIndex];
        for (let s = 0; s < stepLen; s++) {
          lx += dxStep; ly += dyStep;
          if (lx >= minDX && lx <= maxDX && ly >= minDY && ly <= maxDY && !(lx === 0 && ly === 0)) {
            offsets.push({ dx: lx, dy: ly });
            if (offsets.length >= needed) break;
          }
        }
        dirIndex = (dirIndex + 1) % 4;
        if (offsets.length >= needed) break;
      }
      stepLen++;
    }

    // Map vers les coordonn√©es grille selon le c√¥t√©
    const slots = [];
    if (side === 'top') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: 0 + o.dy });
    } else if (side === 'bottom') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: GRID_SIZE - 1 - o.dy });
    } else if (side === 'left') {
      for (const o of offsets) slots.push({ x: 0 + o.dx, y: mid + o.dy });
    } else if (side === 'right') {
      for (const o of offsets) slots.push({ x: GRID_SIZE - 1 - o.dx, y: mid + o.dy });
    }
    return slots;
  };

  // 1) Placer les rois par faction au centre exact du bord
  players.forEach((p,i) => {
    const side = getPlayerSide(i);
    let pos = { x: mid, y: 0 };
    if (side === 'top') pos = { x: mid, y: 0 };
    if (side === 'bottom') pos = { x: mid, y: GRID_SIZE - 1 };
    if (side === 'left') pos = { x: 0, y: mid };
    if (side === 'right') pos = { x: GRID_SIZE - 1, y: mid };
    const kingKey = (kings[p.faction] && kings[p.faction].key) ? kings[p.faction].key : 'nintendo';
    const spr = scene.add.image(0,0,kingKey);
    pieces.push({ sprite: spr, type: 'king', x: pos.x, y: pos.y, player: p.id });
  });

  // 2) Placer les autres pi√®ces en partant du bord propre √† chaque joueur
  players.forEach((p,i) => {
    const side = getPlayerSide(i);
    const slots = getBlockSlotsForSide(side);
    let si = 0;
    p.army.forEach((charKey) => {
      // avancer jusqu'√† trouver un slot libre
      while (si < slots.length && getPieceAt(slots[si])) si++;
      if (si >= slots.length) return; // plus de place dans le bloc
      const pos = slots[si];
      const spr = scene.add.image(0,0,charKey);
      pieces.push({ sprite: spr, type: charKey, x: pos.x, y: pos.y, player: p.id });
      si++;
    });
  });

  updatePieces();
  // Bandeau "D√©but de la partie" en haut de la grille
  const startText = scene.add.text(GRID_OFFSET_X + (GRID_SIZE*TILE_SIZE)/2, GRID_OFFSET_Y - 26, "D√©but de la partie !", { font: "20px Arial", fill: "#000", backgroundColor: "#fff" })
    .setOrigin(0.5, 0)
    .setDepth(2000);
  scene.time.delayedCall(1500, () => { startText.destroy(); });

  // Timers: init par taille
  const baseMinutes = (GRID_SIZE === 9) ? 5 : (GRID_SIZE === 11) ? 10 : 15;
  playerTimersMs = players.map(() => baseMinutes * 60 * 1000);
  // Cr√©er/mettre √† jour les textes timers pr√®s des noms
  if (timerTexts.length) { timerTexts.forEach(t => t && t.destroy()); }
  timerTexts = players.map((p,i) => {
    const nameText = playerNameTexts[i];
    const t = scene.add.text(0,0, formatMs(playerTimersMs[i]), { font: "14px Arial", fill: "#333", backgroundColor: "#fff" }).setDepth(1600);
    positionTimerTextNearName(t, nameText);
    return t;
  });
  // Lancer tick si activ√©
  if (timerEvent) timerEvent.remove(false);
  if (timerEnabled) {
    timerEvent = scene.time.addEvent({ delay: 250, loop: true, callback: () => tickTimer(scene) });
  }

  // Textes des noms des joueurs hors de la grille
  playerNameTexts.forEach(t => t && t.destroy());
  playerNameTexts = [];
  const midNames = getKingCenterIndex(GRID_SIZE);
  const margin = 12;
  players.forEach((p,i) => {
    const side = (i===0)?'top':(i===1)?'bottom':(i===2)?'left':'right';
    let nx = 0, ny = 0;
    if (side === 'top') { nx = GRID_OFFSET_X + midNames*TILE_SIZE + TILE_SIZE/2; ny = GRID_OFFSET_Y - 18; }
    if (side === 'bottom') { nx = GRID_OFFSET_X + midNames*TILE_SIZE + TILE_SIZE/2; ny = GRID_OFFSET_Y + GRID_SIZE*TILE_SIZE + 6; }
    if (side === 'left') { nx = GRID_OFFSET_X - 12; ny = GRID_OFFSET_Y + midNames*TILE_SIZE + TILE_SIZE/2; }
    if (side === 'right') { nx = GRID_OFFSET_X + GRID_SIZE*TILE_SIZE + 12; ny = GRID_OFFSET_Y + midNames*TILE_SIZE + TILE_SIZE/2; }
    const tintColor = brandTints[p.faction || 'nintendo'] || 0x000000;
    const factionLabel = getFactionDisplayName(p.faction || 'nintendo');
    const label = `${p.name} (${factionLabel})`;
    const txt = scene.add.text(nx, ny, label, { font: "18px Arial", fill: `#${tintColor.toString(16).padStart(6,'0')}` }).setOrigin(0.5);
    if (side === 'left') txt.setAngle(-90);
    if (side === 'right') txt.setAngle(90);
    txt.setDepth(1500);
    playerNameTexts.push(txt);
  });

  // Indicateur de tour (ic√¥ne)
  if (turnIcon) { turnIcon.destroy(); }
  turnIcon = scene.add.text(0,0,"üéÆ", { font: "22px Arial" }).setDepth(2000);
  updateTurnUI();
  updateRulesSidebar();
}

function savePreset() {
  try {
    const preset = {
      gridSize: GRID_SIZE,
      players: players.map(p => ({ name: p.name, faction: p.faction }))
    };
    localStorage.setItem('vgb_preset', JSON.stringify(preset));
  } catch(e) {}
}

function loadPresetAndStart(scene) {
  try {
    const raw = localStorage.getItem('vgb_preset');
    if (!raw) return false;
    const preset = JSON.parse(raw);
    if (!preset || !preset.gridSize || !Array.isArray(preset.players) || preset.players.length < 2) return false;
    GRID_SIZE = preset.gridSize;
    const available = 900 - 2*GRID_OFFSET_Y;
    TILE_SIZE = Math.floor(available / GRID_SIZE);
    players = preset.players.map((pp, i) => ({ id: i, points: 20, army: [], name: pp.name || `Joueur ${i+1}`, faction: pp.faction || 'nintendo' }));
    currentPlayer = 0;
    setupDraftUI(scene);
    updateDraftUI();
    return true;
  } catch(e) { return false; }
}

function updatePieces() {
  for (let p of pieces) {
    p.sprite.x = GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2;
    p.sprite.y = GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2;
    // ajuster la taille pour remplir la case moins une marge de bordure
    const targetSize = TILE_SIZE; // utiliser toute la case
    p.sprite.setDisplaySize(targetSize, targetSize);
    // Forcer une mise √† l'√©chelle enti√®re pour √©viter tout flou sous-pixel
    p.sprite.setOrigin(0.5, 0.5);
    // s'assurer que les pi√®ces restent au-dessus des overlays
    if (typeof p.sprite.setDepth === 'function') p.sprite.setDepth(1000);
    if (p.sprite.texture && p.sprite.texture.setFilter) p.sprite.texture.setFilter(Phaser.Textures.FilterMode.LINEAR);
  }
  if (itemCrates && itemCrates.length) {
    for (const c of itemCrates) {
      if (c.sprite) {
        c.sprite.x = GRID_OFFSET_X + c.x*TILE_SIZE + TILE_SIZE/2;
        c.sprite.y = GRID_OFFSET_Y + c.y*TILE_SIZE + TILE_SIZE/2;
      }
    }
  }
  // Portails: positionner leurs sprites si pr√©sents
  const scene = infoText && infoText.scene;
  if (portalOrange && portalOrange.sprite) {
    portalOrange.sprite.x = GRID_OFFSET_X + portalOrange.x*TILE_SIZE + TILE_SIZE/2;
    portalOrange.sprite.y = GRID_OFFSET_Y + portalOrange.y*TILE_SIZE + TILE_SIZE/2;
    portalOrange.sprite.setDisplaySize(TILE_SIZE*0.8, TILE_SIZE*0.8);
    portalOrange.sprite.setAlpha(1);
  }
  if (portalBlue && portalBlue.sprite) {
    portalBlue.sprite.x = GRID_OFFSET_X + portalBlue.x*TILE_SIZE + TILE_SIZE/2;
    portalBlue.sprite.y = GRID_OFFSET_Y + portalBlue.y*TILE_SIZE + TILE_SIZE/2;
    portalBlue.sprite.setDisplaySize(TILE_SIZE*0.8, TILE_SIZE*0.8);
    portalBlue.sprite.setAlpha(1);
  }
  // Effet √©toile: afficher un overlay d√©grad√© sous les pi√®ces prot√©g√©es
  if (starInvincible && starInvincible.playerId >= 0 && scene) {
    updateStarOverlays(scene);
  } else {
    clearStarOverlays();
    for (const p of pieces) if (p.sprite) { p.sprite.clearTint && p.sprite.clearTint(); p.sprite.setAlpha && p.sprite.setAlpha(1); }
  }
  // positionner les ic√¥nes d'objets √† c√¥t√© des noms
  if (playerItemIcons.length) {
    for (let i=0; i<playerItemIcons.length; i++) {
      const entries = playerItemIcons[i] || [];
      const nameText = playerNameTexts[i];
      if (nameText && entries.length) {
        for (let k=0; k<entries.length; k++) {
          const e = entries[k];
          if (e && e.sprite) {
            e.sprite.x = nameText.x + nameText.displayWidth/2 + 14 + k*20;
            e.sprite.y = nameText.y;
            // overlay du compteur pour lightning
            if (e.item === 'lightning') {
              if (!e.counterText) {
                e.counterText = nameText.scene.add.text(0,0, '', { font: '12px Arial', fill: '#000', backgroundColor: '#fff' }).setDepth(2001);
              }
              const txt = (e.chargeTurns && e.chargeTurns > 0) ? String(e.chargeTurns) : '';
              e.counterText.setText(txt);
              e.counterText.x = e.sprite.x + 10;
              e.counterText.y = e.sprite.y - 10;
              e.sprite.setAlpha((e.chargeTurns && e.chargeTurns > 0) ? 0.6 : 1);
            } else if (e.counterText) {
              e.counterText.destroy();
              e.counterText = null;
            }
          }
        }
      }
    }
  }
  updateRulesSidebar();
}

function startStarBlink(playerId) {
  // Initialiser la phase de l‚Äôeffet. Le rendu est g√©r√© dans updatePieces().
  starPhase = 0;
}

function stopStarBlink(playerId) {
  // Nettoyer imm√©diatement l‚Äôeffet visuel pour ce joueur
  for (const p of pieces) {
    if (p.player === playerId && p.sprite) {
      p.sprite.clearTint();
      p.sprite.setAlpha(1);
    }
  }
}

function ensureRainbowTileTexture(scene) {
  const key = 'rainbow-tile';
  const size = Math.max(1, TILE_SIZE - 2);
  const existing = scene.textures.exists(key) ? scene.textures.get(key) : null;
  if (existing && existing.source[0] && existing.source[0].width === size && existing.source[0].height === size) return key;
  if (existing) scene.textures.remove(key);
  const tex = scene.textures.createCanvas(key, size, size);
  const ctx = tex.getContext();
  const grd = ctx.createLinearGradient(0, 0, size, size);
  grd.addColorStop(0.00, '#ff0040');
  grd.addColorStop(0.20, '#ff8000');
  grd.addColorStop(0.40, '#ffee00');
  grd.addColorStop(0.60, '#00dd55');
  grd.addColorStop(0.80, '#00aaff');
  grd.addColorStop(1.00, '#7a00ff');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, size, size);
  tex.refresh();
  return key;
}

function updateStarOverlays(scene) {
  if (!starInvincible || starInvincible.playerId < 0) { clearStarOverlays(); return; }
  const key = ensureRainbowTileTexture(scene);
  const desired = new Set();
  for (const p of pieces) {
    if (p.player === starInvincible.playerId) {
      const k = p.x + ',' + p.y;
      desired.add(k);
      if (!starTileOverlays.has(k)) {
        const img = scene.add.image(
          GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2,
          GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2,
          key
        );
        img.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
        img.setDepth(900); // sous la pi√®ce, au-dessus de la case
        img.setAlpha(0.85);
        starTileOverlays.set(k, img);
      } else {
        const img = starTileOverlays.get(k);
        img.x = GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2;
        img.y = GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2;
        img.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
      }
    }
  }
  // supprimer overlays non d√©sir√©s
  for (const [k, img] of Array.from(starTileOverlays.entries())) {
    if (!desired.has(k)) {
      if (img && img.destroy) img.destroy();
      starTileOverlays.delete(k);
    }
  }
}

function clearStarOverlays() {
  for (const [, img] of Array.from(starTileOverlays.entries())) {
    if (img && img.destroy) img.destroy();
  }
  starTileOverlays.clear();
}

function placePortal(color, pos) {
  const scene = infoText.scene;
  if (color === 'orange') {
    if (portalOrange && portalOrange.sprite) portalOrange.sprite.destroy();
    const spr = scene.add.image(0,0,'portal-orange');
    portalOrange = { x: pos.x, y: pos.y, sprite: spr };
  } else {
    if (portalBlue && portalBlue.sprite) portalBlue.sprite.destroy();
    const spr = scene.add.image(0,0,'portal-blue');
    portalBlue = { x: pos.x, y: pos.y, sprite: spr };
  }
}

function handleClick(scene, pos) {
  if (!gameStarted) return;
  const clickedPiece = getPieceAt(pos);
  // Si un item est actif (ex: bombe), g√©rer l'effet et retourner
  if (currentItemAction && currentItemAction.active && currentItemAction.playerId === currentPlayer) {
    if (currentItemAction.type === 'bomb') {
      // Limite de placement: √† <=3 cases d'une pi√®ce du joueur
      const canPlace = canPlaceBombAt(pos, currentPlayer);
      if (!canPlace) return;
      detonateBombAt(pos);
      currentItemAction.active = false;
      currentItemAction = null; // sortir du mode pose de bombe
      itemUsedThisTurn = true;
      clearHighlights(); // retirer l'indicateur de placement
      // consommer l'item bombe s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (currentItemAction && typeof currentItemAction.inventoryIndex === 'number') ? currentItemAction.inventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'bobomb');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'portal_orange' && currentItemAction.stage === 'orange') {
      if (getPieceAt(pos)) return; // doit √™tre vide
      placePortal('orange', pos);
      currentItemAction.type = 'portal_blue';
      currentItemAction.stage = 'blue';
      if (infoText) infoText.setText(`Joueur ${currentPlayer+1}: placez le portail BLEU`);
      const allowed = getAllEmptyCells();
      highlightPositions(allowed, 0x90caf9); // bleu p√¢le
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'portal_blue' && currentItemAction.stage === 'blue') {
      if (getPieceAt(pos)) return; // doit √™tre vide
      placePortal('blue', pos);
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      if (infoText) infoText.setText("");
      // consommer l'item portals s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (currentItemAction && typeof currentItemAction.inventoryIndex === 'number') ? currentItemAction.inventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'portals');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
  }

  // S√©lection d'une pi√®ce du joueur courant
  if (clickedPiece && clickedPiece.player === currentPlayer) {
    selectedPiece = clickedPiece;
    const reachable = getReachablePositions(selectedPiece);
    highlightPositions(reachable);
    return;
  }

  // D√©placement si une pi√®ce est s√©lectionn√©e et la case est atteignable
  if (selectedPiece) {
    const reachable = getReachablePositions(selectedPiece);
    const isReachable = reachable.some(p => p.x === pos.x && p.y === pos.y);
    if (isReachable) {
      // Capture √©ventuelle sur la case cible
      const target = getPieceAt(pos);
      if (target && target.player !== selectedPiece.player) {
        // Protection √©toile: impossible de capturer si la cible est prot√©g√©e
        if (starInvincible && starInvincible.playerId === target.player && starInvincible.untilRound > roundCounter) {
          // annuler la capture
          return;
        }
        const capturedKing = target.type === 'king';
        target.sprite.destroy();
        pieces = pieces.filter(p => p !== target);
        // D√©placer la pi√®ce du joueur sur la case captur√©e
        selectedPiece.x = pos.x;
        selectedPiece.y = pos.y;
        // R√©cup√©ration de la caisse
        maybePickupItem(selectedPiece);
        updatePieces();
        clearHighlights();
        selectedPiece = null;
        // Gestion √©limination et condition de fin
        if (capturedKing) {
          if (!eliminationOrder.includes(target.player)) {
            eliminationOrder.push(target.player);
          }
          const remainingKings = pieces.filter(pp => pp.type === 'king').length;
          if (remainingKings <= 1) {
            // d√©terminer le vainqueur (roi encore vivant)
            let winnerId = null;
            const kingPiece = pieces.find(pp => pp.type === 'king');
            if (kingPiece) winnerId = kingPiece.player;
            // construire classement
            let ranking = [];
            if (winnerId !== null) ranking.push(winnerId);
            const rest = eliminationOrder.slice().reverse();
            for (let pid of rest) {
              if (winnerId === null || pid !== winnerId) ranking.push(pid);
            }
            endGameWithRanking(ranking);
          return;
        }
        }
        moveCount++;
        if (moveCount % 5 === 0) rotateAds();
        updateAdInfo();
        // fin de tour
        let oldRound = roundCounter;
        if (currentPlayer === players.length - 1) { roundCounter++; }
        currentPlayer = (currentPlayer+1) % players.length; // changer de joueur
        if (roundCounter !== oldRound) {
          decrementLightningCharges();
          // Fin d‚Äôeffet √©toile si n√©cessaire
          if (starInvincible && starInvincible.playerId >= 0 && starInvincible.untilRound <= roundCounter) {
            stopStarBlink(starInvincible.playerId);
            clearStarOverlays();
            // arr√™ter le son √©toile
            try {
              const s = infoText.scene.sound;
              if (s && s.stopByKey) s.stopByKey('star'); else if (s && s.stopAll) s.stopAll();
            } catch(e) {}
            starInvincible = { playerId: -1, untilRound: -1 };
          }
        }
        itemUsedThisTurn = false;
        maybeRespawnCrate(scene);
        updateTurnUI();
        // repositionner tous les timers
        if (timerTexts && playerNameTexts) {
          for (let i=0;i<timerTexts.length;i++) {
            if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
          }
        }
        return;
      }
      // Case vide
      selectedPiece.x = pos.x;
      selectedPiece.y = pos.y;
      // R√©cup√©ration de la caisse
      maybePickupItem(selectedPiece);
      updatePieces();
      clearHighlights();
      selectedPiece = null;
      moveCount++;
      if (moveCount % 5 === 0) rotateAds();
      updateAdInfo();
      // fin de tour
      let oldRound = roundCounter;
      if (currentPlayer === players.length - 1) { roundCounter++; }
      currentPlayer = (currentPlayer+1) % players.length; // changer de joueur
      // d√©cr√©menter les charges uniquement quand un round complet vient de s'achever
      if (roundCounter !== oldRound) {
        decrementLightningCharges();
        // Fin d‚Äôeffet √©toile si n√©cessaire
        if (starInvincible && starInvincible.playerId >= 0 && starInvincible.untilRound <= roundCounter) {
          stopStarBlink(starInvincible.playerId);
          clearStarOverlays();
          try {
            const s = infoText.scene.sound;
            if (s && s.stopByKey) s.stopByKey('star'); else if (s && s.stopAll) s.stopAll();
          } catch(e) {}
          starInvincible = { playerId: -1, untilRound: -1 };
        }
      }
      itemUsedThisTurn = false;
      maybeRespawnCrate(scene);
      updateTurnUI();
      // repositionner tous les timers
      if (timerTexts && playerNameTexts) {
        for (let i=0;i<timerTexts.length;i++) {
          if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
        }
      }
    } else {
      // Clic non valide: nettoyer la s√©lection pour √©viter la confusion
      clearHighlights();
      selectedPiece = null;
    }
  }
}

function isValidMove(piece, pos) {
  const reachable = getReachablePositions(piece);
  return reachable.some(p => p.x === pos.x && p.y === pos.y);
}

function getPieceAt(pos) {
  return pieces.find(p => p.x === pos.x && p.y === pos.y);
}

function getReachablePositions(piece) {
  const positions = [];
  const rule = getRuleForPiece(piece);

  const isPortalPos = (x, y, color) => {
    if (color === 'orange' && portalOrange) return portalOrange.x === x && portalOrange.y === y;
    if (color === 'blue' && portalBlue) return portalBlue.x === x && portalBlue.y === y;
    return false;
  };

  const iterateFrom = (startX, startY, dir, maxSteps, usedTeleport) => {
    for (let step = 1; step <= maxSteps; step++) {
      const nx = startX + dir[0] * step;
      const ny = startY + dir[1] * step;
      if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break;
      const occ = getPieceAt({ x: nx, y: ny });

      // Portail: si on touche ORANGE et BLUE existe, on permet de poursuivre depuis BLUE
      if (!usedTeleport && isPortalPos(nx, ny, 'orange') && portalBlue) {
        // On peut s'arr√™ter sur orange si vide
        if (!occ) positions.push({ x: nx, y: ny });
        // Calculer pas restants apr√®s avoir atteint orange
        const remaining = maxSteps - step;
        // Si la case BLEUE est occup√©e
        const occBlue = getPieceAt({ x: portalBlue.x, y: portalBlue.y });
        if (occBlue) {
          // Si ennemi: on peut capturer BLEU puis on s'arr√™te
          if (occBlue.player !== piece.player) positions.push({ x: portalBlue.x, y: portalBlue.y });
          break;
        } else {
          // Ajouter la case BLEUE comme atteignable et poursuivre au-del√†
          positions.push({ x: portalBlue.x, y: portalBlue.y });
          if (remaining > 0) {
            // continuer depuis BLEU dans la m√™me direction
            iterateFrom(portalBlue.x, portalBlue.y, dir, remaining, true);
          }
          break;
        }
      }

      if (!occ) {
        positions.push({ x: nx, y: ny });
        continue;
      }
      // Case occup√©e: on peut capturer un ennemi mais on s'arr√™te ensuite
      if (occ.player !== piece.player) {
        positions.push({ x: nx, y: ny });
      }
      break;
    }
  };

  for (let dir of rule.moves) {
    iterateFrom(piece.x, piece.y, dir, rule.range, false);
  }
  return positions;
}

function getRuleForPiece(piece) {
  // Retourne l'objet { moves, range } pour la pi√®ce, selon faction/type
  const owner = players[piece.player];
  if (!owner) return { moves: [], range: 0 };
  if (piece.type === 'king') {
    const k = kings[owner.faction];
    return k ? { moves: k.moves, range: k.range } : { moves: [], range: 0 };
  }
  const catalog = getCatalogForFaction(owner.faction);
  const entry = catalog[piece.type];
  return entry ? { moves: entry.moves, range: entry.range } : { moves: [], range: 0 };
}

function endGameWithRanking(ranking) {
  gameStarted = false;
  clearHighlights();
  let msg = '';
  if (Array.isArray(ranking) && ranking.length > 0) {
    msg = 'Classement final:\n' + ranking.map((pid, idx) => `${idx+1}. Joueur ${pid+1}`).join('\n');
  } else {
    msg = 'Partie termin√©e.';
  }
  if (turnText) {
    turnText.setText(msg);
  } else if (infoText) {
    infoText.setText(msg);
  }
  // M√©moriser les r√©glages actuels pour relancer facilement
  savePreset();
  // Bouton DOM pour relancer avec les m√™mes r√©glages
  let btn = document.getElementById('restart-same-settings');
  if (btn) btn.remove();
  btn = document.createElement('button');
  btn.id = 'restart-same-settings';
  btn.textContent = 'D√©marrer une nouvelle partie avec les m√™mes r√©glages';
  btn.style.position = 'fixed';
  btn.style.right = '20px';
  btn.style.bottom = '20px';
  btn.style.zIndex = '9999';
  btn.style.padding = '10px 12px';
  btn.style.font = '14px Arial';
  btn.style.background = '#cfc';
  btn.style.border = '1px solid #9c9';
  btn.style.borderRadius = '6px';
  btn.onclick = () => {
    try { localStorage.setItem('vgb_start_with_preset', '1'); } catch(e) {}
    window.location.reload();
  };
  document.body.appendChild(btn);
}

function maybePickupItem(piece) {
  if (!itemCrates || !itemCrates.length) return;
  for (const c of itemCrates) {
    if (!c.active) continue;
    if (piece.x === c.x && piece.y === c.y) {
      const item = rollRandomItem();
      giveItemToPlayer(piece.player, item);
      c.active = false;
      if (c.sprite) { c.sprite.setAlpha(0.25); }
      c.lastRound = roundCounter;
    }
  }
}

function giveItemToPlayer(playerId, itemKey) {
  const scene = infoText.scene;
  // cr√©er une ic√¥ne (empilement jusqu'√† 3 max)
  if (!playerItemIcons[playerId]) playerItemIcons[playerId] = [];
  if (playerItemIcons[playerId].length >= 3) return; // limite 3 objets
  const textureKey = (itemKey === 'portals') ? 'portals' : itemKey;
  const icon = scene.add.image(0,0,textureKey).setDisplaySize(18,18).setInteractive();
  icon.on('pointerdown', () => tryUseItem(playerId, icon));
  // Pour lightning: ajouter compteur 4 tours complets avant utilisation
  const entry = { sprite: icon, item: itemKey };
  if (itemKey === 'lightning') entry.chargeTurns = 5;
  playerItemIcons[playerId].push(entry);
  updatePieces();
}

function tryUseItem(playerId, clickedIconSprite) {
  if (!gameStarted) return;
  if (playerId !== currentPlayer) return; // utiliser √† son tour
  if (itemUsedThisTurn) return; // un seul objet par tour
  const arr = playerItemIcons[playerId] || [];
  if (arr.length === 0) return;
  let idx = 0;
  if (clickedIconSprite) {
    const found = arr.findIndex(e => e && e.sprite === clickedIconSprite);
    if (found >= 0) idx = found;
  }
  const icon = arr[idx];
  if (!icon || !icon.item) return;
  if (icon.item === 'bobomb') {
    // Activer mode pose de bombe: prochain clic sur une case pose et r√©sout l'effet
    currentItemAction = { playerId, type: 'bomb', active: true, inventoryIndex: idx };
    if (infoText) infoText.setText(`Joueur ${playerId+1}: cliquez sur une case pour poser la bombe`);
    // Highlight des cases possibles
    const allowed = getBombPlacablePositions(playerId);
    highlightPositions(allowed, 0xff8a80); // rouge/ros√©
  }
  if (icon.item === 'portals') {
    currentItemAction = { playerId, type: 'portal_orange', active: true, stage: 'orange', inventoryIndex: idx };
    if (infoText) infoText.setText(`Joueur ${playerId+1}: placez le portail ORANGE`);
    const allowed = getAllEmptyCells();
    highlightPositions(allowed, 0xffcc80); // orange p√¢le
  }
  if (icon.item === 'lightning') {
    // Non utilisable tant que charge > 0
    if (icon.chargeTurns && icon.chargeTurns > 0) return;
    // D√©clencher effet √©clair
    triggerLightningEffect();
    // Tuer toutes les pi√®ces sur cases blanches
    applyLightningKill();
    // Consommer l'item s√©lectionn√©
    const useIdx = idx;
    if (playerItemIcons[playerId] && playerItemIcons[playerId].length && useIdx >= 0) {
      const used = playerItemIcons[playerId].splice(useIdx, 1)[0];
      if (used && used.sprite) used.sprite.destroy();
      if (used && used.counterText) used.counterText.destroy();
    }
    itemUsedThisTurn = true;
    updatePieces();
    // Fin de tour apr√®s usage de l'√©clair
    moveCount++;
    if (moveCount % 5 === 0) rotateAds();
    updateAdInfo();
    if (currentPlayer === players.length - 1) { roundCounter++; }
    currentPlayer = (currentPlayer+1) % players.length;
    itemUsedThisTurn = false;
    decrementLightningCharges();
    // Fin d‚Äôeffet √©toile si n√©cessaire (si un round vient d‚Äôavancer au passage ci-dessus)
    if (starInvincible && starInvincible.playerId >= 0 && starInvincible.untilRound <= roundCounter) {
      stopStarBlink(starInvincible.playerId);
      clearStarOverlays();
      try {
        const s = infoText.scene.sound;
        if (s && s.stopByKey) s.stopByKey('star'); else if (s && s.stopAll) s.stopAll();
      } catch(e) {}
      starInvincible = { playerId: -1, untilRound: -1 };
    }
    maybeRespawnCrate(infoText.scene);
    updateTurnUI();
    // repositionner timers si pr√©sents
    if (timerTexts && playerNameTexts) {
      for (let i=0;i<timerTexts.length;i++) {
        if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
      }
    }
  }
  if (icon.item === 'star') {
    // Activer invincibilit√© pour un round complet
    const currentRound = roundCounter;
    starInvincible = { playerId, untilRound: currentRound + 1 };
    startStarBlink(playerId);
    try {
      // Arr√™ter un √©ventuel son pr√©c√©dent et jouer celui de l‚Äô√©toile
      const s = infoText.scene.sound;
      if (s && s.stopAll) s.stopAll();
      s.play('star', { volume: 0.7, loop: true });
    } catch(e) {}
    // Consommer l'item s√©lectionn√©
    const useIdx = idx;
    if (playerItemIcons[playerId] && playerItemIcons[playerId].length && useIdx >= 0) {
      const used = playerItemIcons[playerId].splice(useIdx, 1)[0];
      if (used && used.sprite) used.sprite.destroy();
    }
    itemUsedThisTurn = true;
    updatePieces();
    return;
  }
}

function getBombPlacablePositions(playerId) {
  const positions = [];
  // toutes cases √† distance de Manhattan <= 2 d'au moins une pi√®ce du joueur
  const myPieces = pieces.filter(p => p.player === playerId);
  const seen = new Set();
  for (let mp of myPieces) {
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = -2; dy <= 2; dy++) {
        const x = mp.x + dx;
        const y = mp.y + dy;
        if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) continue;
        const manhattan = Math.abs(dx) + Math.abs(dy);
        if (manhattan <= 2) {
          const key = x+","+y;
          if (!seen.has(key)) { positions.push({ x, y }); seen.add(key); }
        }
      }
    }
  }
  return positions;
}

function canPlaceBombAt(pos, playerId) {
  const allowed = getBombPlacablePositions(playerId);
  return allowed.some(p => p.x === pos.x && p.y === pos.y);
}

function getAllEmptyCells() {
  const cells = [];
  for (let y=0; y<GRID_SIZE; y++) {
    for (let x=0; x<GRID_SIZE; x++) {
      if (!getPieceAt({x,y})) cells.push({x,y});
    }
  }
  return cells;
}

function detonateBombAt(pos) {
  // Effets visuels et sonores
  const scene = infoText.scene;
  try { scene.sound.play('bobomb', { volume: 0.6 }); } catch(e) {}
  // flash rouge sur la zone
  const centerX = GRID_OFFSET_X + pos.x*TILE_SIZE + TILE_SIZE/2;
  const centerY = GRID_OFFSET_Y + pos.y*TILE_SIZE + TILE_SIZE/2;
  const flash = scene.add.rectangle(centerX, centerY, TILE_SIZE*3, TILE_SIZE*3, 0xff5252).setAlpha(0.4).setDepth(3000);
  scene.tweens.add({ targets: flash, alpha: 0, duration: 220, onComplete: () => flash.destroy() });
  // onde circulaire
  const ring = scene.add.circle(centerX, centerY, 6, 0xff1744).setAlpha(0.7).setDepth(3001);
  scene.tweens.add({ targets: ring, radius: TILE_SIZE*1.2, alpha: 0, duration: 300, onComplete: () => ring.destroy() });

  // D√©truire pi√®ces sur la case et les 8 adjacentes (zone 3x3)
  const deltas = [];
  for (let dx=-1; dx<=1; dx++) {
    for (let dy=-1; dy<=1; dy++) {
      deltas.push({x:dx,y:dy});
    }
  }
  for (let d of deltas) {
    const tx = pos.x + d.x;
    const ty = pos.y + d.y;
    if (tx < 0 || ty < 0 || tx >= GRID_SIZE || ty >= GRID_SIZE) continue;
    const victim = getPieceAt({ x: tx, y: ty });
    if (victim) {
      const wasKing = victim.type === 'king';
      victim.sprite.destroy();
      pieces = pieces.filter(p => !(p.x === tx && p.y === ty && p.player === victim.player && p.type === victim.type));
      if (wasKing) {
        if (!eliminationOrder.includes(victim.player)) eliminationOrder.push(victim.player);
      }
    }
  }
  // consommer le premier item du joueur courant (FIFO)
  if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
    const used = playerItemIcons[currentPlayer].shift();
    if (used && used.sprite) used.sprite.destroy();
  }
  updatePieces();
  // V√©rifier condition de fin
  const remainingKings = pieces.filter(pp => pp.type === 'king').length;
  if (infoText) infoText.setText("");
  if (remainingKings <= 1) {
    let winnerId = null;
    const kingPiece = pieces.find(pp => pp.type === 'king');
    if (kingPiece) winnerId = kingPiece.player;
    let ranking = [];
    if (winnerId !== null) ranking.push(winnerId);
    const rest = eliminationOrder.slice().reverse();
    for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
    endGameWithRanking(ranking);
  }
}

function maybeRespawnCrate(scene) {
  if (!itemCrates || !itemCrates.length) return;
  // R√©appara√Æt tous les 3 tours depuis la derni√®re interaction de chaque caisse
  for (const c of itemCrates) {
    if (c.active) continue;
    if ((roundCounter - c.lastRound) >= 3) {
      c.active = true;
      if (!c.sprite) {
        c.sprite = scene.add.image(0,0,'item-crate');
        c.sprite.setDisplaySize(TILE_SIZE*0.6, TILE_SIZE*0.6);
      }
      c.sprite.setAlpha(1);
      // pas besoin de recaler x/y ici, updatePieces() le fera
    }
  }
  updatePieces();
}

function rollRandomItem() {
  // Tirage pond√©r√© selon ITEM_WEIGHTS
  const entries = Object.entries(ITEM_WEIGHTS);
  const total = entries.reduce((s, [,w]) => s + (w||0), 0);
  if (total <= 0) return 'bobomb';
  let r = Math.random() * total;
  for (const [key, weight] of entries) {
    r -= weight;
    if (r <= 0) return key;
  }
  return entries[entries.length-1][0];
}

function clearHighlights() {
  for (let tile of highlightedTiles) {
    tile.setFillStyle(tile.baseColor);
  }
  highlightedTiles = [];
}

function highlightPositions(positions, color = 0xfff59d) {
  clearHighlights();
  for (let pos of positions) {
    const tile = grid[pos.y][pos.x];
    tile.setFillStyle(color);
    highlightedTiles.push(tile);
  }
}

function updateTurnUI() {
  const mid = getKingCenterIndex(GRID_SIZE);
  // Positionner l'ic√¥ne de tour √† c√¥t√© du nom du joueur actif
  if (turnIcon && playerNameTexts[currentPlayer]) {
    const t = playerNameTexts[currentPlayer];
    turnIcon.x = t.x - t.displayWidth/2 - 16;
    turnIcon.y = t.y - t.displayHeight/2;
    // Rotation de l'ic√¥ne selon c√¥t√©
    const side = (currentPlayer===0)?'top':(currentPlayer===1)?'bottom':(currentPlayer===2)?'left':'right';
    if (side === 'left') turnIcon.setAngle(-90); else if (side === 'right') turnIcon.setAngle(90); else turnIcon.setAngle(0);
  }
  // Mettre √† jour la position des ic√¥nes d'objets √† c√¥t√© des noms
  updatePieces();
}

function decrementLightningCharges() {
  for (let i=0; i<playerItemIcons.length; i++) {
    const arr = playerItemIcons[i] || [];
    for (const e of arr) {
      if (e && e.item === 'lightning' && e.chargeTurns && e.chargeTurns > 0) {
        e.chargeTurns = Math.max(0, e.chargeTurns - 1);
      }
    }
  }
  updatePieces();
}

function triggerLightningEffect() {
  const scene = infoText.scene;
  // flash global
  const flash = scene.add.rectangle(GRID_OFFSET_X + GRID_SIZE*TILE_SIZE/2, GRID_OFFSET_Y + GRID_SIZE*TILE_SIZE/2, GRID_SIZE*TILE_SIZE, GRID_SIZE*TILE_SIZE, 0xffff8d).setAlpha(0.35).setDepth(2900);
  scene.tweens.add({ targets: flash, alpha: 0, duration: 250, onComplete: () => flash.destroy() });
}

function isWhiteSquare(x, y) {
  // m√™me logique que baseColor (x+y)%2===0 blanc
  return ((x + y) % 2) === 0;
}

function applyLightningKill() {
  // Supprimer toutes les pi√®ces sur cases blanches (y compris celles du lanceur)
  const victims = pieces.filter(p => isWhiteSquare(p.x, p.y) && !(starInvincible && starInvincible.playerId === p.player && starInvincible.untilRound > roundCounter));
  let kingDied = false;
  for (const v of victims) {
    if (v && v.sprite) v.sprite.destroy();
    if (v.type === 'king') {
      kingDied = true;
      if (!eliminationOrder.includes(v.player)) eliminationOrder.push(v.player);
    }
  }
  // Conserver les pi√®ces prot√©g√©es par l'√©toile m√™me si elles sont sur case blanche
  pieces = pieces.filter(p => !(isWhiteSquare(p.x, p.y) && !(starInvincible && starInvincible.playerId === p.player && starInvincible.untilRound > roundCounter)));
  updatePieces();
  if (kingDied) {
    const remainingKings = pieces.filter(pp => pp.type === 'king').length;
    if (remainingKings <= 1) {
      let winnerId = null;
      const kingPiece = pieces.find(pp => pp.type === 'king');
      if (kingPiece) winnerId = kingPiece.player;
      let ranking = [];
      if (winnerId !== null) ranking.push(winnerId);
      const rest = eliminationOrder.slice().reverse();
      for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
      endGameWithRanking(ranking);
    }
  }
}

function update() {}

function positionTimerTextNearName(timerText, nameText) {
  if (!timerText || !nameText) return;
  timerText.x = nameText.x + nameText.displayWidth/2 + 54;
  timerText.y = nameText.y - (nameText.displayHeight/2);
}

function formatMs(ms) {
  const s = Math.max(0, Math.floor(ms/1000));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

function tickTimer(scene) {
  if (!gameStarted || !timerEnabled) return;
  if (players.length === 0) return;
  const nowIdx = currentPlayer;
  playerTimersMs[nowIdx] = Math.max(0, playerTimersMs[nowIdx] - 250);
  // MAJ texte
  if (timerTexts[nowIdx]) timerTexts[nowIdx].setText(formatMs(playerTimersMs[nowIdx]));
  // feedback visuel sous 10s
  const under10 = playerTimersMs[nowIdx] <= 30000;
  if (timerTexts[nowIdx]) {
    if (under10) {
      timerBlinkToggle = !timerBlinkToggle;
      timerTexts[nowIdx].setColor('#b00020');
      timerTexts[nowIdx].setAlpha(timerBlinkToggle ? 1 : 0.4);
    } else {
      timerTexts[nowIdx].setColor('#333333');
      timerTexts[nowIdx].setAlpha(1);
    }
  }
  // repositionner (si layout bouge)
  if (timerTexts[nowIdx] && playerNameTexts[nowIdx]) positionTimerTextNearName(timerTexts[nowIdx], playerNameTexts[nowIdx]);
  // D√©faite sur timeout
  if (playerTimersMs[nowIdx] === 0) {
    // √©liminer le roi de this player si encore pr√©sent pour provoquer la fin
    const king = pieces.find(pp => pp.type === 'king' && pp.player === nowIdx);
    if (king) {
      king.sprite.destroy();
      pieces = pieces.filter(p => p !== king);
      if (!eliminationOrder.includes(nowIdx)) eliminationOrder.push(nowIdx);
    }
    // v√©rifier fin
    const remainingKings = pieces.filter(pp => pp.type === 'king').length;
    if (remainingKings <= 1) {
      let winnerId = null;
      const kingPiece = pieces.find(pp => pp.type === 'king');
      if (kingPiece) winnerId = kingPiece.player;
      let ranking = [];
      if (winnerId !== null) ranking.push(winnerId);
      const rest = eliminationOrder.slice().reverse();
      for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
      endGameWithRanking(ranking);
    }
  }
}

new Phaser.Game(config);

// --- Publicit√©s ---
const ADS = [
  { a1: 'Retro Console XL', a2: 'Promo -30%' },
  { a1: 'Figurines 8-bit', a2: 'Nouveaut√©s' },
  { a1: 'Cartouches Repro', a2: 'Rare Loot' },
  { a1: 'T-shirts Pixel', a2: 'Collection 2025' },
];

function rotateAds() {
  adRotationIndex = (adRotationIndex + 1) % ADS.length;
  const data = ADS[adRotationIndex];
  const s1 = document.getElementById('ad-slot-1');
  const s2 = document.getElementById('ad-slot-2');
  if (s1) s1.textContent = data.a1;
  if (s2) s2.textContent = data.a2;
  updateAdInfo(true);
}

function updateAdInfo(reset = false) {
  const info = document.getElementById('ad-info');
  if (!info) return;
  const nextIn = reset ? 5 : (5 - (moveCount % 5));
  const plural = nextIn >= 2 ? 's' : '';
  info.textContent = `Mise √† jour dans ${nextIn} action${plural} (toutes les 5 actions)`;
}

/* https://www.reddit.com/r/retrogaming/comments/1hkzmcw/i_redrew_some_nes_sprites_of_various_nintendo/?tl=fr */
</script>
</body>