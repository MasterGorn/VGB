<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Chesstendo - Draft + Plateau</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body style="margin:0; background:#f7f7f7; font:14px Arial, sans-serif; color:#111;">
<div id="header-root"></div>
<div id="app" style="display:flex; gap:16px; align-items:flex-start; padding-top:32px;">
  <div id="game-root"></div>
  <div id="ads-panel" style="width:280px;">
    <div id="ads-title" style="font:16px Arial; margin-bottom:8px;">Publicit√©s</div>
    <div id="ad-slot-1" style="height:130px; background:#f0f0f0; margin-bottom:10px; display:flex; align-items:center; justify-content:center;">Annonce 1</div>
    <div id="ad-slot-2" style="height:130px; background:#f0f0f0; margin-bottom:10px; display:flex; align-items:center; justify-content:center;">Annonce 2</div>
    <div id="ad-info" style="font:12px Arial; color:#555;">Mise √† jour toutes les 5 actions</div>
    <div id="rules-panel" style="margin-top:14px;">
      <div style="font:16px Arial; margin-bottom:6px;">Pi√®ces en jeu</div>
      <div id="rules-list" style="font:12px Arial; color:#222; line-height:1.5;"></div>
    </div>
  </div>
</div>
<script src="public/js/header.js"></script>
<script>
VGBHeader.injectHeader('index');

const config = {
  type: Phaser.CANVAS,
  width: 900,
  height: 900,
  resolution: (window.devicePixelRatio || 1),
  backgroundColor: '#ececec',
  parent: 'game-root',
  scene: { preload, create, update },
  render: {
    antialias: true,
    pixelArt: false,
    roundPixels: false,
    mipmapFilter: Phaser.Textures.FilterMode.LINEAR
  }
};

const GRID_OFFSET_X = 60; // marge gauche
const GRID_OFFSET_Y = 60; // marge haut
let TILE_SIZE = 52;       // recalcul√© selon GRID_SIZE
let GRID_SIZE = 15;       // configurable (9, 12, 15)

let grid = [];
let pieces = [];
let currentPlayer = 0; // index joueur qui doit jouer
let gameStarted = false;
let selectedPiece = null;
let highlightedTiles = [];
let highlightOverlays = [];
let turnText;
let moveCount = 0;
let infoBackground; // Fond blanc pour les messages d'information
let isEndGameMessage = false; // Flag pour emp√™cher le masquage du message de fin
// plus de garde: d√©cr√©ment √† chaque fin de tour
let adRotationIndex = 0;
let playerNameTexts = [];
let turnIcon;
let currentChoicesFaction = null;
let choiceListBottomY = 0;
let pendingPlayerIndex = 0;
let playerSetupDiv = null;
let adIntervalId = null;
let eliminationOrder = [];
let gridSizeUIElems = [];
// Options de partie
let timerEnabled = true;
let timerOptionEl = null;
// Items & caisses
let itemCrates = []; // [{ x, y, sprite, active, lastRound }]
let playerItemIcons = []; // par joueur: tableau d'ic√¥nes [{ sprite, item }]
let currentItemAction = null; // { playerId, type: 'bomb', active: true }
let lastCrateEventMove = 0; // obsol√®te (conserv√© si besoin)
let roundCounter = 0;
let lastCrateRound = 0;
let itemUsedThisTurn = false;
// Portails
let portalOrange = null; // { x, y, sprite }
let portalBlue = null;   // { x, y, sprite }
// √âtoile d'invincibilit√©
let starInvincible = { playerId: -1, untilRound: -1, untilPlayerTurn: false };
let starPhase = 0; // pour l'effet arc-en-ciel
let starTileOverlays = new Map(); // key "x,y" -> Image overlay arc-en-ciel
// Tetriminos (murs)
let tetriminos = []; // array de { x, y, sprite } pour les murs tetrimino
// Bananes (pi√®ges)
let bananas = []; // array de { x, y, sprite } pour les bananes
// Pi√®ces perdues par joueur (pour la queue de phoenix)
let playerLostPieces = []; // array de { playerId, piece } pour chaque joueur
// Pi√®ces poss√©d√©es par le curseur Sims
let possessedPieces = []; // array de { piece, cursorSprite, originalPlayer, houseBounds }
// Pi√®ces qui ont un c≈ìur
let heartPieces = []; // array de { piece, heartSprite }
// Masque de Majora : pi√®ce forc√©e
let forcedPiece = null; // { piece, playerId, maskSprite }
// Ocarina du Temps : pi√®ces transform√©es en cavaliers
let knightPieces = []; // array de { piece, ocarinaSprite }
// Poids d'apparition des objets de caisse
const ITEM_WEIGHTS = {
  bobomb: 4,
  portals: 4,
  lightning: 1,
  star: 2,
  tetrimino: 3,
  tornado: 2,
  banana: 5,
  phoenix: 2,
  cursor: 3,
  heart: 2,
  sandglass: 3,
  mask: 4,
  ocarina: 3
};
// Timers
let playerTimersMs = [];
let timerTexts = [];
let timerEvent = null;
let timerBlinkToggle = false;

// Factions et teintes
const brandTints = {
  nintendo: 0xe60012,
  sega: 0x0089cf,
  playstation: 0x003087,
  xbox: 0x107c10
};

function parseFactionInput(input) {
  const v = (input || '').toLowerCase();
  if (v.includes('seg')) return 'sega';
  if (v.includes('play') || v.includes('sony') || v.includes('ps')) return 'playstation';
  if (v.includes('xbox') || v.includes('xb')) return 'xbox';
  return 'nintendo';
}

function getFactionDisplayName(faction) {
  if (faction === 'sega') return 'SEGA';
  if (faction === 'playstation') return 'PlayStation';
  if (faction === 'xbox') return 'Xbox';
  return 'Nintendo';
}

function applyFactionTintByPlayerId(playerId, sprite) {
  const player = players.find(p => p.id === playerId);
  const tint = brandTints[player && player.faction ? player.faction : 'nintendo'];
  if (sprite && typeof sprite.setTint === 'function') sprite.setTint(tint);
}

// --- BUDGET / DRAFT ---
let players = [];

// roi par faction (non draft√©)
const kings = {
  nintendo: { key: 'king-nintendo', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  sega: { key: 'king-sega', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  playstation: { key: 'king-playstation', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 },
  xbox: { key: 'king-xbox', cost: 0, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 1 }
};

// catalogues par faction (draftables)
const factionCatalogs = {
  nintendo: {
    link: { cost: 5, tier: 2, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 }, // moyen
    mario: { cost: 3, tier: 1, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // faible
    zelda: { cost: 7, tier: 3, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 } // fort
  },
  xbox: {
    'masterchief': { cost: 5, tier: 1, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 }, // faible
    'marcus-fenix': { cost: 3, tier: 2, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // moyen
    'joanna-dark': { cost: 7, tier: 4, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 } // unique
  },
  sega: {
    'sonic': { cost: 5, tier: 1, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 }, // faible
    'ryo': { cost: 3, tier: 2, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // moyen
    'joe-musashi': { cost: 7, tier: 3, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 } // fort
  },
  playstation: {
    'nathan-drake': { cost: 5, tier: 1, moves: [[1,0],[-1,0],[0,1],[0,-1]], range: 3 }, // faible
    'kratos': { cost: 3, tier: 2, moves: [[1,1],[1,-1],[-1,1],[-1,-1]], range: 2 }, // moyen
    'astro-bot': { cost: 7, tier: 3, moves: [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]], range: 8 } // fort
  }
};

function getCatalogForFaction(faction) { 
  return factionCatalogs[faction] || factionCatalogs.nintendo;
}

// Draft UI
let infoText;
let choiceButtons = [];
let choiceThumbs = [];
let armyThumbs = [];
let armyLabels = [];
let endDraftBtn;
let armyPanels = [];
let armyHints = [];
let clearAllBtn;
let playerCountBtns = [];

function preload() {
  // Activer un filtrage lin√©aire pour toutes les textures pour un rendu lisse
  if (this.textures && this.textures.on) {
    this.textures.on(Phaser.Textures.Events.ADD, (key, texture) => {
      if (texture && texture.setFilter) texture.setFilter(Phaser.Textures.FilterMode.LINEAR);
    });
  }
  // Nintendo existants (actuels)
  this.load.setPath('public/images/nintendo/characters/');
  this.load.image('mario', 'mario.png');
  this.load.image('link', 'link.png');
  this.load.image('zelda', 'zelda.png');
  // nintendo utilise le sprite de pit (fallback)
  this.load.image('nintendo', 'pit.png');

  // Rois par faction (images √† fournir) - chemins par dossier faction
  this.load.setPath('public/images/nintendo/characters/');
  this.load.image('king-nintendo', 'king.png');
  this.load.setPath('public/images/sega/characters/');
  this.load.image('king-sega', 'king.png');
  this.load.setPath('public/images/playstation/characters/');
  this.load.image('king-playstation', 'king.png');
  this.load.setPath('public/images/xbox/characters/');
  this.load.image('king-xbox', 'king.png');

  // Sprites factionnels (images √† ajouter par faction, sans pr√©fixe dans les noms de fichiers)
  // Xbox
  this.load.setPath('public/images/xbox/characters/');
  this.load.image('masterchief', 'masterchief.png');
  this.load.image('marcus-fenix', 'marcus-fenix.png');
  this.load.image('joanna-dark', 'joanna-dark.png');
  // SEGA
  this.load.setPath('public/images/sega/characters/');
  this.load.image('sonic', 'sonic.png');
  this.load.image('ryo', 'ryo.png');
  this.load.image('joe-musashi', 'joe-musashi.png');
  // PlayStation
  this.load.setPath('public/images/playstation/characters/');
  this.load.image('nathan-drake', 'nathan-drake.png');
  this.load.image('kratos', 'kratos.png');
  this.load.image('astro-bot', 'astro-bot.png');

  // Items
  this.load.setPath('public/images/items/');
  this.load.svg('item-crate', 'box-item-mario-kart.svg');
  this.load.image('bobomb', 'bobomb.png');
  this.load.image('portals', 'portals.png'); // ic√¥ne inventaire
  this.load.image('portal-orange', 'portal-orange.png');
  this.load.image('portal-blue', 'portal-blue.png');
  this.load.image('lightning', 'Lightning.png');
  this.load.image('star', 'star.png');
  this.load.image('tetrimino', 'tetrimino.png');
  this.load.image('tornado', 'tornado.png');
  this.load.image('banana', 'banana.png');
  this.load.image('phoenix', 'phoenix-down.png');
  this.load.image('cursor', 'cursor-sims.png');
  this.load.image('heart', 'heart.png');
  this.load.image('sandglass', 'hourglass.png');
  this.load.image('mask', 'mask-majora.png');
  this.load.image('ocarina', 'oracina.png');
  // Sons (par item)
  this.load.setPath('public/sounds/items/');
  this.load.audio('bobomb', 'bobomb.mp3');
  this.load.audio('star', 'star.mp3');
  this.load.audio('ocarina', 'ocarina.wav');
}

function create() {
  // Cr√©er le texte d'information centr√© avec fond blanc et coins arrondis
  infoText = this.add.text(0, 0, "", { 
    font: "18px Arial", 
    fill: "#000",
    align: "center",
    wordWrap: { width: 400 }
  });
  infoText.setDepth(10000); // Z-index tr√®s √©lev√© pour passer devant tout
  infoText.setOrigin(0.5, 0.5);
  infoText.x = 448; // Centre du canvas (896/2)
  infoText.y = 300; // Position verticale centr√©e
  
  // Cr√©er le fond blanc avec coins arrondis
  infoBackground = this.add.rectangle(448, 300, 420, 60, 0xffffff);
  infoBackground.setDepth(9999); // Juste en dessous du texte
  infoBackground.setStrokeStyle(2, 0xcccccc);
  infoBackground.setVisible(false);
  // D√©marrage avec preset m√©moris√© ?
  const wantsPreset = localStorage.getItem('vgb_start_with_preset') === '1';
  if (wantsPreset && loadPresetAndStart(this)) {
    localStorage.removeItem('vgb_start_with_preset');
    return;
  }
  setupGridSizeUI(this);
}

function showInfoMessage(message, duration = 3000) {
  if (!infoText || !infoBackground) return;
  
  // Ne pas afficher de nouveaux messages si c'est un message de fin de partie permanent
  if (isEndGameMessage && duration > 0) return;
  
  // Ajuster la taille du fond selon la longueur du message
  const textWidth = Math.min(500, Math.max(200, message.length * 8));
  const textHeight = message.includes('\n') ? 80 : 60;
  
  infoBackground.setSize(textWidth + 32, textHeight); // +32 pour le padding
  infoBackground.setVisible(true);
  
  infoText.setText(message);
  infoText.setVisible(true);
  
  // Masquer apr√®s la dur√©e sp√©cifi√©e (sauf si duration = 0 pour message permanent)
  if (duration > 0 && !isEndGameMessage) {
    setTimeout(() => {
      if (infoText && !isEndGameMessage) infoText.setVisible(false);
      if (infoBackground && !isEndGameMessage) infoBackground.setVisible(false);
    }, duration);
  }
}

function hideInfoMessage() {
  // Ne pas masquer si c'est un message de fin de partie permanent
  if (isEndGameMessage) return;
  
  if (infoText) infoText.setVisible(false);
  if (infoBackground) infoBackground.setVisible(false);
}

function getNextActivePlayer() {
  // Trouver le prochain joueur non √©limin√©
  let nextPlayer = (currentPlayer + 1) % players.length;
  
  // Continuer √† chercher tant qu'on trouve un joueur √©limin√©
  while (eliminationOrder.includes(nextPlayer)) {
    nextPlayer = (nextPlayer + 1) % players.length;
    
    // Protection contre une boucle infinie si tous les joueurs sont √©limin√©s
    if (nextPlayer === currentPlayer) break;
  }
  
  return nextPlayer;
}

function shouldIncrementRoundCounter() {
  // Incr√©menter le compteur de round quand on revient au premier joueur actif
  const nextPlayer = getNextActivePlayer();
  
  // Trouver le premier joueur actif (non √©limin√©)
  let firstActivePlayer = 0;
  while (eliminationOrder.includes(firstActivePlayer) && firstActivePlayer < players.length) {
    firstActivePlayer++;
  }
  
  // Incr√©menter si on revient au premier joueur actif ou si on "boucle" vers un joueur avec un index plus petit
  return nextPlayer === firstActivePlayer || (nextPlayer < currentPlayer && !eliminationOrder.includes(nextPlayer));
}

function setupGridSizeUI(scene) {
  const last = parseInt(localStorage.getItem('vgb_grid_size') || '0', 10);
  showInfoMessage("Choisissez la taille du plateau (9x9 / 12x12 / 15x15)", 10000);
  const options = [9,11,15];
  let x = 10;
  let y = 40;
  options.forEach(size => {
    const isDefault = (last === size);
    const label = isDefault ? `${size} x ${size} (d√©faut)` : `${size} x ${size}`;
    const btn = scene.add.text(x, y, label, { font: "16px Arial", fill: "#000", backgroundColor: isDefault ? "#bdf" : "#ddd" })
      .setInteractive()
      .on("pointerdown", () => selectGridSize(scene, size));
    gridSizeUIElems.push(btn);
    y += 30;
  });
  // Bouton pour utiliser directement la taille par d√©faut m√©moris√©e
  if (options.includes(last)) {
    const defBtn = scene.add.text(x, y + 10, `‚û°Ô∏è Utiliser la taille par d√©faut (${last}x${last})`, { font: "16px Arial", fill: "#000", backgroundColor: "#cfc" })
      .setInteractive()
      .on("pointerdown", () => selectGridSize(scene, last));
    gridSizeUIElems.push(defBtn);
  }
}

function selectGridSize(scene, size) {
  GRID_SIZE = size;
  // ajuster automatiquement la taille de tuile pour tenir dans 900x900 avec les offsets
  const available = 900 - 2*GRID_OFFSET_Y; // carr√©
  TILE_SIZE = Math.floor(available / GRID_SIZE);
  // m√©moriser le choix
  try { localStorage.setItem('vgb_grid_size', String(size)); } catch(e) {}
  // passer au choix du nombre de joueurs
  gridSizeUIElems.forEach(e => e && e.setVisible(false));
  setupPlayerCountUI(scene);
}

function getKingCenterIndex(gridSize) {
  // 15x15 -> 8e case (index 7), 11x11 -> 6e (index 5), 9x9 -> 5e (index 4)
  if (gridSize === 15) return 7;
  if (gridSize === 11) return 5;
  if (gridSize === 9) return 4;
  return Math.floor(gridSize / 2);
}

function setupPlayerCountUI(scene) {
  infoText.setText("Choisissez le nombre de joueurs (2 √† 4)");
  const options = [2,3,4];
  let x = 10;
  let y = 40;
  // toggle timer option en haut √† gauche, bien visible
  const timerText = scene.add.text(10, 10, `Activer le timer`, { font: "14px Arial", fill: "#000", backgroundColor: "#eee" })
    .setInteractive()
    .on('pointerdown', () => {
      timerEnabled = !timerEnabled;
      timerText.setBackgroundColor(timerEnabled?"#cfc":"#fdd");
    });
  options.forEach(n => {
    const btn = scene.add.text(x, y, `${n} joueurs`, { font: "16px Arial", fill: "#000", backgroundColor: "#ddd" })
      .setInteractive()
      .on("pointerdown", () => selectPlayerCount(scene, n));
    playerCountBtns.push(btn);
    y += 30;
  });
}

function selectPlayerCount(scene, n) {
  const budget = (GRID_SIZE === 9) ? 20 : (GRID_SIZE === 11) ? 30 : 50;
  players = Array.from({ length: n }, (_, i) => ({ id: i, points: budget, army: [], name: '', faction: 'nintendo' }));
  currentPlayer = 0;
  // nettoyer UI de s√©lection
  playerCountBtns.forEach(b => b.destroy());
  playerCountBtns = [];
  // lancer le formulaire s√©quentiel Nom + Faction
  pendingPlayerIndex = 0;
  showPlayerSetupForm(scene);
}

function showPlayerSetupForm(scene) {
  if (!playerSetupDiv) {
    playerSetupDiv = document.createElement('div');
    playerSetupDiv.id = 'player-setup';
    playerSetupDiv.style.position = 'fixed';
    playerSetupDiv.style.left = '20px';
    playerSetupDiv.style.top = '20px';
    playerSetupDiv.style.zIndex = '9999';
    playerSetupDiv.style.background = 'rgba(255,255,255,0.95)';
    playerSetupDiv.style.border = '1px solid #ccc';
    playerSetupDiv.style.padding = '12px';
    playerSetupDiv.style.borderRadius = '6px';
    playerSetupDiv.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
    document.body.appendChild(playerSetupDiv);
  }
  const idx = pendingPlayerIndex;
  const formHtml = `
    <div style="font:16px Arial; margin-bottom:8px;">Configuration du Joueur ${idx+1}</div>
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
      <label style="font:14px Arial;">Nom</label>
      <input id="pset-name" type="text" value="${players[idx].name || `Joueur ${idx+1}`}" style="font:14px Arial; padding:4px;" />
    </div>
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:12px;">
      <label style="font:14px Arial;">Faction</label>
      <select id="pset-faction" style="font:14px Arial; padding:4px;">
        <option ${players[idx].faction==='nintendo'?'selected':''} value="nintendo">Nintendo</option>
        <option ${players[idx].faction==='sega'?'selected':''} value="sega">SEGA</option>
        <option ${players[idx].faction==='playstation'?'selected':''} value="playstation">PlayStation</option>
        <option ${players[idx].faction==='xbox'?'selected':''} value="xbox">Xbox</option>
      </select>
    </div>
    <div style="display:flex; gap:8px;">
      <button id="pset-validate" style="font:14px Arial; padding:6px 10px;">Valider</button>
    </div>
  `;
  playerSetupDiv.innerHTML = formHtml;
  const btn = document.getElementById('pset-validate');
  btn.onclick = () => {
    const name = (document.getElementById('pset-name').value || '').trim() || `Joueur ${idx+1}`;
    const faction = (document.getElementById('pset-faction').value || 'nintendo');
    players[idx].name = name;
    players[idx].faction = faction;
    pendingPlayerIndex++;
    if (pendingPlayerIndex >= players.length) {
      // termin√©
      playerSetupDiv.remove();
      playerSetupDiv = null;
      infoText.setText("");
      setupDraftUI(scene);
      updateDraftUI();
    } else {
      showPlayerSetupForm(scene);
    }
  };
}

function setupDraftUI(scene) {
  rebuildChoiceList(scene);

  // bouton "Terminer"
  endDraftBtn = scene.add.text(10, choiceListBottomY+10, "‚úÖ Terminer draft", 
    { font: "16px Arial", fill: "#000", backgroundColor: "#afa" })
    .setInteractive()
    .on("pointerdown", () => endDraft(scene));

  // bouton "Tout supprimer"
  clearAllBtn = scene.add.text(180, choiceListBottomY+10, "üóëÔ∏è Tout supprimer", 
    { font: "16px Arial", fill: "#000", backgroundColor: "#faa" })
    .setInteractive()
    .on("pointerdown", () => clearCurrentBasket(scene));

  // labels/panneaux/hints dynamiques selon nombre de joueurs
  armyLabels = [];
  armyPanels = [];
  armyHints = [];
  armyThumbs = Array.from({ length: players.length }, () => []);
  for (let i = 0; i < players.length; i++) {
    const baseLabelY = 30 + i*70;
    armyLabels[i] = scene.add.text(300, baseLabelY, `√âquipe J${i+1}`, { font: "16px Arial", fill: "#000" });
    armyPanels[i] = scene.add.rectangle(450, baseLabelY + 35, 280, 50, 0xffffff, 0).setStrokeStyle(0, 0).setVisible(false);
    armyHints[i] = scene.add.text(300, baseLabelY + 15, "Cliquez pour retirer", { font: "12px Arial", fill: "#555" });
  }
  renderArmyThumbnails(scene);
}

function hasTexture(scene, key) {
  return scene.textures && typeof scene.textures.exists === 'function' && scene.textures.exists(key);
}

function rebuildChoiceList(scene) {
  const faction = players[currentPlayer] && players[currentPlayer].faction ? players[currentPlayer].faction : 'nintendo';
  const draftCatalog = getCatalogForFaction(faction);
  // d√©truire anciens choix
  if (choiceThumbs.length) {
    for (let entry of choiceThumbs) {
      entry.image.destroy();
      entry.nameText.destroy();
      entry.costText.destroy();
    }
    choiceThumbs = [];
  }
  currentChoicesFaction = faction;
  let y = 50;
  for (let key in draftCatalog) {
    const displayName = getDisplayNameForKey(key);
    const texKey = hasTexture(scene, key) ? key : 'nintendo';
    const img = scene.add.image(35, y, texKey)
      .setDisplaySize(52,52)
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const nameText = scene.add.text(70, y - 12, displayName, { font: "16px Arial", fill: "#000" })
      .setInteractive()
      .on("pointerdown", () => pickCharacter(scene, key));
    const costText = scene.add.text(70, y + 10, `cost: ${draftCatalog[key].cost}` , { font: "12px Arial", fill: "#333" });
    choiceThumbs.push({ key, image: img, nameText, costText });
    y += 70;
  }
  choiceListBottomY = y;
  if (endDraftBtn) endDraftBtn.setY(choiceListBottomY + 10);
  if (clearAllBtn) clearAllBtn.setY(choiceListBottomY + 10);
}

function mapCharacterToFactionSprite(faction, baseKey) {
  // baseKey est d√©j√† la cl√© du sprite √† charger dans le dossier de la faction
  return baseKey;
}

function getDisplayNameForKey(key) {
  // Capitalise chaque mot
  return key.replaceAll('-', ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function updateDraftUI() {
  let p = players[currentPlayer];
  infoText.setText(`Joueur ${p.id+1} - Points restants: ${p.points}\nChoisissez vos persos`);
  rebuildChoiceList(infoText.scene); // reconstruire au changement de joueur/faction
  updateChoiceAvailability();
  const scene = infoText.scene;
  renderArmyThumbnails(scene);
  if (clearAllBtn) {
    clearAllBtn.setText(`üóëÔ∏è Tout supprimer (J${currentPlayer+1})`);
  }
}

function updateChoiceAvailability() {
  const p = players[currentPlayer];
  const catalog = getCatalogForFaction(p.faction);
  for (let entry of choiceThumbs) {
    const affordable = p.points >= catalog[entry.key].cost;
    entry.image.setAlpha(affordable ? 1 : 0.4);
    entry.nameText.setAlpha(affordable ? 1 : 0.5);
    entry.costText.setAlpha(affordable ? 1 : 0.5);
    if (affordable) {
      entry.image.setInteractive();
      entry.nameText.setInteractive();
    } else {
      entry.image.disableInteractive();
      entry.nameText.disableInteractive();
    }
  }
}

function renderArmyThumbnails(scene) {
  // nettoyer existants
  for (let i = 0; i < armyThumbs.length; i++) {
    for (let img of armyThumbs[i]) { img.destroy(); }
    armyThumbs[i] = [];
  }
  // re-cr√©er
  players.forEach((pl,i) => {
    const baseY = 60 + i*70;
    pl.army.forEach((charKey, idx) => {
      const img = scene.add.image(300 + idx*45, baseY, charKey).setDisplaySize(32,32);
      if (i === currentPlayer && !gameStarted) {
        img.setInteractive().on("pointerdown", () => removeArmyItem(scene, i, idx));
      } else {
        img.disableInteractive();
        img.setAlpha(0.9);
      }
      armyThumbs[i].push(img);
    });
  });
}

function removeArmyItem(scene, playerIndex, itemIndex) {
  if (gameStarted) return;
  if (playerIndex !== currentPlayer) return;
  const key = players[playerIndex].army[itemIndex];
  if (!key) return;
  players[playerIndex].army.splice(itemIndex, 1);
  players[playerIndex].points += getCatalogForFaction(players[playerIndex].faction)[key].cost;
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function clearCurrentBasket(scene) {
  if (gameStarted) return;
  const p = players[currentPlayer];
  // Confirmation
  if (!window.confirm(`Voulez-vous supprimer tous les choix du Joueur ${currentPlayer+1} ?`)) {
    return;
  }
  // rembourser tous les choix
  let refund = 0;
  for (let key of p.army) {
    refund += getCatalogForFaction(p.faction)[key].cost;
  }
  p.points += refund;
  p.army = [];
  renderArmyThumbnails(scene);
  updateDraftUI();
}

function pickCharacter(scene, key) {
  let p = players[currentPlayer];
  let char = getCatalogForFaction(p.faction)[key];
  if (p.points >= char.cost) {
    p.points -= char.cost;
    p.army.push(key);
    updateDraftUI();
  }
}

function endDraft(scene) {
  if (currentPlayer === players.length-1) {
    // Tous les joueurs ont fini => lancer la partie
    startGame(scene);
  } else {
    currentPlayer++;
    updateDraftUI();
  }
}

function rulesTextForEntry(entry) {
  const name = getDisplayNameForKey(entry.key || entry.type || '');
  const moves = (entry.moves || []).map(m => `(${m[0]},${m[1]})`).join(', ');
  const range = typeof entry.range === 'number' ? entry.range : 0;
  return `${name}: d√©placements ${moves || '‚Äî'} port√©e ${range || 0}`;
}

function buildRulesCatalog() {
  const map = new Map();
  // Ajouter les rois
  for (const f of Object.keys(kings)) {
    const k = kings[f];
    map.set(k.key, { key: k.key, moves: k.moves, range: k.range });
  }
  // Ajouter les pi√®ces des factions
  for (const f of Object.keys(factionCatalogs)) {
    const cat = factionCatalogs[f];
    for (const key of Object.keys(cat)) {
      const it = cat[key];
      map.set(key, { key, moves: it.moves, range: it.range });
    }
  }
  return map;
}

function updateRulesSidebar() {
  const el = document.getElementById('rules-list');
  if (!el) return;
  const rulesMap = buildRulesCatalog();
  // Helper pour trouver la source d'image selon faction et type
  const getImgSrc = (faction, type, isKing) => {
    const file = isKing ? 'king' : type;
    return `public/images/${faction}/characters/${file}.png`;
  };
  // D√©dupliquer par (faction::keyAfficher)
  const presentByKey = new Map();
  for (const p of pieces) {
    const faction = players[p.player] && players[p.player].faction ? players[p.player].faction : 'nintendo';
    const isKing = p.type === 'king';
    const ruleKey = isKing ? (kings[faction].key) : p.type;
    const uniq = `${faction}::${ruleKey}`;
    if (!presentByKey.has(uniq)) {
      const entry = rulesMap.get(ruleKey);
      if (entry) {
        const text = rulesTextForEntry(entry);
        const img = getImgSrc(faction, isKing ? 'king' : p.type, isKing);
        presentByKey.set(uniq, { img, text });
      }
    }
  }
  if (presentByKey.size === 0) {
    el.innerHTML = '<div style="color:#666;">Aucune pi√®ce en jeu</div>';
    return;
  }
  const rows = [];
  presentByKey.forEach((v) => {
    rows.push(`<div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
      <img src="${v.img}" alt="" style="width:24px; height:24px; object-fit:contain; display:block;" />
      <div>${v.text}</div>
    </div>`);
  });
  el.innerHTML = rows.join('');
}

function startGame(scene) {
  gameStarted = true;
  currentPlayer = 0;
  // reset portails
  if (portalOrange && portalOrange.sprite) { portalOrange.sprite.destroy(); }
  if (portalBlue && portalBlue.sprite) { portalBlue.sprite.destroy(); }
  portalOrange = null;
  portalBlue = null;
  
  // reset tetriminos
  for (const t of tetriminos) {
    if (t.sprite) t.sprite.destroy();
  }
  tetriminos = [];
  
  // reset bananes
  for (const b of bananas) {
    if (b.sprite) b.sprite.destroy();
  }
  bananas = [];
  
  // reset pi√®ces perdues
  playerLostPieces = [];
  
  // reset pi√®ces poss√©d√©es
  for (const pp of possessedPieces) {
    if (pp.cursorSprite) pp.cursorSprite.destroy();
  }
  possessedPieces = [];
  
  // reset c≈ìurs
  for (const hp of heartPieces) {
    if (hp.heartSprite) hp.heartSprite.destroy();
  }
  heartPieces = [];
  
  // reset masque de Majora
  if (forcedPiece && forcedPiece.maskSprite) {
    forcedPiece.maskSprite.destroy();
  }
  forcedPiece = null;
  
  // reset ocarinas (cavaliers)
  for (const kp of knightPieces) {
    if (kp.ocarinaSprite) kp.ocarinaSprite.destroy();
  }
  knightPieces = [];
  infoText.setText("");
  // cacher widget d'option timer s'il existe c√¥t√© Phaser
  if (playerCountBtns && playerCountBtns.length) { playerCountBtns.forEach(b => b && b.setVisible(false)); }
  // cacher l'UI de draft
  choiceButtons.forEach(btn => btn.setVisible(false));
  if (endDraftBtn) endDraftBtn.setVisible(false);
  if (choiceThumbs && choiceThumbs.length) {
    choiceThumbs.forEach(entry => {
      entry.image.setVisible(false);
      entry.nameText.setVisible(false);
      entry.costText.setVisible(false);
    });
  }
  if (clearAllBtn) clearAllBtn.setVisible(false);
  // cacher l'aper√ßu des √©quipes pendant la partie
  if (armyLabels && armyLabels.length) {
    armyLabels.forEach(lbl => lbl && lbl.setVisible(false));
  }
  if (armyThumbs && armyThumbs.length) {
    armyThumbs.forEach(list => list.forEach(img => img && img.setVisible(false)));
  }
  if (armyPanels && armyPanels.length) {
    armyPanels.forEach(r => r && r.setVisible(false));
  }
  if (armyHints && armyHints.length) {
    armyHints.forEach(t => t && t.setVisible(false));
  }

  // cr√©er la grille
  for (let y=0; y<GRID_SIZE; y++) {
    grid[y] = [];
    for (let x=0; x<GRID_SIZE; x++) {
      const baseColor = (x+y)%2===0 ? 0xffffff : 0xcccccc;
      const rect = scene.add.rectangle(
        GRID_OFFSET_X + x*TILE_SIZE + TILE_SIZE/2,
        GRID_OFFSET_Y + y*TILE_SIZE + TILE_SIZE/2,
        TILE_SIZE-2, TILE_SIZE-2,
        baseColor
      ).setStrokeStyle(1,0x000000).setInteractive();
      rect.baseColor = baseColor;
      rect.pos = {x,y};
      rect.on('pointerdown', () => handleClick(scene, rect.pos));
      grid[y][x] = rect;
    }
  }

  // Placer les caisses d'objets selon la taille de grille
  itemCrates = [];
  const cratePositions = [];
  if (GRID_SIZE === 9) {
    const cx = Math.floor(GRID_SIZE/2);
    const cy = Math.floor(GRID_SIZE/2);
    cratePositions.push({ x: cx, y: cy });
  } else if (GRID_SIZE === 11) {
    // Positions demand√©es (1-based): [5,5], [5,7], [7,5], [7,7]
    // Conversion 0-based:
    cratePositions.push({ x: 4, y: 4 }, { x: 4, y: 6 }, { x: 6, y: 4 }, { x: 6, y: 6 });
  } else if (GRID_SIZE === 15) {
    // Positions demand√©es (1-based): [6,6], [6,10], [8,8], [10,6], [10,10]
    // Conversion 0-based:
    cratePositions.push({ x: 5, y: 5 }, { x: 5, y: 9 }, { x: 7, y: 7 }, { x: 9, y: 5 }, { x: 9, y: 9 });
  }
  for (const pos of cratePositions) {
    const sprite = scene.add.image(0,0,'item-crate');
    sprite.setDisplaySize(TILE_SIZE*0.6, TILE_SIZE*0.6);
    sprite.setAlpha(1);
    itemCrates.push({ x: pos.x, y: pos.y, sprite, active: true, lastRound: roundCounter });
  }

  // Helpers placement
  const getPlayerSide = (index) => {
    if (index === 0) return 'top';
    if (index === 1) return 'bottom';
    if (index === 2) return 'left';
    return 'right';
  };
  const mid = getKingCenterIndex(GRID_SIZE);

  const getBlockSlotsForSide = (side) => {
    // G√©n√©rer une spirale en coordonn√©es locales (autour de 0,0) puis mapper vers la grille
    let minDX, maxDX, minDY, maxDY;
    if (side === 'top' || side === 'bottom') {
      minDX = -2; maxDX = 2; minDY = 0; maxDY = 3; // 5x4
    } else { // left / right
      minDX = 0; maxDX = 3; minDY = -2; maxDY = 2; // 4x5
    }
    const area = (maxDX - minDX + 1) * (maxDY - minDY + 1);
    const needed = area - 1; // case du roi exclue

    const dirs = [ [1,0], [0,1], [-1,0], [0,-1] ]; // droite, bas, gauche, haut
    let stepLen = 1;
    let dirIndex = 0;
    let lx = 0, ly = 0; // coords locales
    const offsets = [];
    while (offsets.length < needed && stepLen < 100) {
      for (let repeat = 0; repeat < 2; repeat++) {
        const [dxStep, dyStep] = dirs[dirIndex];
        for (let s = 0; s < stepLen; s++) {
          lx += dxStep; ly += dyStep;
          if (lx >= minDX && lx <= maxDX && ly >= minDY && ly <= maxDY && !(lx === 0 && ly === 0)) {
            offsets.push({ dx: lx, dy: ly });
            if (offsets.length >= needed) break;
          }
        }
        dirIndex = (dirIndex + 1) % 4;
        if (offsets.length >= needed) break;
      }
      stepLen++;
    }

    // Map vers les coordonn√©es grille selon le c√¥t√©
    const slots = [];
    if (side === 'top') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: 0 + o.dy });
    } else if (side === 'bottom') {
      for (const o of offsets) slots.push({ x: mid + o.dx, y: GRID_SIZE - 1 - o.dy });
    } else if (side === 'left') {
      for (const o of offsets) slots.push({ x: 0 + o.dx, y: mid + o.dy });
    } else if (side === 'right') {
      for (const o of offsets) slots.push({ x: GRID_SIZE - 1 - o.dx, y: mid + o.dy });
    }
    return slots;
  };

  // 1) Placer les rois par faction au centre exact du bord
  players.forEach((p,i) => {
    const side = getPlayerSide(i);
    let pos = { x: mid, y: 0 };
    if (side === 'top') pos = { x: mid, y: 0 };
    if (side === 'bottom') pos = { x: mid, y: GRID_SIZE - 1 };
    if (side === 'left') pos = { x: 0, y: mid };
    if (side === 'right') pos = { x: GRID_SIZE - 1, y: mid };
    const kingKey = (kings[p.faction] && kings[p.faction].key) ? kings[p.faction].key : 'nintendo';
    const spr = scene.add.image(0,0,kingKey);
    pieces.push({ sprite: spr, type: 'king', x: pos.x, y: pos.y, player: p.id });
  });

  // 2) Placer les autres pi√®ces en partant du bord propre √† chaque joueur
  // Trier par force: faible < moyen < fort < unique
  const getPieceTier = (charKey, faction) => {
    const catalog = getCatalogForFaction(faction);
    const entry = catalog[charKey];
    if (!entry) return 1; // par d√©faut faible
    
    // Utiliser la propri√©t√© tier d√©finie dans le catalogue
    return entry.tier || 1; // 1=faible, 2=moyen, 3=fort, 4=unique
  };
  
  players.forEach((p,i) => {
    const side = getPlayerSide(i);
    const slots = getBlockSlotsForSide(side);
    
    // Trier l'arm√©e par force (plus fort = plus proche du roi)
    const sortedArmy = [...p.army].sort((a, b) => {
      const tierA = getPieceTier(a, p.faction);
      const tierB = getPieceTier(b, p.faction);
      return tierB - tierA; // d√©croissant: fort vers faible
    });
    
    let si = 0;
    sortedArmy.forEach((charKey) => {
      // avancer jusqu'√† trouver un slot libre
      while (si < slots.length && getPieceAt(slots[si])) si++;
      if (si >= slots.length) return; // plus de place dans le bloc
      const pos = slots[si];
      const spr = scene.add.image(0,0,charKey);
      pieces.push({ sprite: spr, type: charKey, x: pos.x, y: pos.y, player: p.id });
      si++;
    });
  });

  updatePieces();
  // Bandeau "D√©but de la partie" en haut de la grille
  const startText = scene.add.text(GRID_OFFSET_X + (GRID_SIZE*TILE_SIZE)/2, GRID_OFFSET_Y - 26, "D√©but de la partie !", { font: "20px Arial", fill: "#000", backgroundColor: "#fff" })
    .setOrigin(0.5, 0)
    .setDepth(2000);
  scene.time.delayedCall(1500, () => { startText.destroy(); });

  // Timers: init par taille
  const baseMinutes = (GRID_SIZE === 9) ? 5 : (GRID_SIZE === 11) ? 10 : 15;
  playerTimersMs = players.map(() => baseMinutes * 60 * 1000);
  // Cr√©er/mettre √† jour les textes timers pr√®s des noms
  if (timerTexts.length) { timerTexts.forEach(t => t && t.destroy()); }
  timerTexts = players.map((p,i) => {
    const nameText = playerNameTexts[i];
    const t = scene.add.text(0,0, formatMs(playerTimersMs[i]), { font: "14px Arial", fill: "#333", backgroundColor: "#fff" }).setDepth(1600);
    positionTimerTextNearName(t, nameText);
    return t;
  });
  // Lancer tick si activ√©
  if (timerEvent) timerEvent.remove(false);
  if (timerEnabled) {
    timerEvent = scene.time.addEvent({ delay: 250, loop: true, callback: () => tickTimer(scene) });
  }

  // Textes des noms des joueurs hors de la grille
  playerNameTexts.forEach(t => t && t.destroy());
  playerNameTexts = [];
  const midNames = getKingCenterIndex(GRID_SIZE);
  const margin = 12;
  players.forEach((p,i) => {
    const side = (i===0)?'top':(i===1)?'bottom':(i===2)?'left':'right';
    let nx = 0, ny = 0;
    if (side === 'top') { nx = GRID_OFFSET_X + midNames*TILE_SIZE + TILE_SIZE/2; ny = GRID_OFFSET_Y - 20; }
    if (side === 'bottom') { nx = GRID_OFFSET_X + midNames*TILE_SIZE + TILE_SIZE/2; ny = GRID_OFFSET_Y + GRID_SIZE*TILE_SIZE + 20; }
    if (side === 'left') { nx = GRID_OFFSET_X - 20; ny = GRID_OFFSET_Y + midNames*TILE_SIZE + TILE_SIZE/2; }
    if (side === 'right') { nx = GRID_OFFSET_X + GRID_SIZE*TILE_SIZE + 20; ny = GRID_OFFSET_Y + midNames*TILE_SIZE + TILE_SIZE/2; }
    const tintColor = brandTints[p.faction || 'nintendo'] || 0x000000;
    const factionLabel = getFactionDisplayName(p.faction || 'nintendo');
    const label = `${p.name} (${factionLabel})`;
    const txt = scene.add.text(nx, ny, label, { font: "18px Arial", fill: `#${tintColor.toString(16).padStart(6,'0')}` }).setOrigin(0.5);
    if (side === 'left') txt.setAngle(-90);
    if (side === 'right') txt.setAngle(90);
    txt.setDepth(1500);
    playerNameTexts.push(txt);
  });

  // Indicateur de tour (ic√¥ne)
  if (turnIcon) { turnIcon.destroy(); }
  turnIcon = scene.add.text(0,0,"üéÆ", { font: "22px Arial" }).setDepth(2000);
  updateTurnUI();
  updateRulesSidebar();
}

function savePreset() {
  try {
    const preset = {
      gridSize: GRID_SIZE,
      players: players.map(p => ({ name: p.name, faction: p.faction }))
    };
    localStorage.setItem('vgb_preset', JSON.stringify(preset));
  } catch(e) {}
}

function loadPresetAndStart(scene) {
  try {
    const raw = localStorage.getItem('vgb_preset');
    if (!raw) return false;
    const preset = JSON.parse(raw);
    if (!preset || !preset.gridSize || !Array.isArray(preset.players) || preset.players.length < 2) return false;
    GRID_SIZE = preset.gridSize;
    const available = 900 - 2*GRID_OFFSET_Y;
    TILE_SIZE = Math.floor(available / GRID_SIZE);
    players = preset.players.map((pp, i) => ({ id: i, points: 20, army: [], name: pp.name || `Joueur ${i+1}`, faction: pp.faction || 'nintendo' }));
    currentPlayer = 0;
    setupDraftUI(scene);
    updateDraftUI();
    return true;
  } catch(e) { return false; }
}

function updatePieces() {
  for (let p of pieces) {
    p.sprite.x = GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2;
    p.sprite.y = GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2;
    // ajuster la taille pour remplir la case moins une marge de bordure
    const targetSize = TILE_SIZE; // utiliser toute la case
    p.sprite.setDisplaySize(targetSize, targetSize);
    // Forcer une mise √† l'√©chelle enti√®re pour √©viter tout flou sous-pixel
    p.sprite.setOrigin(0.5, 0.5);
    // s'assurer que les pi√®ces restent au-dessus des overlays
    if (typeof p.sprite.setDepth === 'function') p.sprite.setDepth(1000);
    if (p.sprite.texture && p.sprite.texture.setFilter) p.sprite.texture.setFilter(Phaser.Textures.FilterMode.LINEAR);
  }
  if (itemCrates && itemCrates.length) {
    for (const c of itemCrates) {
      if (c.sprite) {
        c.sprite.x = GRID_OFFSET_X + c.x*TILE_SIZE + TILE_SIZE/2;
        c.sprite.y = GRID_OFFSET_Y + c.y*TILE_SIZE + TILE_SIZE/2;
      }
    }
  }
  // Portails: positionner leurs sprites si pr√©sents
  const scene = infoText && infoText.scene;
  if (portalOrange && portalOrange.sprite) {
    portalOrange.sprite.x = GRID_OFFSET_X + portalOrange.x*TILE_SIZE + TILE_SIZE/2;
    portalOrange.sprite.y = GRID_OFFSET_Y + portalOrange.y*TILE_SIZE + TILE_SIZE/2;
    portalOrange.sprite.setDisplaySize(TILE_SIZE*0.8, TILE_SIZE*0.8);
    portalOrange.sprite.setAlpha(1);
  }
  if (portalBlue && portalBlue.sprite) {
    portalBlue.sprite.x = GRID_OFFSET_X + portalBlue.x*TILE_SIZE + TILE_SIZE/2;
    portalBlue.sprite.y = GRID_OFFSET_Y + portalBlue.y*TILE_SIZE + TILE_SIZE/2;
    portalBlue.sprite.setDisplaySize(TILE_SIZE*0.8, TILE_SIZE*0.8);
    portalBlue.sprite.setAlpha(1);
  }
  // Curseurs Sims: positionner les curseurs au-dessus des pi√®ces poss√©d√©es
  for (const pp of possessedPieces) {
    if (pp.cursorSprite && pp.piece) {
      pp.cursorSprite.x = GRID_OFFSET_X + pp.piece.x * TILE_SIZE + TILE_SIZE/2 + 15;
      pp.cursorSprite.y = GRID_OFFSET_Y + pp.piece.y * TILE_SIZE + TILE_SIZE/2 - 20;
    }
  }
  // Effet √©toile: afficher un overlay d√©grad√© sous les pi√®ces prot√©g√©es
  if (starInvincible && starInvincible.playerId >= 0 && scene) {
    updateStarOverlays(scene);
      } else {
    clearStarOverlays();
    for (const p of pieces) if (p.sprite) { p.sprite.clearTint && p.sprite.clearTint(); p.sprite.setAlpha && p.sprite.setAlpha(1); }
  }
  // positionner les ic√¥nes d'objets √† c√¥t√© des noms
  if (playerItemIcons.length) {
    for (let i=0; i<playerItemIcons.length; i++) {
      const entries = playerItemIcons[i] || [];
      const nameText = playerNameTexts[i];
      if (nameText && entries.length) {
        const side = (i===0)?'top':(i===1)?'bottom':(i===2)?'left':'right';
        for (let k=0; k<entries.length; k++) {
          const e = entries[k];
          if (e && e.sprite) {
            // Positionnement selon le c√¥t√© du joueur
            if (side === 'top') {
              // Joueur du haut : objets √† droite du nom, align√©s horizontalement
              e.sprite.x = nameText.x + 38 + k*25;
              e.sprite.y = nameText.y - 20;
            } else if (side === 'bottom') {
              // Joueur du bas : objets en dessous du nom, align√©s horizontalement
              e.sprite.x = nameText.x + 38 + k*25;
              e.sprite.y = nameText.y + 20;
            } else if (side === 'left') {
              // Joueur de gauche : objets √† gauche du nom, align√©s verticalement
              e.sprite.x = nameText.x - nameText.displayWidth - 30;
              e.sprite.y = nameText.y - nameText.displayHeight/2 + 15 + k*25;
            } else { // right
              // Joueur de droite : objets √† droite du nom, align√©s verticalement
              e.sprite.x = nameText.x + nameText.displayWidth + 30;
              e.sprite.y = nameText.y - nameText.displayHeight/2 + 15 + k*25;
            }
            e.sprite.setAngle(0); // pas de rotation pour les objets
            
            // overlay du compteur pour lightning
            if (e.item === 'lightning') {
              if (!e.counterText) {
                e.counterText = nameText.scene.add.text(0,0, '', { font: '12px Arial', fill: '#000', backgroundColor: '#fff' }).setDepth(2001);
              }
              const txt = (e.chargeTurns && e.chargeTurns > 0) ? String(e.chargeTurns) : '';
              e.counterText.setText(txt);
              e.counterText.x = e.sprite.x + 10;
              e.counterText.y = e.sprite.y - 10;
              e.sprite.setAlpha((e.chargeTurns && e.chargeTurns > 0) ? 0.6 : 1);
            } else if (e.counterText) {
              e.counterText.destroy();
              e.counterText = null;
            }
          }
        }
      }
    }
  }
  
  // Nettoyer les compteurs orphelins (compteurs sans sprite associ√©)
  cleanupOrphanedCounters();
  // Mettre √† jour les positions des c≈ìurs
  updateHeartPositions();
  // Mettre √† jour la position du masque de Majora
  updateMaskPosition();
  // Mettre √† jour les positions des ocarinas
  updateOcarinaPositions();
  updateRulesSidebar();
}

function startStarBlink(playerId) {
  // Initialiser la phase de l'effet et s'assurer que la texture arc-en-ciel existe
  starPhase = 0;
  if (infoText && infoText.scene) {
    ensureRainbowTileTexture(infoText.scene);
  }
}

function stopStarBlink(playerId) {
  // Nettoyer imm√©diatement l‚Äôeffet visuel pour ce joueur
  for (const p of pieces) {
    if (p.player === playerId && p.sprite) {
      p.sprite.clearTint();
      p.sprite.setAlpha(1);
    }
  }
}

function ensureRainbowTileTexture(scene) {
  const key = 'rainbow-tile';
  const size = Math.max(1, TILE_SIZE - 2);
  const existing = scene.textures.exists(key) ? scene.textures.get(key) : null;
  if (existing && existing.source[0] && existing.source[0].width === size && existing.source[0].height === size) return key;
  if (existing) scene.textures.remove(key);
  const tex = scene.textures.createCanvas(key, size, size);
  const ctx = tex.getContext();
  const grd = ctx.createLinearGradient(0, 0, size, size);
  grd.addColorStop(0.00, '#ff0040');
  grd.addColorStop(0.20, '#ff8000');
  grd.addColorStop(0.40, '#ffee00');
  grd.addColorStop(0.60, '#00dd55');
  grd.addColorStop(0.80, '#00aaff');
  grd.addColorStop(1.00, '#7a00ff');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, size, size);
  tex.refresh();
  return key;
}

function updateStarOverlays(scene) {
  if (!starInvincible || starInvincible.playerId < 0) { clearStarOverlays(); return; }
  const key = ensureRainbowTileTexture(scene);
  const desired = new Set();
  
  // Animation de l'effet arc-en-ciel
  starPhase += 0.1;
  const hue = (starPhase * 50) % 360;
  
  for (const p of pieces) {
    if (p.player === starInvincible.playerId) {
      const k = p.x + ',' + p.y;
      desired.add(k);
      if (!starTileOverlays.has(k)) {
        const img = scene.add.image(
          GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2,
          GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2,
          key
        );
        img.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
        img.setDepth(900); // sous la pi√®ce, au-dessus de la case
        img.setAlpha(0.85);
        starTileOverlays.set(k, img);
      } else {
        const img = starTileOverlays.get(k);
        img.x = GRID_OFFSET_X + p.x*TILE_SIZE + TILE_SIZE/2;
        img.y = GRID_OFFSET_Y + p.y*TILE_SIZE + TILE_SIZE/2;
        img.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
        // Appliquer l'effet de couleur arc-en-ciel
        img.setTint(Phaser.Display.Color.HSVToRGB(hue/360, 0.8, 1).color);
      }
    }
  }
  // supprimer overlays non d√©sir√©s
  for (const [k, img] of Array.from(starTileOverlays.entries())) {
    if (!desired.has(k)) {
      if (img && img.destroy) img.destroy();
      starTileOverlays.delete(k);
    }
  }
}

function clearStarOverlays() {
  for (const [, img] of Array.from(starTileOverlays.entries())) {
    if (img && img.destroy) img.destroy();
  }
  starTileOverlays.clear();
}

function cleanupOrphanedCounters() {
  // Nettoyer les compteurs de lightning orphelins (sans sprite associ√©)
  for (let i=0; i<playerItemIcons.length; i++) {
    const entries = playerItemIcons[i] || [];
    for (let k=0; k<entries.length; k++) {
      const e = entries[k];
      if (e && e.counterText && (!e.sprite || e.sprite.destroyed)) {
        // Le sprite n'existe plus ou est d√©truit, supprimer le compteur
        e.counterText.destroy();
        e.counterText = null;
      }
    }
  }
}

function placePortal(color, pos) {
  const scene = infoText.scene;
  if (color === 'orange') {
    if (portalOrange && portalOrange.sprite) portalOrange.sprite.destroy();
    const spr = scene.add.image(0,0,'portal-orange');
    portalOrange = { x: pos.x, y: pos.y, sprite: spr };
  } else {
    if (portalBlue && portalBlue.sprite) portalBlue.sprite.destroy();
    const spr = scene.add.image(0,0,'portal-blue');
    portalBlue = { x: pos.x, y: pos.y, sprite: spr };
  }
}

function handleClick(scene, pos) {
  if (!gameStarted) return;
  
  // Emp√™cher les joueurs √©limin√©s de jouer
  if (eliminationOrder.includes(currentPlayer)) {
    currentPlayer = getNextActivePlayer();
    updateTurnUI();
    return;
  }
  
  const clickedPiece = getPieceAt(pos);
  // Si un item est actif (ex: bombe), g√©rer l'effet et retourner
  if (currentItemAction && currentItemAction.active && currentItemAction.playerId === currentPlayer) {
    if (currentItemAction.type === 'bomb') {
      // Limite de placement: √† <=3 cases d'une pi√®ce du joueur
      const canPlace = canPlaceBombAt(pos, currentPlayer);
      if (!canPlace) return;
      detonateBombAt(pos);
      const bombInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null; // sortir du mode pose de bombe
      itemUsedThisTurn = true;
      clearHighlights(); // retirer l'indicateur de placement
      // consommer l'item bombe s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof bombInventoryIndex === 'number') ? bombInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'bobomb');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'portal_orange' && currentItemAction.stage === 'orange') {
      if (getPieceAt(pos)) return; // doit √™tre vide
      placePortal('orange', pos);
      currentItemAction.type = 'portal_blue';
      currentItemAction.stage = 'blue';
      if (infoText) infoText.setText(`Joueur ${currentPlayer+1}: placez le portail BLEU`);
      const allowed = getAllEmptyCells();
      highlightPositions(allowed, 0x90caf9); // bleu p√¢le
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'portal_blue' && currentItemAction.stage === 'blue') {
      if (getPieceAt(pos)) return; // doit √™tre vide
      placePortal('blue', pos);
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      // consommer l'item portals s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (currentItemAction && typeof currentItemAction.inventoryIndex === 'number') ? currentItemAction.inventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'portals');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'tetrimino') {
      // V√©rifier si le tetrimino peut √™tre plac√© √† cette position
      if (!canPlaceTetriminoAt(pos.x, pos.y)) return;
      placeTetrimino(pos);
      const tetriminoInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      // consommer l'item tetrimino s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof tetriminoInventoryIndex === 'number') ? tetriminoInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'tetrimino');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'tornado') {
      // V√©rifier si le roi peut √™tre t√©l√©port√© √† cette position
      if (!canTeleportKingTo(pos.x, pos.y)) return;
      teleportKingTo(currentPlayer, pos);
      const tornadoInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      // consommer l'item tornado s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof tornadoInventoryIndex === 'number') ? tornadoInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'tornado');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'banana') {
      // V√©rifier si la banane peut √™tre plac√©e √† cette position
      if (!canPlaceBananaAt(pos.x, pos.y)) return;
      placeBanana(pos);
      const bananaInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      // consommer l'item banane s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof bananaInventoryIndex === 'number') ? bananaInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'banana');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'cursor') {
      // V√©rifier si une pi√®ce peut √™tre poss√©d√©e √† cette position
      const targetPiece = getPieceAt(pos);
      if (!targetPiece || !canPossessPiece(targetPiece, currentPlayer)) return;
      possessPiece(targetPiece, currentPlayer);
      const cursorInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights(); // Effacer le fond vert p√¢le
      hideInfoMessage();
      // consommer l'item curseur s√©lectionn√©
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof cursorInventoryIndex === 'number') ? cursorInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'cursor');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'heart') {
      // V√©rifier si une pi√®ce est cliqu√©e
      if (!clickedPiece) return;
      
      // Donner un c≈ìur √† la pi√®ce
      giveHeartToPiece(clickedPiece);
      const heartInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      
      // Consommer l'item c≈ìur
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof heartInventoryIndex === 'number') ? heartInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'heart');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'mask') {
      // V√©rifier si une pi√®ce adverse est cliqu√©e
      if (!clickedPiece || clickedPiece.player === currentPlayer) return;
      
      // Appliquer le masque de Majora √† la pi√®ce adverse
      applyMaskToPiece(clickedPiece);
      const maskInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      
      // Consommer l'item masque
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof maskInventoryIndex === 'number') ? maskInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'mask');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
    if (currentItemAction.type === 'ocarina') {
      // V√©rifier si une pi√®ce est cliqu√©e
      if (!clickedPiece) return;
      
      // Appliquer l'Ocarina du Temps √† la pi√®ce
      applyOcarinaToPiece(clickedPiece);
      const ocarinaInventoryIndex = currentItemAction.inventoryIndex;
      currentItemAction.active = false;
      currentItemAction = null;
      itemUsedThisTurn = true;
      clearHighlights();
      hideInfoMessage();
      
      // Consommer l'item ocarina
      if (playerItemIcons[currentPlayer] && playerItemIcons[currentPlayer].length) {
        const useIdx = (typeof ocarinaInventoryIndex === 'number') ? ocarinaInventoryIndex : playerItemIcons[currentPlayer].findIndex(e => e && e.item === 'ocarina');
        if (useIdx >= 0) {
          const used = playerItemIcons[currentPlayer].splice(useIdx, 1)[0];
          if (used && used.sprite) used.sprite.destroy();
        }
      }
      updatePieces();
      return;
    }
  }

  // Si le joueur a une pi√®ce forc√©e, emp√™cher la s√©lection d'autres pi√®ces
  if (forcedPiece && forcedPiece.playerId === currentPlayer && forcedPiece.piece && clickedPiece && clickedPiece !== forcedPiece.piece) {
    showInfoMessage(`Vous √™tes forc√© de jouer cette pi√®ce par le Masque de Majora !`, 3000);
    return;
  }
  
  // S√©lection d'une pi√®ce du joueur courant (y compris les pi√®ces poss√©d√©es qui restent contr√¥l√©es par leur joueur d'origine)
  if (clickedPiece && clickedPiece.player === currentPlayer) {
    selectedPiece = clickedPiece;
    const reachable = getReachablePositions(selectedPiece);
    highlightPositions(reachable);
    return;
  }

  // D√©placement si une pi√®ce est s√©lectionn√©e et la case est atteignable
  if (selectedPiece) {
    const reachable = getReachablePositions(selectedPiece);
    const isReachable = reachable.some(p => p.x === pos.x && p.y === pos.y);
    if (isReachable) {
      // Capture √©ventuelle sur la case cible
      const target = getPieceAt(pos);
      if (target && target.player !== selectedPiece.player) {
        // Protection √©toile: impossible de capturer si la cible est prot√©g√©e
        if (starInvincible && starInvincible.playerId === target.player && starInvincible.untilPlayerTurn) {
          // annuler la capture
          return;
        }
        const capturedKing = target.type === 'king';
        
        // V√©rifier si la pi√®ce cible a un c≈ìur
        const hasHeart = heartPieces.some(hp => hp.piece === target);
        if (hasHeart) {
          // La pi√®ce a un c≈ìur : elle reste en place mais perd son c≈ìur
          removeHeartFromPiece(target);
          showInfoMessage(`La pi√®ce a perdu son c≈ìur !`, 2000);
          // La pi√®ce reste en place, pas de capture
        } else {
          // Pas de c≈ìur : capture normale
          // Enregistrer la pi√®ce perdue pour la queue de phoenix
          playerLostPieces.push({ playerId: target.player, piece: { ...target } });
          // Nettoyer l'exposant du curseur Sims si la pi√®ce √©tait poss√©d√©e
          cleanupCursorForPiece(target);
          // Nettoyer l'ocarina si la pi√®ce en avait un
          removeOcarinaFromPiece(target);
          target.sprite.destroy();
          pieces = pieces.filter(p => p !== target);
        }
        // V√©rifier si la pi√®ce tr√©buche sur une banane
        if (checkBananaTrip(selectedPiece, pos)) {
          // La pi√®ce tr√©buche, elle est d√©plac√©e sur la case de la banane
          updatePieces();
          clearHighlights();
          selectedPiece = null;
          // Terminer le tour et passer au joueur suivant
          moveCount++;
          if (moveCount % 5 === 0) rotateAds();
          currentPlayer = getNextActivePlayer(); // changer de joueur en sautant les √©limin√©s
          updateTurnUI();
          return;
        }
        // D√©placer la pi√®ce du joueur sur la case captur√©e
        selectedPiece.x = pos.x;
        selectedPiece.y = pos.y;
        // R√©cup√©ration de la caisse
        maybePickupItem(selectedPiece);
        updatePieces();
        clearHighlights();
        selectedPiece = null;
        // Gestion √©limination et condition de fin
        if (capturedKing) {
          if (!eliminationOrder.includes(target.player)) {
            eliminationOrder.push(target.player);
            
            // Supprimer TOUTES les pi√®ces du joueur √©limin√©
            const eliminatedPlayerId = target.player;
            const piecesToRemove = pieces.filter(p => p.player === eliminatedPlayerId);
            
            for (const piece of piecesToRemove) {
              // Nettoyer les √©l√©ments associ√©s avant suppression
              cleanupCursorForPiece(piece);
              removeHeartFromPiece(piece);
              removeOcarinaFromPiece(piece);
              if (piece.sprite) piece.sprite.destroy();
            }
            
            // Retirer toutes les pi√®ces du joueur √©limin√© du tableau pieces
            pieces = pieces.filter(p => p.player !== eliminatedPlayerId);
            
            // Annoncer l'√©limination du joueur
            const eliminatedPlayer = players[eliminatedPlayerId];
            showInfoMessage(`‚öîÔ∏è ${eliminatedPlayer.name} a √©t√© √©limin√© ! Toutes ses pi√®ces ont disparu.`, 3000);
          }
          const remainingKings = pieces.filter(pp => pp.type === 'king').length;
          if (remainingKings <= 1) {
            // d√©terminer le vainqueur (roi encore vivant)
            let winnerId = null;
            const kingPiece = pieces.find(pp => pp.type === 'king');
            if (kingPiece) winnerId = kingPiece.player;
            // construire classement
            let ranking = [];
            if (winnerId !== null) ranking.push(winnerId);
            const rest = eliminationOrder.slice().reverse();
            for (let pid of rest) {
              if (winnerId === null || pid !== winnerId) ranking.push(pid);
            }
            endGameWithRanking(ranking);
          return;
        }
        }
        moveCount++;
        if (moveCount % 5 === 0) rotateAds();
        updateAdInfo();
        
        // Supprimer le masque de Majora si la pi√®ce forc√©e a √©t√© jou√©e
        if (forcedPiece && forcedPiece.piece === selectedPiece) {
          if (forcedPiece.maskSprite) {
            forcedPiece.maskSprite.destroy();
          }
          forcedPiece = null;
        }
        
        // fin de tour
        let oldRound = roundCounter;
        if (shouldIncrementRoundCounter()) { roundCounter++; }
        currentPlayer = getNextActivePlayer(); // changer de joueur en sautant les √©limin√©s
        if (roundCounter !== oldRound) {
          decrementLightningCharges();
          // L'effet √©toile est maintenant g√©r√© dans updateTurnUI()
        }
        itemUsedThisTurn = false;
        maybeRespawnCrate(scene);
        updateTurnUI();
        // repositionner tous les timers
        if (timerTexts && playerNameTexts) {
          for (let i=0;i<timerTexts.length;i++) {
            if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
          }
        }
        return;
      }
      // V√©rifier si la pi√®ce tr√©buche sur une banane
      if (checkBananaTrip(selectedPiece, pos)) {
        // La pi√®ce tr√©buche, elle est d√©plac√©e sur la case de la banane
        updatePieces();
        clearHighlights();
        
        // Supprimer le masque de Majora si la pi√®ce forc√©e a √©t√© jou√©e
        if (forcedPiece && forcedPiece.piece === selectedPiece) {
          if (forcedPiece.maskSprite) {
            forcedPiece.maskSprite.destroy();
          }
          forcedPiece = null;
        }
        
        selectedPiece = null;
        // Terminer le tour et passer au joueur suivant
        moveCount++;
        if (moveCount % 5 === 0) rotateAds();
        currentPlayer = getNextActivePlayer(); // changer de joueur en sautant les √©limin√©s
        updateTurnUI();
        return;
      }
      // Case vide
      selectedPiece.x = pos.x;
      selectedPiece.y = pos.y;
      // R√©cup√©ration de la caisse
      maybePickupItem(selectedPiece);
      updatePieces();
      clearHighlights();
      
      // Supprimer le masque de Majora si la pi√®ce forc√©e a √©t√© jou√©e
      if (forcedPiece && forcedPiece.piece === selectedPiece) {
        if (forcedPiece.maskSprite) {
          forcedPiece.maskSprite.destroy();
        }
        forcedPiece = null;
      }
      
      selectedPiece = null;
      moveCount++;
      if (moveCount % 5 === 0) rotateAds();
      updateAdInfo();
      // fin de tour
      let oldRound = roundCounter;
      if (shouldIncrementRoundCounter()) { roundCounter++; }
      currentPlayer = getNextActivePlayer(); // changer de joueur en sautant les √©limin√©s
      // d√©cr√©menter les charges uniquement quand un round complet vient de s'achever
      if (roundCounter !== oldRound) {
        decrementLightningCharges();
        // L'effet √©toile est maintenant g√©r√© dans updateTurnUI()
      }
      itemUsedThisTurn = false;
      maybeRespawnCrate(scene);
      updateTurnUI();
      // repositionner tous les timers
      if (timerTexts && playerNameTexts) {
        for (let i=0;i<timerTexts.length;i++) {
          if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
        }
      }
    } else {
      // Clic non valide: nettoyer la s√©lection pour √©viter la confusion
      clearHighlights();
      selectedPiece = null;
    }
  }
}

function isValidMove(piece, pos) {
  const reachable = getReachablePositions(piece);
  return reachable.some(p => p.x === pos.x && p.y === pos.y);
}

function getPieceAt(pos) {
  return pieces.find(p => p.x === pos.x && p.y === pos.y);
}

function getReachablePositions(piece) {
  const positions = [];
  const rule = getRuleForPiece(piece);
  
  // V√©rifier si la pi√®ce est poss√©d√©e et limiter ses mouvements √† sa "maison"
  const possessed = possessedPieces.find(pp => pp.piece === piece);
  if (possessed) {
    // Limiter les mouvements aux limites de la maison
    const houseBounds = possessed.houseBounds;
    const iterateFrom = (startX, startY, dir, maxSteps, usedTeleport) => {
      for (let step = 1; step <= maxSteps; step++) {
        const nx = startX + dir[0] * step;
        const ny = startY + dir[1] * step;
        
        // V√©rifier les limites de la maison
        if (nx < houseBounds.startX || nx > houseBounds.endX || 
            ny < houseBounds.startY || ny > houseBounds.endY) {
          break; // Sortir des limites de la maison
        }
        
        const occ = getPieceAt({ x: nx, y: ny });
        if (occ && occ.player === piece.player) break; // Pi√®ce alli√©e
        if (occ && occ.player !== piece.player) {
          // V√©rifier protection √©toile
          if (starInvincible && starInvincible.playerId === occ.player && starInvincible.untilPlayerTurn) {
            continue; // Pi√®ce prot√©g√©e, continuer
          }
          positions.push({ x: nx, y: ny }); // Capturer
          break;
        }
        positions.push({ x: nx, y: ny }); // Case vide
      }
    };
    
    // Appliquer les mouvements selon les r√®gles
    for (const dir of rule.moves) {
      iterateFrom(piece.x, piece.y, dir, rule.range, false);
    }
    
    return positions;
  }

  const isPortalPos = (x, y, color) => {
    if (color === 'orange' && portalOrange) return portalOrange.x === x && portalOrange.y === y;
    if (color === 'blue' && portalBlue) return portalBlue.x === x && portalBlue.y === y;
    return false;
  };

  const isTetriminoPos = (x, y) => {
    return tetriminos.some(t => t.x === x && t.y === y);
  };

  const iterateFrom = (startX, startY, dir, maxSteps, usedTeleport) => {
    for (let step = 1; step <= maxSteps; step++) {
      const nx = startX + dir[0] * step;
      const ny = startY + dir[1] * step;
      if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) break;
      
      // V√©rifier si la case contient un tetrimino (mur)
      if (isTetriminoPos(nx, ny)) {
        // Les cavaliers peuvent sauter par-dessus les tetriminos
        // Un cavalier se d√©place en L (2+1 ou 1+2), donc range = 1 et step = 1
        const isKnightMove = (rule.range === 1 && step === 1 && 
          (Math.abs(dir[0]) === 2 && Math.abs(dir[1]) === 1) || 
          (Math.abs(dir[0]) === 1 && Math.abs(dir[1]) === 2));
        
        if (isKnightMove) {
          continue; // continuer le mouvement (sauter par-dessus)
        } else {
          break; // s'arr√™ter pour les autres pi√®ces
        }
      }
      
      const occ = getPieceAt({ x: nx, y: ny });

      // Portail: si on touche ORANGE et BLUE existe, on permet de poursuivre depuis BLUE
      if (!usedTeleport && isPortalPos(nx, ny, 'orange') && portalBlue) {
        // On peut s'arr√™ter sur orange si vide
        if (!occ) positions.push({ x: nx, y: ny });
        // Calculer pas restants apr√®s avoir atteint orange
        const remaining = maxSteps - step;
        // Si la case BLEUE est occup√©e
        const occBlue = getPieceAt({ x: portalBlue.x, y: portalBlue.y });
        if (occBlue) {
        // Si ennemi: on peut capturer BLEU puis on s'arr√™te (si pas prot√©g√© par √©toile)
        if (occBlue.player !== piece.player && !(starInvincible && starInvincible.playerId === occBlue.player && starInvincible.untilPlayerTurn)) {
          positions.push({ x: portalBlue.x, y: portalBlue.y });
        }
          break;
        } else {
          // Ajouter la case BLEUE comme atteignable et poursuivre au-del√†
          positions.push({ x: portalBlue.x, y: portalBlue.y });
          if (remaining > 0) {
            // continuer depuis BLEU dans la m√™me direction
            iterateFrom(portalBlue.x, portalBlue.y, dir, remaining, true);
          }
          break;
        }
      }

      if (!occ) {
        positions.push({ x: nx, y: ny });
        continue;
      }
      // Case occup√©e: on peut capturer un ennemi mais on s'arr√™te ensuite
      if (occ.player !== piece.player) {
        // V√©rifier si la pi√®ce cible est prot√©g√©e par l'√©toile
        if (!(starInvincible && starInvincible.playerId === occ.player && starInvincible.untilPlayerTurn)) {
        positions.push({ x: nx, y: ny });
        }
      }
      break;
    }
  };

  // Gestion sp√©ciale pour les cavaliers (mouvements en L)
  const isKnightMove = (dir) => {
    return rule.range === 1 && (
      (Math.abs(dir[0]) === 2 && Math.abs(dir[1]) === 1) || 
      (Math.abs(dir[0]) === 1 && Math.abs(dir[1]) === 2)
    );
  };

  for (let dir of rule.moves) {
    if (isKnightMove(dir)) {
      // Mouvement de cavalier : sauter directement √† la case de destination
      const nx = piece.x + dir[0];
      const ny = piece.y + dir[1];
      if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
        const occ = getPieceAt({ x: nx, y: ny });
        if (!occ) {
          positions.push({ x: nx, y: ny });
        } else if (occ.player !== piece.player) {
          // V√©rifier si la pi√®ce cible est prot√©g√©e par l'√©toile
          if (!(starInvincible && starInvincible.playerId === occ.player && starInvincible.untilPlayerTurn)) {
            positions.push({ x: nx, y: ny });
          }
        }
      }
    } else {
      iterateFrom(piece.x, piece.y, dir, rule.range, false);
    }
  }
  return positions;
}

function getRuleForPiece(piece) {
  // Retourne l'objet { moves, range } pour la pi√®ce, selon faction/type
  const owner = players[piece.player];
  if (!owner) return { moves: [], range: 0 };
  if (piece.type === 'king') {
    const k = kings[owner.faction];
    return k ? { moves: k.moves, range: k.range } : { moves: [], range: 0 };
  }
  const catalog = getCatalogForFaction(owner.faction);
  const entry = catalog[piece.type];
  return entry ? { moves: entry.moves, range: entry.range } : { moves: [], range: 0 };
}

function endGameWithRanking(ranking) {
  gameStarted = false;
  clearHighlights();
  let msg = '';
  if (Array.isArray(ranking) && ranking.length > 0) {
    msg = 'Classement final:\n' + ranking.map((pid, idx) => `${idx+1}. Joueur ${pid+1}`).join('\n');
  } else {
    msg = 'Partie termin√©e.';
  }
  if (turnText) {
    turnText.setText(msg);
  } else if (infoText) {
    infoText.setText(msg);
  }
  // M√©moriser les r√©glages actuels pour relancer facilement
  savePreset();
  // Bouton DOM pour relancer avec les m√™mes r√©glages
  let btn = document.getElementById('restart-same-settings');
  if (btn) btn.remove();
  btn = document.createElement('button');
  btn.id = 'restart-same-settings';
  btn.textContent = 'D√©marrer une nouvelle partie avec les m√™mes r√©glages';
  btn.style.position = 'fixed';
  btn.style.right = '20px';
  btn.style.bottom = '20px';
  btn.style.zIndex = '9999';
  btn.style.padding = '10px 12px';
  btn.style.font = '14px Arial';
  btn.style.background = '#cfc';
  btn.style.border = '1px solid #9c9';
  btn.style.borderRadius = '6px';
  btn.onclick = () => {
    try { localStorage.setItem('vgb_start_with_preset', '1'); } catch(e) {}
    window.location.reload();
  };
  document.body.appendChild(btn);
}

function maybePickupItem(piece) {
  if (!itemCrates || !itemCrates.length) return;
  for (const c of itemCrates) {
    if (!c.active) continue;
    if (piece.x === c.x && piece.y === c.y) {
      const item = rollRandomItem();
      giveItemToPlayer(piece.player, item);
      c.active = false;
      if (c.sprite) { c.sprite.setAlpha(0.25); }
      c.lastRound = roundCounter;
    }
  }
}

function giveItemToPlayer(playerId, itemKey) {
  const scene = infoText.scene;
  // cr√©er une ic√¥ne (empilement jusqu'√† 3 max)
  if (!playerItemIcons[playerId]) playerItemIcons[playerId] = [];
  if (playerItemIcons[playerId].length >= 3) return; // limite 3 objets
  const textureKey = (itemKey === 'portals') ? 'portals' : itemKey;
  const icon = scene.add.image(0,0,textureKey).setDisplaySize(24,24).setInteractive();
  icon.on('pointerdown', () => tryUseItem(playerId, icon));
  // Pour lightning: ajouter compteur 4 tours complets avant utilisation
  const entry = { sprite: icon, item: itemKey };
  if (itemKey === 'lightning') entry.chargeTurns = 5;
  playerItemIcons[playerId].push(entry);
  updatePieces();
}

function tryUseItem(playerId, clickedIconSprite) {
  if (!gameStarted) return;
  if (playerId !== currentPlayer) return; // utiliser √† son tour
  if (itemUsedThisTurn) return; // un seul objet par tour
  const arr = playerItemIcons[playerId] || [];
  if (arr.length === 0) return;
  let idx = 0;
  if (clickedIconSprite) {
    const found = arr.findIndex(e => e && e.sprite === clickedIconSprite);
    if (found >= 0) idx = found;
  }
  const icon = arr[idx];
  if (!icon || !icon.item) return;
  if (icon.item === 'bobomb') {
    // Activer mode pose de bombe: prochain clic sur une case pose et r√©sout l'effet
    currentItemAction = { playerId, type: 'bomb', active: true, inventoryIndex: idx };
    if (infoText) infoText.setText(`Joueur ${playerId+1}: cliquez sur une case pour poser la bombe`);
    // Highlight des cases possibles
    const allowed = getBombPlacablePositions(playerId);
    highlightPositions(allowed, 0xff8a80); // rouge/ros√©
  }
  if (icon.item === 'portals') {
    currentItemAction = { playerId, type: 'portal_orange', active: true, stage: 'orange', inventoryIndex: idx };
    if (infoText) infoText.setText(`Joueur ${playerId+1}: placez le portail ORANGE`);
    const allowed = getAllEmptyCells();
    highlightPositions(allowed, 0xffcc80); // orange p√¢le
  }
  if (icon.item === 'lightning') {
    // Non utilisable tant que charge > 0
    if (icon.chargeTurns && icon.chargeTurns > 0) return;
    // D√©clencher effet √©clair
    triggerLightningEffect();
    // Tuer toutes les pi√®ces sur cases blanches
    applyLightningKill();
    // Consommer l'item s√©lectionn√©
    const useIdx = idx;
    if (playerItemIcons[playerId] && playerItemIcons[playerId].length && useIdx >= 0) {
      const used = playerItemIcons[playerId].splice(useIdx, 1)[0];
      if (used && used.sprite) used.sprite.destroy();
      if (used && used.counterText) used.counterText.destroy();
    }
    itemUsedThisTurn = true;
    updatePieces();
    // Fin de tour apr√®s usage de l'√©clair
    moveCount++;
    if (moveCount % 5 === 0) rotateAds();
    updateAdInfo();
    if (shouldIncrementRoundCounter()) { roundCounter++; }
    currentPlayer = getNextActivePlayer();
    itemUsedThisTurn = false;
    decrementLightningCharges();
    // L'effet √©toile est maintenant g√©r√© dans updateTurnUI()
    maybeRespawnCrate(infoText.scene);
    updateTurnUI();
    // repositionner timers si pr√©sents
    if (timerTexts && playerNameTexts) {
      for (let i=0;i<timerTexts.length;i++) {
        if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
      }
    }
  }
  if (icon.item === 'star') {
    // Activer invincibilit√© jusqu'√† ce que le joueur rejoue
    starInvincible = { playerId, untilRound: -1, untilPlayerTurn: true };
    startStarBlink(playerId);
    try {
      // Arr√™ter un √©ventuel son pr√©c√©dent et jouer celui de l'√©toile
      const s = infoText.scene.sound;
      if (s && s.stopAll) s.stopAll();
      s.play('star', { volume: 0.7, loop: true });
    } catch(e) {}
    // Forcer la mise √† jour imm√©diate de l'effet visuel
    updatePieces();
    // Consommer l'item s√©lectionn√©
    const useIdx = idx;
    if (playerItemIcons[playerId] && playerItemIcons[playerId].length && useIdx >= 0) {
      const used = playerItemIcons[playerId].splice(useIdx, 1)[0];
      if (used && used.sprite) used.sprite.destroy();
    }
    itemUsedThisTurn = true;
    updatePieces();
    // Fin de tour apr√®s usage de l'√©toile
    moveCount++;
    if (moveCount % 5 === 0) rotateAds();
    updateAdInfo();
        let oldRound = roundCounter;
        if (shouldIncrementRoundCounter()) { roundCounter++; }
        currentPlayer = getNextActivePlayer();
        if (roundCounter !== oldRound) {
      decrementLightningCharges();
      // L'effet √©toile est maintenant g√©r√© dans updateTurnUI()
    }
    itemUsedThisTurn = false;
    decrementLightningCharges();
    maybeRespawnCrate(infoText.scene);
    updateTurnUI();
    // repositionner timers si pr√©sents
    if (timerTexts && playerNameTexts) {
      for (let i=0;i<timerTexts.length;i++) {
        if (timerTexts[i] && playerNameTexts[i]) positionTimerTextNearName(timerTexts[i], playerNameTexts[i]);
      }
    }
  }
  if (icon.item === 'tetrimino') {
    // Activer mode pose de tetrimino: prochain clic sur une case pose le mur
    currentItemAction = { playerId, type: 'tetrimino', active: true, inventoryIndex: idx };
    showInfoMessage(`Joueur ${playerId+1}: cliquez sur une case pour placer le tetrimino`, 5000);
    // Highlight des cases possibles
    const allowed = getTetriminoPlacablePositions();
    highlightPositions(allowed, 0xce93d8); // violet p√¢le
  }
  if (icon.item === 'tornado') {
    // Activer mode t√©l√©portation du roi: prochain clic sur une case vide t√©l√©porte le roi
    currentItemAction = { playerId, type: 'tornado', active: true, inventoryIndex: idx };
    showInfoMessage(`Joueur ${playerId+1}: cliquez sur une case vide pour t√©l√©porter votre roi`, 5000);
    // Highlight des cases possibles (cases vides sauf caisses d'objets)
    const allowed = getTornadoTeleportPositions();
    highlightPositions(allowed, 0x81c784); // vert p√¢le
  }
  if (icon.item === 'banana') {
    // Activer mode pose de banane: prochain clic sur une case vide pose la banane
    currentItemAction = { playerId, type: 'banana', active: true, inventoryIndex: idx };
    showInfoMessage(`Joueur ${playerId+1}: cliquez sur une case vide pour placer la banane`, 5000);
    // Highlight des cases possibles (cases vides)
    const allowed = getBananaPlacablePositions();
    highlightPositions(allowed, 0xffd54f); // jaune p√¢le
  }
  if (icon.item === 'phoenix') {
    // Utiliser la queue de phoenix pour ressusciter la derni√®re pi√®ce perdue
    if (tryResurrectLastPiece(playerId)) {
      // Consommer l'item
      if (playerItemIcons[playerId] && playerItemIcons[playerId].length) {
        const used = playerItemIcons[playerId].splice(idx, 1)[0];
        if (used && used.sprite) used.sprite.destroy();
      }
      updatePieces();
    } else {
      // Aucune pi√®ce √† ressusciter
      showInfoMessage(`Joueur ${playerId+1}: aucune pi√®ce perdue √† ressusciter`, 2000);
    }
  }
  if (icon.item === 'cursor') {
    // Activer mode possession: prochain clic sur une pi√®ce faible/moyenne adverse la poss√®de
    currentItemAction = { playerId, type: 'cursor', active: true, inventoryIndex: idx };
    showInfoMessage(`Joueur ${playerId+1}: cliquez sur une pi√®ce faible ou moyenne adverse √† poss√©der`, 5000);
    // Highlight des pi√®ces possibles (faibles et moyennes adverses) en vert p√¢le
    const allowed = getPossessablePieces(playerId);
    highlightPieces(allowed, 0x81c784); // vert p√¢le
  }
  if (icon.item === 'heart') {
    // Activer mode don de c≈ìur: prochain clic sur une pi√®ce lui donne un c≈ìur
    currentItemAction = { playerId, type: 'heart', active: true, inventoryIndex: idx };
    showInfoMessage(`Joueur ${playerId+1}: cliquez sur une pi√®ce pour lui donner un c≈ìur`, 5000);
    // Highlight de toutes les pi√®ces (alli√©es et adverses)
    highlightPieces(pieces, 0xffb3ba); // rose p√¢le
  }
  if (icon.item === 'sandglass') {
    // Utiliser la sabli√®re du temps: r√©duire le temps des adversaires selon la taille du plateau
    if (timerEnabled && playerTimersMs.length > 0) {
      // Calculer le temps √† soustraire selon la taille du plateau
      let timeToSubtract;
      let timeText;
      if (GRID_SIZE === 9) {
        timeToSubtract = 60000; // 1 minute
        timeText = "1 minute";
      } else if (GRID_SIZE === 11) {
        timeToSubtract = 120000; // 2 minutes
        timeText = "2 minutes";
      } else if (GRID_SIZE === 15) {
        timeToSubtract = 180000; // 3 minutes
        timeText = "3 minutes";
      } else {
        timeToSubtract = 60000; // fallback: 1 minute
        timeText = "1 minute";
      }
      
      let affectedPlayers = 0;
      for (let i = 0; i < playerTimersMs.length; i++) {
        if (i !== playerId) {
          // R√©duire le temps de l'adversaire selon la taille du plateau
          playerTimersMs[i] = Math.max(0, playerTimersMs[i] - timeToSubtract);
          affectedPlayers++;
        }
      }
      const plural = affectedPlayers > 1 ? 's' : '';
      showInfoMessage(`Sabli√®re du Temps ! -${timeText} pour ${affectedPlayers} adversaire${plural}`, 3000);
      // Consommer l'item
      if (playerItemIcons[playerId] && playerItemIcons[playerId].length) {
        const used = playerItemIcons[playerId].splice(idx, 1)[0];
        if (used && used.sprite) used.sprite.destroy();
      }
      updatePieces();
    } else {
      showInfoMessage(`Joueur ${playerId+1}: le timer n'est pas activ√© !`, 2000);
    }
  }
  if (icon.item === 'mask') {
    // Activer mode masque de Majora: prochain clic sur une pi√®ce adverse la force
    currentItemAction = { playerId, type: 'mask', active: true, inventoryIndex: idx };
    showInfoMessage(`Joueur ${playerId+1}: cliquez sur une pi√®ce adverse √† forcer`, 5000);
    // Highlight des pi√®ces adverses possibles
    const allowed = pieces.filter(p => p.player !== playerId);
    highlightPieces(allowed, 0xff9800); // orange
  }
  if (icon.item === 'ocarina') {
    // Activer mode ocarina: prochain clic sur une pi√®ce la transforme en cavalier
    currentItemAction = { playerId, type: 'ocarina', active: true, inventoryIndex: idx };
    showInfoMessage(`Joueur ${playerId+1}: cliquez sur une pi√®ce √† transformer en cavalier`, 5000);
    // Highlight de toutes les pi√®ces (alli√©es et adverses)
    highlightPieces(pieces, 0x9c27b0); // violet
  }
}

function getBananaPlacablePositions() {
  const positions = [];
  // V√©rifier toutes les cases vides
  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      // V√©rifier si la banane peut √™tre plac√©e √† cette position
      if (canPlaceBananaAt(x, y)) {
        positions.push({ x, y });
      }
    }
  }
  return positions;
}

function canPlaceBananaAt(x, y) {
  // V√©rifier que la case est dans la grille
  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de pi√®ce sur cette case
  if (getPieceAt({ x, y })) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de caisse d'objet sur cette case
  if (itemCrates.some(c => c.x === x && c.y === y)) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de tetrimino sur cette case
  if (tetriminos.some(t => t.x === x && t.y === y)) {
    return false;
  }
  // V√©rifier qu'il n'y a pas d√©j√† une banane sur cette case
  if (bananas.some(b => b.x === x && b.y === y)) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de portail sur cette case
  if ((portalOrange && portalOrange.x === x && portalOrange.y === y) ||
      (portalBlue && portalBlue.x === x && portalBlue.y === y)) {
    return false;
  }
  return true;
}

function placeBanana(pos) {
  const scene = infoText.scene;
  const sprite = scene.add.image(
    GRID_OFFSET_X + pos.x * TILE_SIZE + TILE_SIZE/2,
    GRID_OFFSET_Y + pos.y * TILE_SIZE + TILE_SIZE/2,
    'banana'
  );
  sprite.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
  sprite.setDepth(150); // au-dessus des cases mais sous les pi√®ces
  bananas.push({ x: pos.x, y: pos.y, sprite });
}

function checkBananaTrip(piece, destination) {
  // V√©rifier si la pi√®ce traverse une banane sur son chemin
  const path = getPathBetween(piece.x, piece.y, destination.x, destination.y);
  
  for (const pos of path) {
    const banana = bananas.find(b => b.x === pos.x && b.y === pos.y);
    if (banana) {
      // 33% de chance de tr√©bucher
      if (Math.random() < 0.33) {
        // La pi√®ce tr√©buche, la d√©placer sur la case de la banane
        piece.x = banana.x;
        piece.y = banana.y;
        // Supprimer la banane
        if (banana.sprite) banana.sprite.destroy();
        const index = bananas.indexOf(banana);
        if (index > -1) bananas.splice(index, 1);
        return true; // tr√©buch√©
      }
    }
  }
  return false; // pas tr√©buch√©
}

function getPathBetween(x1, y1, x2, y2) {
  const path = [];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const steps = Math.max(Math.abs(dx), Math.abs(dy));
  
  if (steps === 0) return path;
  
  for (let i = 1; i <= steps; i++) {
    const x = x1 + Math.round((dx * i) / steps);
    const y = y1 + Math.round((dy * i) / steps);
    path.push({ x, y });
  }
  
  return path;
}

function tryResurrectLastPiece(playerId) {
  // Trouver la derni√®re pi√®ce perdue par ce joueur
  const playerLostPiecesList = playerLostPieces.filter(lp => lp.playerId === playerId);
  if (playerLostPiecesList.length === 0) {
    return false; // Aucune pi√®ce perdue
  }
  
  // Prendre la derni√®re pi√®ce perdue (la plus r√©cente)
  const lastLostPiece = playerLostPiecesList[playerLostPiecesList.length - 1];
  
  // Trouver une case libre pr√®s du roi
  const king = pieces.find(p => p.player === playerId && p.type === 'king');
  if (!king) {
    return false; // Pas de roi trouv√©
  }
  
  const resurrectionPos = findNearestEmptyPosition(king.x, king.y);
  if (!resurrectionPos) {
    return false; // Aucune case libre trouv√©e
  }
  
  // Ressusciter la pi√®ce
  const resurrectedPiece = {
    ...lastLostPiece.piece,
    x: resurrectionPos.x,
    y: resurrectionPos.y,
    player: playerId,
    name: lastLostPiece.piece.name || lastLostPiece.piece.type
  };
  
  // Cr√©er le sprite pour la pi√®ce ressuscit√©e
  const scene = infoText.scene;
  const faction = players[playerId].faction;
  let spriteKey;
  
  if (resurrectedPiece.type === 'king') {
    spriteKey = `king-${faction}`;
  } else {
    // Utiliser le nom de la pi√®ce tel qu'il est d√©fini dans le catalogue
    spriteKey = resurrectedPiece.type;
  }
  
  const sprite = scene.add.image(
    GRID_OFFSET_X + resurrectedPiece.x * TILE_SIZE + TILE_SIZE/2,
    GRID_OFFSET_Y + resurrectedPiece.y * TILE_SIZE + TILE_SIZE/2,
    spriteKey
  );
  sprite.setDisplaySize(TILE_SIZE-2, TILE_SIZE-2);
  sprite.setDepth(200);
  sprite.setInteractive();
  sprite.on('pointerdown', () => handleClick(scene, { x: resurrectedPiece.x, y: resurrectedPiece.y }));
  
  // Ajouter le sprite √† la pi√®ce
  resurrectedPiece.sprite = sprite;
  
  // Ajouter la pi√®ce au tableau des pi√®ces
  pieces.push(resurrectedPiece);
  
  // Supprimer la pi√®ce de la liste des pi√®ces perdues
  const index = playerLostPieces.findIndex(lp => lp === lastLostPiece);
  if (index > -1) {
    playerLostPieces.splice(index, 1);
  }
  
  if (infoText) infoText.setText(`Joueur ${playerId+1}: ${resurrectedPiece.name} ressuscit√©e !`);
  setTimeout(() => {
    if (infoText) infoText.setText("");
  }, 2000);
  
  return true;
}

function findNearestEmptyPosition(kingX, kingY) {
  // Chercher dans un rayon croissant autour du roi
  for (let radius = 1; radius <= 3; radius++) {
    for (let dx = -radius; dx <= radius; dx++) {
      for (let dy = -radius; dy <= radius; dy++) {
        // Ignorer les cases en dehors du rayon actuel
        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
        
        const x = kingX + dx;
        const y = kingY + dy;
        
        // V√©rifier que la position est dans la grille
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
        
        // V√©rifier que la case est libre
        if (isPositionEmpty(x, y)) {
          return { x, y };
        }
      }
    }
  }
  return null; // Aucune case libre trouv√©e
}

function isPositionEmpty(x, y) {
  // V√©rifier qu'il n'y a pas de pi√®ce sur cette case
  if (getPieceAt({ x, y })) return false;
  
  // V√©rifier qu'il n'y a pas de caisse d'objet sur cette case
  if (itemCrates.some(c => c.x === x && c.y === y)) return false;
  
  // V√©rifier qu'il n'y a pas de tetrimino sur cette case
  if (tetriminos.some(t => t.x === x && t.y === y)) return false;
  
  // V√©rifier qu'il n'y a pas de banane sur cette case
  if (bananas.some(b => b.x === x && b.y === y)) return false;
  
  // V√©rifier qu'il n'y a pas de portail sur cette case
  if ((portalOrange && portalOrange.x === x && portalOrange.y === y) ||
      (portalBlue && portalBlue.x === x && portalBlue.y === y)) {
    return false;
  }
  
  return true;
}

function getPossessablePieces(playerId) {
  const possessablePieces = [];
  for (const piece of pieces || []) {
    if (canPossessPiece(piece, playerId)) {
      possessablePieces.push(piece);
    }
  }
  return possessablePieces;
}

function canPossessPiece(piece, playerId) {
  // Ne peut pas poss√©der ses propres pi√®ces
  if (piece.player === playerId) return false;
  
  // Ne peut pas poss√©der les rois
  if (piece.type === 'king') return false;
  
  // V√©rifier le tier de la pi√®ce (faible ou moyen)
  const faction = players[piece.player] && players[piece.player].faction ? players[piece.player].faction : 'nintendo';
  const catalog = getCatalogForFaction(faction);
  
  // Essayer d'abord avec piece.type, puis avec piece.name si piece.type ne fonctionne pas
  let pieceData = catalog[piece.type];
  if (!pieceData && piece.name) {
    pieceData = catalog[piece.name];
  }
  
  if (!pieceData) return false;
  
  // Seulement les pi√®ces de tier 1 (faible) ou 2 (moyen)
  return pieceData.tier === 1 || pieceData.tier === 2;
}

function possessPiece(piece, playerId) {
  const scene = infoText.scene;
  const originalPlayer = piece.player;
  
  // NE PAS changer le propri√©taire de la pi√®ce - elle reste contr√¥l√©e par son joueur d'origine
  
  // D√©placer la pi√®ce pr√®s du roi du joueur d'ORIGINE
  const originalKing = pieces.find(p => p.player === originalPlayer && p.type === 'king');
  if (originalKing) {
    const newPos = findPositionNearKing(originalKing.x, originalKing.y);
    if (newPos) {
      piece.x = newPos.x;
      piece.y = newPos.y;
      if (piece.sprite) {
        piece.sprite.x = GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2;
        piece.sprite.y = GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2;
      }
    }
  }
  
  // Cr√©er le curseur au-dessus de la pi√®ce
  const cursorSprite = scene.add.image(
    GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2 + 15,
    GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2 - 20,
    'cursor'
  );
  cursorSprite.setDisplaySize(20, 20);
  cursorSprite.setDepth(1500); // Au-dessus des pi√®ces
  cursorSprite.setVisible(true);
  
  // Calculer les limites de la "maison" bas√©e sur le joueur d'origine
  const houseBounds = calculateHouseBounds(originalPlayer);
  
  // Enregistrer la possession
  possessedPieces.push({
    piece: piece,
    cursorSprite: cursorSprite,
    originalPlayer: originalPlayer,
    possessorPlayer: playerId,
    houseBounds: houseBounds
  });
  
  if (infoText) infoText.setText(`Joueur ${playerId+1}: ${piece.type} poss√©d√©e !`);
  setTimeout(() => {
    if (infoText) infoText.setText("");
  }, 2000);
}

function findPositionNearKing(kingX, kingY) {
  // Chercher une case libre pr√®s du roi
  for (let radius = 1; radius <= 2; radius++) {
    for (let dx = -radius; dx <= radius; dx++) {
      for (let dy = -radius; dy <= radius; dy++) {
        if (dx === 0 && dy === 0) continue;
        
        const x = kingX + dx;
        const y = kingY + dy;
        
        if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && isPositionEmpty(x, y)) {
          return { x, y };
        }
      }
    }
  }
  return null;
}

function calculateHouseBounds(originalPlayer) {
  // Zones fixes selon la taille du plateau et le joueur
  if (GRID_SIZE === 9) {
    switch(originalPlayer) {
      case 0: return { startX: 2, endX: 6, startY: 0, endY: 2 }; // J1: [1,3] √† [3,7]
      case 1: return { startX: 2, endX: 6, startY: 6, endY: 8 }; // J2: [9,3] √† [7,7]
      case 2: return { startX: 0, endX: 3, startY: 2, endY: 6 }; // J3: [3,1] √† [7,4]
      case 3: return { startX: 6, endX: 8, startY: 2, endY: 6 }; // J4: [3,9] √† [7,7]
      default: return { startX: 0, endX: 0, startY: 0, endY: 0 };
    }
  } else if (GRID_SIZE === 11) {
    switch(originalPlayer) {
      case 0: return { startX: 2, endX: 8, startY: 0, endY: 3 }; // J1: [1,3] √† [4,9]
      case 1: return { startX: 2, endX: 8, startY: 7, endY: 10 }; // J2: [11,3] √† [9,9]
      case 2: return { startX: 0, endX: 3, startY: 2, endY: 8 }; // J3: [3,1] √† [9,4]
      case 3: return { startX: 7, endX: 10, startY: 2, endY: 8 }; // J4: [3,11] √† [9,9]
      default: return { startX: 0, endX: 0, startY: 0, endY: 0 };
    }
  } else { // 15x15
    switch(originalPlayer) {
      case 0: return { startX: 4, endX: 10, startY: 0, endY: 3 }; // J1: [1,5] √† [4,11]
      case 1: return { startX: 4, endX: 10, startY: 11, endY: 14 }; // J2: [15,5] √† [12,11]
      case 2: return { startX: 0, endX: 3, startY: 4, endY: 10 }; // J3: [5,1] √† [11,4]
      case 3: return { startX: 11, endX: 14, startY: 4, endY: 10 }; // J4: [5,15] √† [11,12]
      default: return { startX: 0, endX: 0, startY: 0, endY: 0 };
    }
  }
}

function isWithinHouseBounds(x, y, houseBounds) {
  return x >= houseBounds.startX && x <= houseBounds.endX && 
         y >= houseBounds.startY && y <= houseBounds.endY;
}

function cleanupCursorForPiece(piece) {
  // Nettoyer l'exposant du curseur Sims si la pi√®ce √©tait poss√©d√©e
  const possessedIndex = possessedPieces.findIndex(pp => pp.piece === piece);
  if (possessedIndex >= 0) {
    const possessed = possessedPieces[possessedIndex];
    if (possessed.cursorSprite && possessed.cursorSprite.destroy) {
      possessed.cursorSprite.destroy();
    }
    possessedPieces.splice(possessedIndex, 1);
  }
}

function highlightPieces(pieces, color) {
  clearHighlights();
  for (const piece of pieces) {
    if (piece && piece.sprite) {
      const highlight = piece.sprite.scene.add.rectangle(
        GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2,
        GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2,
        TILE_SIZE,
        TILE_SIZE,
        color
      ).setAlpha(0.3).setDepth(100);
      highlightOverlays.push(highlight);
    }
  }
}

function giveHeartToPiece(piece) {
  // V√©rifier si la pi√®ce a d√©j√† un c≈ìur
  if (heartPieces.some(hp => hp.piece === piece)) {
    if (infoText) infoText.setText("Cette pi√®ce a d√©j√† un c≈ìur !");
    return;
  }
  
  // Cr√©er le sprite du c≈ìur
  const scene = infoText.scene;
  const heartSprite = scene.add.image(
    GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2 + 15,
    GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2 - 15,
    'heart'
  );
  heartSprite.setDisplaySize(16, 16);
  heartSprite.setDepth(1500);
  heartSprite.setVisible(true);
  
  // Ajouter √† la liste des pi√®ces avec c≈ìur
  heartPieces.push({ piece: piece, heartSprite: heartSprite });
  
  if (infoText) infoText.setText(`C≈ìur donn√© √† la pi√®ce !`);
}

function removeHeartFromPiece(piece) {
  // Trouver et supprimer le c≈ìur de la pi√®ce
  const heartIndex = heartPieces.findIndex(hp => hp.piece === piece);
  if (heartIndex >= 0) {
    const heart = heartPieces[heartIndex];
    if (heart.heartSprite && heart.heartSprite.destroy) {
      heart.heartSprite.destroy();
    }
    heartPieces.splice(heartIndex, 1);
  }
}

function removeOcarinaFromPiece(piece) {
  // Trouver et supprimer l'ocarina de la pi√®ce
  const ocarinaIndex = knightPieces.findIndex(kp => kp.piece === piece);
  if (ocarinaIndex >= 0) {
    const knight = knightPieces[ocarinaIndex];
    if (knight.ocarinaSprite && knight.ocarinaSprite.destroy) {
      knight.ocarinaSprite.destroy();
    }
    knightPieces.splice(ocarinaIndex, 1);
  }
}

function updateHeartPositions() {
  // Mettre √† jour la position des c≈ìurs pour qu'ils suivent leurs pi√®ces
  for (const hp of heartPieces) {
    if (hp.heartSprite && hp.piece) {
      hp.heartSprite.x = GRID_OFFSET_X + hp.piece.x * TILE_SIZE + TILE_SIZE/2 + 15;
      hp.heartSprite.y = GRID_OFFSET_Y + hp.piece.y * TILE_SIZE + TILE_SIZE/2 - 15;
    }
  }
}

function updateMaskPosition() {
  // Mettre √† jour la position du masque de Majora
  if (forcedPiece && forcedPiece.maskSprite && forcedPiece.piece) {
    forcedPiece.maskSprite.x = GRID_OFFSET_X + forcedPiece.piece.x * TILE_SIZE + TILE_SIZE/2;
    forcedPiece.maskSprite.y = GRID_OFFSET_Y + forcedPiece.piece.y * TILE_SIZE + TILE_SIZE/2 - 25;
  }
}

function updateOcarinaPositions() {
  // Mettre √† jour les positions des ocarinas
  for (const kp of knightPieces) {
    if (kp.ocarinaSprite && kp.piece) {
      kp.ocarinaSprite.x = GRID_OFFSET_X + kp.piece.x * TILE_SIZE + TILE_SIZE/2;
      kp.ocarinaSprite.y = GRID_OFFSET_Y + kp.piece.y * TILE_SIZE + TILE_SIZE/2 - 25;
    }
  }
}

function applyMaskToPiece(piece) {
  // Nettoyer l'ancien masque s'il existe
  if (forcedPiece && forcedPiece.maskSprite) {
    forcedPiece.maskSprite.destroy();
  }
  
  // Cr√©er le sprite du masque
  const scene = infoText.scene;
  const maskSprite = scene.add.image(0, 0, 'mask');
  maskSprite.setDisplaySize(20, 20);
  maskSprite.setDepth(1500);
  
  // Positionner le masque au-dessus de la pi√®ce
  maskSprite.x = GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2;
  maskSprite.y = GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2 - 25;
  
  // Stocker l'information du masque
  forcedPiece = {
    piece: piece,
    playerId: piece.player,
    maskSprite: maskSprite
  };
  
  showInfoMessage(`Masque de Majora ! Le joueur ${piece.player + 1} devra jouer cette pi√®ce !`, 3000);
}

function applyOcarinaToPiece(piece) {
  // V√©rifier si la pi√®ce n'est pas d√©j√† un cavalier
  const existingKnight = knightPieces.find(kp => kp.piece === piece);
  if (existingKnight) {
    showInfoMessage(`Cette pi√®ce est d√©j√† transform√©e en cavalier !`, 2000);
    return;
  }
  
  // Cr√©er le sprite de l'ocarina
  const scene = infoText.scene;
  const ocarinaSprite = scene.add.image(0, 0, 'ocarina');
  ocarinaSprite.setDisplaySize(18, 18);
  ocarinaSprite.setDepth(1500);
  
  // Positionner l'ocarina au-dessus de la pi√®ce
  ocarinaSprite.x = GRID_OFFSET_X + piece.x * TILE_SIZE + TILE_SIZE/2;
  ocarinaSprite.y = GRID_OFFSET_Y + piece.y * TILE_SIZE + TILE_SIZE/2 - 25;
  
  // Stocker l'information du cavalier
  knightPieces.push({
    piece: piece,
    ocarinaSprite: ocarinaSprite
  });
  
  // Jouer le son de l'Ocarina
  scene.sound.play('ocarina');
  
  showInfoMessage(`Ocarina du Temps ! Cette pi√®ce devient un cavalier !`, 3000);
}

function getReachablePositions(piece) {
  if (!piece) return [];
  
  // V√©rifier si la pi√®ce est transform√©e en cavalier par l'Ocarina
  const isKnight = knightPieces.some(kp => kp.piece === piece);
  
  if (isKnight) {
    return getKnightMoves(piece);
  } else {
    // Utiliser la logique de mouvement originale du jeu
    // Pour l'instant, on retourne un mouvement simple en attendant d'identifier la vraie logique
    return getOriginalMoves(piece);
  }
}

function getKnightMoves(piece) {
  const moves = [];
  const knightOffsets = [
    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
    [1, -2], [1, 2], [2, -1], [2, 1]
  ];
  
  for (const [dx, dy] of knightOffsets) {
    const newX = piece.x + dx;
    const newY = piece.y + dy;
    
    // V√©rifier que la position est dans la grille
    if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) continue;
    
    // V√©rifier s'il y a une pi√®ce sur cette case
    const targetPiece = getPieceAt({x: newX, y: newY});
    
    if (!targetPiece) {
      // Case vide - mouvement valide
      moves.push({x: newX, y: newY});
    } else if (targetPiece.player !== piece.player) {
      // Pi√®ce ennemie - capture possible
      moves.push({x: newX, y: newY});
    }
    // Si c'est une pi√®ce alli√©e, on ne peut pas aller sur cette case
  }
  
  return moves;
}

function getOriginalMoves(piece) {
  const moves = [];
  
  // Obtenir les donn√©es de mouvement de la pi√®ce
  const pieceData = getPieceMovementData(piece);
  if (!pieceData) {
    // Fallback : mouvement de roi si pas de donn√©es
    return getBasicKingMoves(piece);
  }
  
  const { moves: moveDirections, range } = pieceData;
  
  // Appliquer chaque direction de mouvement
  for (const [dx, dy] of moveDirections) {
    // Parcourir dans cette direction jusqu'√† la port√©e maximale
    for (let distance = 1; distance <= range; distance++) {
      const newX = piece.x + dx * distance;
      const newY = piece.y + dy * distance;
      
      // V√©rifier limites de grille
      if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) break;
      
      const targetPiece = getPieceAt({x: newX, y: newY});
      
      if (!targetPiece) {
        // Case vide - mouvement valide
        moves.push({x: newX, y: newY});
      } else if (targetPiece.player !== piece.player) {
        // Pi√®ce ennemie - capture possible puis arr√™t
        moves.push({x: newX, y: newY});
        break;
      } else {
        // Pi√®ce alli√©e - arr√™t
        break;
      }
    }
  }
  
  return moves;
}

function getPieceMovementData(piece) {
  // Obtenir la faction du joueur
  const player = players[piece.player];
  const faction = player ? player.faction : 'nintendo';
  
  if (piece.type === 'king') {
    // Donn√©es du roi pour cette faction
    return kings[faction];
  } else {
    // Donn√©es de la pi√®ce dans le catalogue de faction
    const catalog = factionCatalogs[faction];
    return catalog ? catalog[piece.type] : null;
  }
}

function getBasicKingMoves(piece) {
  // Mouvement de base du roi en cas de fallback
  const moves = [];
  const directions = [
    [-1, -1], [-1, 0], [-1, 1],
    [0, -1],           [0, 1],
    [1, -1],  [1, 0],  [1, 1]
  ];
  
  for (const [dx, dy] of directions) {
    const newX = piece.x + dx;
    const newY = piece.y + dy;
    if (isValidMove(piece, newX, newY)) {
      moves.push({x: newX, y: newY});
    }
  }
  
  return moves;
}

function isValidMove(piece, x, y) {
  // V√©rifier que la position est dans la grille
  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return false;
  
  // V√©rifier s'il y a une pi√®ce sur cette case
  const targetPiece = getPieceAt({x, y});
  
  if (!targetPiece) {
    // Case vide - mouvement valide
    return true;
  } else if (targetPiece.player !== piece.player) {
    // Pi√®ce ennemie - capture possible
    return true;
  }
  
  // Pi√®ce alli√©e - mouvement invalide
  return false;
}

function isPiecePossessedByCurrentPlayer(piece) {
  const possessed = possessedPieces.find(pp => pp.piece === piece);
  return possessed && possessed.possessorPlayer === currentPlayer;
}

function getTornadoTeleportPositions() {
  const positions = [];
  // V√©rifier toutes les cases vides (sauf caisses d'objets)
  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      // V√©rifier si la case est vide et peut recevoir le roi
      if (canTeleportKingTo(x, y)) {
        positions.push({ x, y });
      }
    }
  }
  return positions;
}

function canTeleportKingTo(x, y) {
  // V√©rifier que la case est dans la grille
  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de pi√®ce sur cette case
  if (getPieceAt({ x, y })) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de caisse d'objet sur cette case
  if (itemCrates.some(c => c.x === x && c.y === y)) {
    return false;
  }
  // V√©rifier qu'il n'y a pas de tetrimino sur cette case
  if (tetriminos.some(t => t.x === x && t.y === y)) {
    return false;
  }
  return true;
}

function teleportKingTo(playerId, newPos) {
  // Trouver le roi du joueur
  const king = pieces.find(p => p.player === playerId && p.type === 'king');
  if (!king) return;
  
  // Mettre √† jour la position du roi
  king.x = newPos.x;
  king.y = newPos.y;
  
  // Mettre √† jour la position visuelle du sprite
  if (king.sprite) {
    king.sprite.x = GRID_OFFSET_X + newPos.x * TILE_SIZE + TILE_SIZE/2;
    king.sprite.y = GRID_OFFSET_Y + newPos.y * TILE_SIZE + TILE_SIZE/2;
  }
}

function getTetriminoPlacablePositions() {
  const positions = [];
  // V√©rifier toutes les positions possibles pour le tetrimino (forme T invers√©)
  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE; y++) {
      // V√©rifier si le tetrimino peut √™tre plac√© √† cette position
      if (canPlaceTetriminoAt(x, y)) {
        positions.push({ x, y });
      }
    }
  }
  return positions;
}

function canPlaceTetriminoAt(centerX, centerY) {
  // Forme T invers√© : 3 cases horizontales + 1 case en dessous du milieu
  const positions = [
    { x: centerX - 1, y: centerY },     // gauche
    { x: centerX, y: centerY },         // centre
    { x: centerX + 1, y: centerY },     // droite
    { x: centerX, y: centerY + 1 }      // en dessous du centre
  ];
  
  // V√©rifier que toutes les positions sont dans la grille
  for (const pos of positions) {
    if (pos.x < 0 || pos.x >= GRID_SIZE || pos.y < 0 || pos.y >= GRID_SIZE) {
      return false;
    }
    // V√©rifier qu'il n'y a pas de pi√®ce sur cette case
    if (getPieceAt(pos)) {
      return false;
    }
    // V√©rifier qu'il n'y a pas d√©j√† un tetrimino sur cette case
    if (tetriminos.some(t => t.x === pos.x && t.y === pos.y)) {
      return false;
    }
    // V√©rifier qu'il n'y a pas de caisse d'objet sur cette case
    if (itemCrates.some(c => c.x === pos.x && c.y === pos.y)) {
      return false;
    }
    // V√©rifier qu'il n'y a pas de portail sur cette case
    if ((portalOrange && portalOrange.x === pos.x && portalOrange.y === pos.y) ||
        (portalBlue && portalBlue.x === pos.x && portalBlue.y === pos.y)) {
      return false;
    }
  }
  return true;
}

function placeTetrimino(centerPos) {
  const scene = infoText.scene;
  const positions = [
    { x: centerPos.x - 1, y: centerPos.y },     // gauche
    { x: centerPos.x, y: centerPos.y },         // centre
    { x: centerPos.x + 1, y: centerPos.y },     // droite
    { x: centerPos.x, y: centerPos.y + 1 }      // en dessous du centre
  ];
  
  // Cr√©er des rectangles violets pour chaque case du tetrimino
  for (const pos of positions) {
    const rect = scene.add.rectangle(
      GRID_OFFSET_X + pos.x * TILE_SIZE + TILE_SIZE/2,
      GRID_OFFSET_Y + pos.y * TILE_SIZE + TILE_SIZE/2,
      TILE_SIZE-2,
      TILE_SIZE-2,
      0x9c27b0 // violet
    );
    rect.setDepth(100); // au-dessus des cases mais sous les pi√®ces
    tetriminos.push({ x: pos.x, y: pos.y, sprite: rect });
  }
}

function getBombPlacablePositions(playerId) {
  const positions = [];
  // toutes cases √† distance de Manhattan <= 2 d'au moins une pi√®ce du joueur
  const myPieces = pieces.filter(p => p.player === playerId);
  const seen = new Set();
  for (let mp of myPieces) {
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = -2; dy <= 2; dy++) {
        const x = mp.x + dx;
        const y = mp.y + dy;
        if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE) continue;
        const manhattan = Math.abs(dx) + Math.abs(dy);
        if (manhattan <= 2) {
          const key = x+","+y;
          if (!seen.has(key)) { positions.push({ x, y }); seen.add(key); }
        }
      }
    }
  }
  return positions;
}

function canPlaceBombAt(pos, playerId) {
  const allowed = getBombPlacablePositions(playerId);
  return allowed.some(p => p.x === pos.x && p.y === pos.y);
}

function getAllEmptyCells() {
  const cells = [];
  for (let y=0; y<GRID_SIZE; y++) {
    for (let x=0; x<GRID_SIZE; x++) {
      if (!getPieceAt({x,y})) cells.push({x,y});
    }
  }
  return cells;
}

function detonateBombAt(pos) {
  // Effets visuels et sonores
  const scene = infoText.scene;
  try { scene.sound.play('bobomb', { volume: 0.6 }); } catch(e) {}
  // flash rouge sur la zone
  const centerX = GRID_OFFSET_X + pos.x*TILE_SIZE + TILE_SIZE/2;
  const centerY = GRID_OFFSET_Y + pos.y*TILE_SIZE + TILE_SIZE/2;
  const flash = scene.add.rectangle(centerX, centerY, TILE_SIZE*3, TILE_SIZE*3, 0xff5252).setAlpha(0.4).setDepth(3000);
  scene.tweens.add({ targets: flash, alpha: 0, duration: 220, onComplete: () => flash.destroy() });
  // onde circulaire
  const ring = scene.add.circle(centerX, centerY, 6, 0xff1744).setAlpha(0.7).setDepth(3001);
  scene.tweens.add({ targets: ring, radius: TILE_SIZE*1.2, alpha: 0, duration: 300, onComplete: () => ring.destroy() });

  // D√©truire pi√®ces sur la case et les 8 adjacentes (zone 3x3)
  const deltas = [];
  for (let dx=-1; dx<=1; dx++) {
    for (let dy=-1; dy<=1; dy++) {
      deltas.push({x:dx,y:dy});
    }
  }
  for (let d of deltas) {
    const tx = pos.x + d.x;
    const ty = pos.y + d.y;
    if (tx < 0 || ty < 0 || tx >= GRID_SIZE || ty >= GRID_SIZE) continue;
    const victim = getPieceAt({ x: tx, y: ty });
    if (victim) {
      // V√©rifier si la pi√®ce est prot√©g√©e par l'√©toile
      if (starInvincible && starInvincible.playerId === victim.player && starInvincible.untilPlayerTurn) {
        continue; // Pi√®ce immunis√©e, passer √† la suivante
      }
      const wasKing = victim.type === 'king';
      // Enregistrer la pi√®ce perdue pour la queue de phoenix
      playerLostPieces.push({ playerId: victim.player, piece: { ...victim } });
      // Nettoyer l'exposant du curseur Sims si la pi√®ce √©tait poss√©d√©e
      cleanupCursorForPiece(victim);
      // Nettoyer l'ocarina si la pi√®ce en avait un
      removeOcarinaFromPiece(victim);
      victim.sprite.destroy();
      pieces = pieces.filter(p => !(p.x === tx && p.y === ty && p.player === victim.player && p.type === victim.type));
      if (wasKing) {
        if (!eliminationOrder.includes(victim.player)) eliminationOrder.push(victim.player);
      }
    }
  }
  // L'item bombe est d√©j√† consomm√© dans handleClick, pas besoin de le refaire ici
  updatePieces();
  // V√©rifier condition de fin
  const remainingKings = pieces.filter(pp => pp.type === 'king').length;
  if (infoText) infoText.setText("");
  if (remainingKings <= 1) {
    let winnerId = null;
    const kingPiece = pieces.find(pp => pp.type === 'king');
    if (kingPiece) winnerId = kingPiece.player;
    let ranking = [];
    if (winnerId !== null) ranking.push(winnerId);
    const rest = eliminationOrder.slice().reverse();
    for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
    endGameWithRanking(ranking);
  }
}

function maybeRespawnCrate(scene) {
  if (!itemCrates || !itemCrates.length) return;
  // R√©appara√Æt tous les 3 tours depuis la derni√®re interaction de chaque caisse
  for (const c of itemCrates) {
    if (c.active) continue;
    if ((roundCounter - c.lastRound) >= 3) {
      c.active = true;
      if (!c.sprite) {
        c.sprite = scene.add.image(0,0,'item-crate');
        c.sprite.setDisplaySize(TILE_SIZE*0.6, TILE_SIZE*0.6);
      }
      c.sprite.setAlpha(1);
      // pas besoin de recaler x/y ici, updatePieces() le fera
    }
  }
  updatePieces();
}

function rollRandomItem() {
  // Tirage pond√©r√© selon ITEM_WEIGHTS
  const entries = Object.entries(ITEM_WEIGHTS);
  const total = entries.reduce((s, [,w]) => s + (w||0), 0);
  if (total <= 0) return 'bobomb';
  let r = Math.random() * total;
  for (const [key, weight] of entries) {
    r -= weight;
    if (r <= 0) return key;
  }
  return entries[entries.length-1][0];
}

function clearHighlights() {
  for (let tile of highlightedTiles) {
    tile.setFillStyle(tile.baseColor);
  }
  highlightedTiles = [];
  
  // Nettoyer aussi les overlays de pi√®ces (pour le curseur Sims)
  for (let overlay of highlightOverlays) {
    if (overlay && overlay.destroy) {
      overlay.destroy();
    }
  }
  highlightOverlays = [];
}

function highlightPositions(positions, color = 0xfff59d) {
  clearHighlights();
  for (let pos of positions) {
    const tile = grid[pos.y][pos.x];
    tile.setFillStyle(color);
    highlightedTiles.push(tile);
  }
}

function checkStarEffect() {
  // V√©rifier si l'effet de l'√©toile doit se terminer
  if (starInvincible && starInvincible.playerId >= 0 && starInvincible.untilPlayerTurn && starInvincible.playerId === currentPlayer) {
    // L'√©toile se termine car le joueur qui l'a utilis√©e rejoue
    stopStarBlink(starInvincible.playerId);
    clearStarOverlays();
    try {
      const s = infoText.scene.sound;
      if (s && s.stopByKey) s.stopByKey('star'); else if (s && s.stopAll) s.stopAll();
    } catch(e) {}
    starInvincible = { playerId: -1, untilRound: -1, untilPlayerTurn: false };
  }
}

function updateTurnUI() {
  const mid = getKingCenterIndex(GRID_SIZE);
  
  // V√©rifier si le joueur actuel est √©limin√© et passer au suivant si n√©cessaire
  if (eliminationOrder.includes(currentPlayer)) {
    currentPlayer = getNextActivePlayer();
    // Appeler r√©cursivement pour s'assurer que le nouveau joueur n'est pas √©limin√© non plus
    updateTurnUI();
    return;
  }
  
  // V√©rifier si l'effet de l'√©toile doit se terminer
  checkStarEffect();
  
  // Si le joueur actuel a une pi√®ce forc√©e par le masque de Majora, la s√©lectionner automatiquement
  if (forcedPiece && forcedPiece.playerId === currentPlayer && forcedPiece.piece) {
    selectedPiece = forcedPiece.piece;
    const reachable = getReachablePositions(selectedPiece);
    highlightPositions(reachable);
    showInfoMessage(`Vous √™tes forc√© de jouer cette pi√®ce par le Masque de Majora !`, 5000);
  } else {
    // D√©s√©lectionner toute pi√®ce si pas de contrainte
    selectedPiece = null;
    clearHighlights();
  }
  
  // Positionner l'ic√¥ne de tour √† c√¥t√© du nom du joueur actif
  if (turnIcon && playerNameTexts[currentPlayer]) {
    const t = playerNameTexts[currentPlayer];
    const side = (currentPlayer===0)?'top':(currentPlayer===1)?'bottom':(currentPlayer===2)?'left':'right';
    
    if (side === 'top') {
      // Joueur du haut : manette √† gauche du nom, bien √©loign√©e
      turnIcon.x = t.x - 56;
      turnIcon.y = t.y - 34;
    } else if (side === 'bottom') {
      // Joueur du bas : manette √† gauche du nom, bien √©loign√©e
      turnIcon.x = t.x - 56;
      turnIcon.y = t.y + 10;
    } else if (side === 'left') {
      // Joueur de gauche : manette au-dessus du nom, bien √©loign√©e
      turnIcon.x = t.x;
      turnIcon.y = t.y - 50;
    } else { // right
      // Joueur de droite : manette au-dessus du nom, bien √©loign√©e
      turnIcon.x = t.x;
      turnIcon.y = t.y - t.displayHeight/2 - 50;
    }
    
    // Rotation de l'ic√¥ne selon c√¥t√©
    if (side === 'left') turnIcon.setAngle(-90); else if (side === 'right') turnIcon.setAngle(90); else turnIcon.setAngle(0);
  }
  // Mettre √† jour la position des ic√¥nes d'objets √† c√¥t√© des noms
  updatePieces();
}

function decrementLightningCharges() {
  for (let i=0; i<playerItemIcons.length; i++) {
    const arr = playerItemIcons[i] || [];
    for (const e of arr) {
      if (e && e.item === 'lightning' && e.chargeTurns && e.chargeTurns > 0) {
        e.chargeTurns = Math.max(0, e.chargeTurns - 1);
      }
    }
  }
  updatePieces();
}

function triggerLightningEffect() {
  const scene = infoText.scene;
  // flash global
  const flash = scene.add.rectangle(GRID_OFFSET_X + GRID_SIZE*TILE_SIZE/2, GRID_OFFSET_Y + GRID_SIZE*TILE_SIZE/2, GRID_SIZE*TILE_SIZE, GRID_SIZE*TILE_SIZE, 0xffff8d).setAlpha(0.35).setDepth(2900);
  scene.tweens.add({ targets: flash, alpha: 0, duration: 250, onComplete: () => flash.destroy() });
}

function isWhiteSquare(x, y) {
  // m√™me logique que baseColor (x+y)%2===0 blanc
  return ((x + y) % 2) === 0;
}

function applyLightningKill() {
  // Supprimer toutes les pi√®ces sur cases blanches (y compris celles du lanceur)
  const victims = pieces.filter(p => isWhiteSquare(p.x, p.y) && !(starInvincible && starInvincible.playerId === p.player && starInvincible.untilPlayerTurn));
  let kingDied = false;
  for (const v of victims) {
    // Enregistrer la pi√®ce perdue pour la queue de phoenix
    playerLostPieces.push({ playerId: v.player, piece: { ...v } });
    // Nettoyer l'exposant du curseur Sims si la pi√®ce √©tait poss√©d√©e
    cleanupCursorForPiece(v);
    // Nettoyer l'ocarina si la pi√®ce en avait un
    removeOcarinaFromPiece(v);
    if (v && v.sprite) v.sprite.destroy();
    if (v.type === 'king') {
      kingDied = true;
      if (!eliminationOrder.includes(v.player)) eliminationOrder.push(v.player);
    }
  }
  // Conserver les pi√®ces prot√©g√©es par l'√©toile m√™me si elles sont sur case blanche
  pieces = pieces.filter(p => !(isWhiteSquare(p.x, p.y) && !(starInvincible && starInvincible.playerId === p.player && starInvincible.untilPlayerTurn)));
  updatePieces();
  if (kingDied) {
    const remainingKings = pieces.filter(pp => pp.type === 'king').length;
    if (remainingKings <= 1) {
      let winnerId = null;
      const kingPiece = pieces.find(pp => pp.type === 'king');
      if (kingPiece) winnerId = kingPiece.player;
      let ranking = [];
      if (winnerId !== null) ranking.push(winnerId);
      const rest = eliminationOrder.slice().reverse();
      for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
      endGameWithRanking(ranking);
    }
  }
}

function update() {}

function positionTimerTextNearName(timerText, nameText) {
  if (!timerText || !nameText) return;
  // D√©terminer le c√¥t√© du joueur pour positionner le timer
  const playerIndex = playerNameTexts.indexOf(nameText);
  const side = (playerIndex===0)?'top':(playerIndex===1)?'bottom':(playerIndex===2)?'left':'right';
  
  if (side === 'top') {
    // Joueur du haut : timer √† droite du nom, align√© avec les objets
    timerText.x = nameText.x - 20;
    timerText.y = nameText.y - 28;
  } else if (side === 'bottom') {
    // Joueur du bas : timer en dessous du nom, align√© avec les objets
    timerText.x = nameText.x - 20;
    timerText.y = nameText.y + nameText.displayHeight - 5;
  } else if (side === 'left') {
    // Joueur de gauche : timer √† gauche du nom, align√© avec les objets
    //timerText.x = nameText.x - nameText.displayWidth - 30;
    timerText.x = nameText.x - 20;
    //timerText.y = nameText.y - nameText.displayHeight/2 + 15;
    timerText.y = nameText.y - 15;
  } else { // right
    // Joueur de droite : timer √† droite du nom, align√© avec les objets
    timerText.x = nameText.x + nameText.displayWidth + 30;
    timerText.y = nameText.y - nameText.displayHeight/2 + 15;
  }
}

function formatMs(ms) {
  const s = Math.max(0, Math.floor(ms/1000));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

function tickTimer(scene) {
  if (!gameStarted || !timerEnabled) return;
  if (players.length === 0) return;
  const nowIdx = currentPlayer;
  playerTimersMs[nowIdx] = Math.max(0, playerTimersMs[nowIdx] - 250);
  // MAJ texte
  if (timerTexts[nowIdx]) timerTexts[nowIdx].setText(formatMs(playerTimersMs[nowIdx]));
  // feedback visuel sous 10s
  const under10 = playerTimersMs[nowIdx] <= 30000;
  if (timerTexts[nowIdx]) {
    if (under10) {
      timerBlinkToggle = !timerBlinkToggle;
      timerTexts[nowIdx].setColor('#b00020');
      timerTexts[nowIdx].setAlpha(timerBlinkToggle ? 1 : 0.4);
    } else {
      timerTexts[nowIdx].setColor('#333333');
      timerTexts[nowIdx].setAlpha(1);
    }
  }
  // repositionner (si layout bouge)
  if (timerTexts[nowIdx] && playerNameTexts[nowIdx]) positionTimerTextNearName(timerTexts[nowIdx], playerNameTexts[nowIdx]);
  // D√©faite sur timeout
  if (playerTimersMs[nowIdx] === 0) {
    if (!eliminationOrder.includes(nowIdx)) {
      eliminationOrder.push(nowIdx);
      
      // Supprimer TOUTES les pi√®ces du joueur √©limin√© par timeout
      const eliminatedPlayerId = nowIdx;
      const piecesToRemove = pieces.filter(p => p.player === eliminatedPlayerId);
      
      for (const piece of piecesToRemove) {
        // Nettoyer les √©l√©ments associ√©s avant suppression
        cleanupCursorForPiece(piece);
        removeHeartFromPiece(piece);
        removeOcarinaFromPiece(piece);
        if (piece.sprite) piece.sprite.destroy();
      }
      
      // Retirer toutes les pi√®ces du joueur √©limin√© du tableau pieces
      pieces = pieces.filter(p => p.player !== eliminatedPlayerId);
      
      // Annoncer l'√©limination par timeout
      const eliminatedPlayer = players[nowIdx];
      showInfoMessage(`‚è∞ ${eliminatedPlayer.name} a perdu par timeout ! Toutes ses pi√®ces ont disparu.`, 3000);
    }
    // v√©rifier fin
    const remainingKings = pieces.filter(pp => pp.type === 'king').length;
    if (remainingKings <= 1) {
      let winnerId = null;
      const kingPiece = pieces.find(pp => pp.type === 'king');
      if (kingPiece) winnerId = kingPiece.player;
      let ranking = [];
      if (winnerId !== null) ranking.push(winnerId);
      const rest = eliminationOrder.slice().reverse();
      for (let pid of rest) if (winnerId === null || pid !== winnerId) ranking.push(pid);
      endGameWithRanking(ranking);
    }
  }
}

function endGameWithRanking(ranking) {
  // Cr√©er le message de fin de partie avec le classement
  let message = "üèÜ FIN DE PARTIE üèÜ\n\n";
  
  for (let i = 0; i < ranking.length; i++) {
    const playerId = ranking[i];
    const player = players[playerId];
    const position = i + 1;
    const emoji = position === 1 ? "ü•á" : position === 2 ? "ü•à" : position === 3 ? "ü•â" : "üèÖ";
    
    message += `${emoji} ${position}er : ${player.name}\n`;
  }
  
  // Afficher le message de mani√®re permanente avec le bouton int√©gr√©
  showEndGameMessage(message);
}

function showEndGameMessage(message) {
  if (!infoText || !infoBackground) return;
  
  // Marquer que c'est un message de fin de partie permanent
  isEndGameMessage = true;
  
  const scene = infoText.scene;
  
  // Calculer la taille n√©cessaire pour le message + bouton
  const textWidth = Math.min(500, Math.max(300, message.length * 8));
  const textHeight = 140; // Hauteur fixe pour message + bouton plus bas
  
  // Ajuster la taille du fond pour inclure le bouton
  infoBackground.setSize(textWidth + 32, textHeight); // +32 pour le padding
  infoBackground.setVisible(true);
  
  // Afficher le message (PERMANENT - pas de timeout)
  infoText.setText(message);
  infoText.setVisible(true);
  
  // Cr√©er le bouton "Nouvelle Partie" int√©gr√© dans le message
  const buttonY = 380; // Position du bouton plus bas sous le message
  
  // Cr√©er le fond du bouton
  const buttonBackground = scene.add.rectangle(448, buttonY, 180, 40, 0x4CAF50);
  buttonBackground.setDepth(10001);
  buttonBackground.setStrokeStyle(2, 0x2E7D32);
  buttonBackground.setInteractive();
  
  // Cr√©er le texte du bouton
  const button = scene.add.text(448, buttonY, "üéÆ Nouvelle Partie", {
    font: "18px Arial",
    fill: "#ffffff"
  });
  button.setOrigin(0.5, 0.5);
  button.setDepth(10002);
  button.setInteractive();
  
  // Style du bouton au survol
  buttonBackground.on('pointerover', () => {
    buttonBackground.setFillStyle(0x45a049);
  });
  
  buttonBackground.on('pointerout', () => {
    buttonBackground.setFillStyle(0x4CAF50);
  });
  
  // Action du bouton : recharger la page
  const reloadGame = () => {
    location.reload();
  };
  
  buttonBackground.on('pointerdown', reloadGame);
  button.on('pointerdown', reloadGame);
}

new Phaser.Game(config);

// --- Publicit√©s ---
const ADS = [
  { a1: 'Retro Console XL', a2: 'Promo -30%' },
  { a1: 'Figurines 8-bit', a2: 'Nouveaut√©s' },
  { a1: 'Cartouches Repro', a2: 'Rare Loot' },
  { a1: 'T-shirts Pixel', a2: 'Collection 2025' },
];

function rotateAds() {
  adRotationIndex = (adRotationIndex + 1) % ADS.length;
  const data = ADS[adRotationIndex];
  const s1 = document.getElementById('ad-slot-1');
  const s2 = document.getElementById('ad-slot-2');
  if (s1) s1.textContent = data.a1;
  if (s2) s2.textContent = data.a2;
  updateAdInfo(true);
}

function updateAdInfo(reset = false) {
  const info = document.getElementById('ad-info');
  if (!info) return;
  const nextIn = reset ? 5 : (5 - (moveCount % 5));
  const plural = nextIn >= 2 ? 's' : '';
  info.textContent = `Mise √† jour dans ${nextIn} action${plural} (toutes les 5 actions)`;
}

/* https://www.reddit.com/r/retrogaming/comments/1hkzmcw/i_redrew_some_nes_sprites_of_various_nintendo/?tl=fr */
</script>
</body>